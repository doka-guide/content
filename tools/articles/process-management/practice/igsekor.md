---
tags:
  - practice
permalink: false
---

## Управление процессами

В Windows управление процессами сводится к диспетчеру задач, который имеет графический интерфейс пользователя. С помощью этой утилиты можно запускать и останавливать разные процессы. В Unix-подобных операционных системах, которые являются изначально многопользовательскими, предусмотрены довольно развитые механизмы управления процессами.

Все процессы в Unix-подобных операционных системах делятся на фоновые (background) и приоритетные (foreground). В статье [Интерфейс командной строки](/tools/article/cli) описано использование Терминала для запуска приоритетных процессов. Приоритетный режим означает, что Терминал будет ожидать завершения процесса и не будет доступен для ввода новых команд до его завершения.

Иногда удобнее использовать фоновые процесс. Например, если мы хотим все время посылать запросы сетевому устройству с помощью команды `ping`, как это было описано в статье [Работа с сетью](/tools/articles/network):

```bash
ping 8.8.8.8 -i 15 &
> [1] <PID>
```

Символ `&` в конце строки команды и означает запуск процесса в фоновом режиме. `<PID>` (от Process Identifier) — идентификационный номер процесса. Зная его, можно отслеживать состояние процесса, подавать ему сигналы или управлять им напрямую средствами операционной системы. `[1]` — обозначает номер задания (фонового процесса пользователя, который запущен из данного Терминала). Значения ключа `-i` устанавливает количество секунд между запросами к серверу.

Если запустить другой процесс, например, разархивировать другой архив, то вы увидите, что номер сменился:

```bash
ping 8.8.4.4 -i 10 &
> [2] <PID>
```

Изменится также и PID. Вы можете посмотреть список задач, для этого используется команда:

```bash
jobs
> [1]  - running    ping 8.8.8.8
> [2]  + running    ping 8.8.4.4
```

Чтобы перевести процесс из фонового в приоритетный режим, можно используется команду `fg`. выполнить её без аргументов, то она переведёт последний фоновый процесс в приоритетный режим. В нашем случае, это будет процесс под номером `[2]`.

Запустим процесс в приоритетном режиме и нажмём сочетание клавиш <kbd>Ctrl Z</kbd>:

```bash
ping 8.8.8.8 -i 15
^Z
> [1]  + 22495 suspended  ping 8.8.8.8 -i 15
```

Вызовем список процессов с помощью `jobs`:

```bash
jobs
> [1]  + suspended  ping 8.8.8.8 -i 15
```

То есть процесс не завершён, а именно остановлен. Его можно продолжить командой `bg` и перевести в фоновый режим:

```bash
bg
> [1]  + 22495 continued  ping 8.8.8.8 -i 15
> 64 bytes from 8.8.8.8: icmp_seq=1 ttl=108 time=28.854 ms

jobs
> [1]  + running    ping 8.8.8.8 -i 15
```

Можно просмотреть и все процессы, запущенные не только из текущего Терминала так:

```bash
top
```

Утилита `top` показывает не только работающие процессы, но и свободную оперативную память, нагрузку на ядра процессора и состояние [своп-файла](https://ru.wikipedia.org/wiki/Подкачка_страниц). С помощью нажатия клавиши <kbd>Q</kbd> на клавиатуре можно выйти из `top`, а нажатие клавиши <kbd>?</kbd> позволяет вывести справку по использованию этой утилиты.

Утилита `top` используется дял мониторинга состояния операционной системы. Для того, чтобы получить отчёт о процессах используют утилиту `ps`. Название утилиты образовалось от «Process Status». Выполнение этой команды в Терминале приведёт к выводу списка терминалов. А если добавить ключ `-A`, вы получите список всех текущих процессов в операционной системе:

```bash
ps -A
```

Ключ `-f` используется, чтобы информация о процессах была более детализирована:

```bash
ps -Af
```

Команда `kill` используется для остановке процесса:

```bash
kill <PID>
```

Остановка процесса произойдет, если в коде программы процесса описан ответ на сигнал `SIGKILL`. Но процесс можно завершить принудительно командой:

```bash
sudo kill -9 <PID>
```

Обычно операционная система попросит выполнить эту команду с директивой `sudo`.

## Сигналы и процессы

В [Node.js](/tools/article/nodejs) есть возможность обрабатывать сигналы от Unix-подобных операционных систем. Создадим простую консольную утилиту, которая будет корректно обрабатывать сигналы от операционной системы.

Создадим скрипт `index.js`:

```js
console.log('Hello!');
```

Добавить обработку сигналов в программу очень просто:

```js
console.log(`Process ID: ${process.pid}`);
process.on('SIGHUP', () => console.log('Received: SIGHUP'));
process.on('SIGINT', () => console.log('Received: SIGINT'));

// Таймер, чтобы процесс не останавливался сам
setTimeout(() => {}, 5 * 60 * 1000);
```

Выполним команду, чтобы запустить процесс:

```bash
node index.js
> Process ID: <PROCESS_ID>
```

Если нажать сочетание клавиш <kbd>Ctrl C</kbd>, то процесс сначала покажет соответствующее сообщение, которое мы прописали в программе, но не остановится. Для остановки процесса мы должны были прописать `process.exit(0)`. В скобках можно указать код выхода процесса для обозначения корректного завершения программы с кодом `0` или завершения с ошибкой с кодом больше нуля.

Откроем другое окно Терминала и выполним команду:

```bash
kill -s SIGHUP <PROCESS_ID>
```

В первом окне программа снова выведет соответствующее сигналу сообщение. Вы можете управлять поведением программы при посылке сообщений со стороны пользователя или операционной системы.
