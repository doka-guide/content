### YAML vs JSON

Преимущества YAML в том, что мы можем использовать комментарии. В [JSON](/tools/json/) они нам не доступны.
Корневым узлом в JSON может быть только объект или массив. YAML даёт полную свободу и разрешает использовать любой из допустимых типов данных как корневой узел.

Например, JSON:

```json
{
  "demo": "demo text"
}
```

А вот YAML с той же информацией:

```yaml
demo: "demo text"
```

Иерархия в файле YAML обозначается двойными пробелами, а в JSON объекты и массивы обозначаются фигурными и квадратными скобками соответственно.

Приятной особенностью YAML является возможность не использовать кавычки для строк. Это не обозначает, что они не поддерживаются. Всё, как и указано выше — строки можно обозначать и кавычками, и без. У JSON политика жёстче — строки должны быть в двойных кавычках.

### Использование YAML на примере Github Action

Один из способов использования — это [настройка Github Actions](/tools/github-actions/). Это очень полезная штука, которая позволяет проверять пул-реквесты по заданным в YAML-конфигах правилам.
Если в правилах описать запуск линтера и тестов в ответ на событие в репозитории (например, pull-request), то они будут запускаться каждый раз при появлении этого события. Так мы можем оградить главную ветку репозитория от сломанного кода.
Базовый список для минимального action это имя, в каком случае он будет выполняться (на какое событие), где запускать (операционная система) и шаги которые необходимо выполнить.

```yaml
name: GitHub Actions Example
on: [pull_request]
jobs:
  Explore-GitHub-Actions:
    runs-on: ubuntu-latest
    steps:
      - run: echo "Ура! Я запустился на ${{ github.event_name }}."
      - run: echo "Я работаю на ОС - ${{ runner.os }}"
```

В экшенах можно пользоваться переменными, например, операционная система `${{ runner.os }}` описана выше одноимённым ключом `runs-on` и мы получим значение Linux. В случае `${{ github.event_name }}` выведет значение ключа `on` — `pull_request`.
