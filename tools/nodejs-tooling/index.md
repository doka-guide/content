---
title: "Node.js для создания инструментов разработки"
description: "Почему node.js из языка бэкенда превратился в язык разработки тулинга."
authors:
  - igorkamyshev
contributors:
  - furtivite
keywords:
  - тулинг
  - tooling
  - версии
related:
  - tools/code-style
  - tools/static-analysis
  - js/language-versions
tags:
  - article
---
## Кратко

[Node.js](/tools/nodejs/) — это платформа, которая позволяет запускать JavaScript вне браузера. Области её применения можно разделить на две категории: создание серверных веб-приложений и создание инструментов для разработки.

Вся современная разработка на JavaScript строится вокруг огромного числа инструментов — тулинга. Большинство этих инструментов используют Node.js.

Тулинг (калька английского слова _tooling_) — набор инструментов для разработки.

Практически для каждого этапа работы над JS-проектом потребуется инструмент, который использует Node.js. Вот тройка примеров:

- Разработка требует установки зависимостей через [менеджер зависимостей](/tools/package-managers/). Все популярные пакетные менеджеры _написаны на JavaScript или его диалектах и используют Node.js_;
- Типичный проект требует [этапа сборки](/tools/bundlers/) кода перед отправкой его в браузер. Все популярные сборщики _написаны на JavaScript или его диалектах и используют Node.js_;
- Абсолютное большинство проектов используют [статический анализ](/tools/static-analysis/) для контроля качества кода. Все популярные статические анализаторы _написаны на JavaScript или его диалектах и используют Node.js_.

Это означает, что даже разработчикам интерфейсов важно понимать, как работает Node.js, и уметь минимально с ней взаимодействовать.

## Как понять

Обычно мы не запускаем инструменты напрямую с помощью Node.js, а используем для этого пакетный менеджер. Команды, которые используются в проекте, нужно определить в разделе `scripts` файла `package.json`:

```json
"scripts": {
  "lint": "eslint \"./src/**/*.js\""
}
```

Запускается скрипт так:

```bash
npm run lint
```

Но это просто удобная форма запуска команды:

```bash
node ./node_modules/.bin/eslint "./src/**/*.js"
```

В этой строке происходит сразу несколько вещей: с помощью Node.js мы запускаем файл `eslint`, который лежит в папке `node_modules/.bin`, и передаём ему как аргумент строку, по которой ESLint найдёт файлы для анализа.

Файл `eslint` — это программа, написанная на JavaScript. В ней не происходит никакой магии.

В таком скрипте много кода, но для понимания принципа работы Node.js-инструментов можно его упростить и посмотреть на принципиальную схему. Это не настоящий ESLint, а просто пример того, как может быть устроен скрипт на Node.js:

```js
const cliOptions = parseCommandLineArguments(process.args)
const configOptions = parseConfigFile('.eslintrs')
const options = mergeConfigs([cliOptions, configOptions])
const files = findFiles(options)
const errors = analyzeFiles(files, options)

for (const error of errors) {
  console.warn(error)
}

if (errors.length > 0) {
  process.exit(1)
} else {
  process.exit(0)
}
```

А теперь разберём его построчно. Получаем аргументы командной строки, чтобы найти файлы, которые следует анализировать:

```js
const cliOptions = parseCommandLineArguments(process.args)
```

Читаем файл конфигурации, чтобы решить, какие правила анализа нужно применить:

```js
const configOptions = parseConfigFile('.eslintrs')
```

Собираем финальную конфигурацию:

```js
const options = mergeConfigs([cliOptions, configOptions])
```

Находим все файлы, удовлетворяющие условию:

```js
const files = findFiles(options)
```

Ищем нарушения правил в каждом файле и пишем о них в консоль:

```js
const errors = analyzeFiles(files, options)

for (const error of errors) {
  console.warn(error)
}
```

Если была найдена хоть одна ошибка, завершаем выполнение с кодом `1`. Если ошибок не было, завершаем выполнение с кодом `0`:

```js
if (errors.length > 0) {
  process.exit(1)
} else {
  process.exit(0)
}
```

Любая консольная программа при завершении может сообщить операционной системе код результата. Принято возвращать `0` при успешном завершении и `1` при ошибке.

Концептуально, все Node.js инструменты работают похожим образом — читают конфигурацию из файла в проекте, разбирают аргументы командной строки, делают какую-то полезную работу и сообщают код результата операционной системе.
