---
title: "Паттерны Gateway и Backend-For-Frontend"
description: "Gateway — единое окно для разных API. Backend For Frontend использует Gateway для обработки запросов и подготовки ответов, предназначенных для фронтенда"
authors:
  - igsekor
tags:
  - article
---

## Кратко

Gateway и Backend For Frontend (BFF) — паттерны проектирования для разработки веб-приложений. Оба паттерна используется для обеспечения доступа к разным API с помощью одного контракта. Контракт — это всё то, что позволяет общаться двум сетевым узлам между собой: архитектура построения сетевого соединения, набор сетевых протоколов, набор адресов и портов для доступа к данным, правила формирования запросов со стороны клиентов, механизм подготовки и отправки ответов со стороны сервера.

## Как понять

Gateway является, как правило, прокси-сервером, то есть предоставляет единое окно для доступа к данным по определённому программному интерфейсу (Application Programmable Interface — API). Внешний вид приложения пользователя меняется, бизнес-логика меняется, клиентское приложение меняется, может меняться и контракт, но на остальные API это вообще никак не влияет. Gateway пересылает запросы со стороны клиентов на другие API, учитывая разницу в контрактах, и этим позволяет снизить связность бэкенда и фронтенда в веб-приложении. Как правило, на стороне Gateway частые запросы могут кешироваться, может быть реализована простая бизнес-логика, которая обеспечивает контроль над набором пересылаемых данных между клиентом и внешним API.

Работа Backend For Frontend похожа на Gateway в задачах обеспечения единого контракта и контроля над набором данных, поэтому BFF обязательно включает в себя Gateway. Но должны быть соблюдены и другие требования:

- Общие шаблоны на клиенте и сервере ([JSX](https://ru.reactjs.org/docs/introducing-jsx.html), [Template Literals](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Template_literals) и прочее).
- Высокая скорость ответа под нагрузкой.
- Единый язык на клиенте и промежуточном сервере BFF.

Общие шаблоны очень важны, поскольку это существенно ускоряет разработку и облегчает поддержку как клиентской части приложения, так и серверного приложения BFF. Учитывая, что и язык должен быть единым, это позволяет переиспользовать код на клиенте и сервере. Высокая скорость ответа достигается не только применением кеширования частых запросов, но средствами предварительной подготовки данных для запросов от клиента.

Можно использовать BFF не только для доступа к различным API. Например, паттерн BFF прекрасно ложится на архитектуру построения веб-приложения, в которой на стороне сервера работают микросервисы. Вы можете прочитать о них в статье «[Микросервисы](/tools/microservices/)».

# Как начать

Если в качестве языка разработки используется JavaScript, то очевидно, что необхдимо обеспечить исполнение кода. Скорее всего, вы будете использовать [Node.js](https://nodejs.org/en/), но есть и альтернативы: [Deno](https://deno.land) или [GraalVM](https://www.graalvm.org). Node.js прекрасно подходит для большого количество операций ввода/вывода, но не в случае вычислений. Для BFF это отличный выбор.

Следующий шаг — выбор архитектуры. Этот этап очень важен, поскольку выбор архитектуры определяет дальнейшую поддержку и развитие приложения.

Для BFF прекрасно подходит концепция слоёв. В этой концепции происходит разделение пользовательского интерфейса (в нашем случае API, к которому обращается клиент), от бизнес-логики и данных. Серверное приложение обычно построено на слоях и связях между ними. Есть несколько подходов для реализации слоёв.

**Трёхуровневая (трёхзвенная) архитектура** — исторически один из первых подходов, который построен на совместной работе трёх слоёв: слоя клиента, слоя бизнес-логики и слоя данных. Самый низкий слой — это слой данных. Он взаимодействует со слоем бизнес-логики, который в свою очередь взаимодействует с клиентским слоем. В трёхуровневой архитектуре клиентский слой изолирован от слоя данных.

![Трёхуровневая (трёхзвенная) архитектура](images/1.png)

Проблемы такого подхода очевидны. Всё приложение построено в привязке к данным. Например, структура в базе данных будет полностью определять все верхние слои, что в корне не правильно. Это не позволяет обеспечивать должный уровень абстракции. Будут проблемы, если измениться какой-то внешний API или способ получения данных от микросервиса. Развивать и поддерживать такое приложение будет крайне сложно.

**Domain-Driven Design (DDD)** — более современный подход, когда приложение разбивается на четыре слоя: пользовательский интерфейс (клиент), бизнес-логика, домен, инфраструктура. В этом подходе самым низким слоем является слой инфраструктуры, над которым надстраивается доменный слой (он определяет все сущности, которые необходимы для работы слоя бизнес-логики в рамках доменной области).

![Domain-Driven Design (DDD)](images/2.png)

Такой подход неплох, но он слишком тяжёлый для BFF. Часто требования к продукту таковы, что определение домена и основной бизнес-логики должно лежать на бэкенде. Задача BFF — быть удобной и лёгкой прослойкой между фронтендом и бэкендом.

Важно отметить, что инфраструктура иногда должна быть видна из уровня бизнес-логики, что приводит к проблеме, которая называется [протечкой абстракции или текущей абстракцией](https://en.wikipedia.org/wiki/Leaky_abstraction). Проблема связана с тем, что для поддержания правильной с точки зрения будущей поддержки и развития кода архитектуры нужно изолировать слои. Только верхний и нижний слой могут что-то знать о текущем, но не остальные.

**Чистая архитектура** — ещё более современный подход, в котором используются те же четыре слоя, что и в DDD, но иначе. Слой инфраструктуры поднимается до уровня пользовательского интерфейса. Это позволяет избегать протечки абстракции. Домен становится центром приложения. В современных BFF-приложениях используется чистая архитектура.

![Чистая архитектура](images/3.png)

В качестве фреймворка часто используется [Express](https://expressjs.com) в связке с [Nest.js](https://nestjs.com). Безусловно, проектирование конкретного приложения зависит от бизнес-задачи и доменной области веб-приложения. Вы можете почитать о нескольких успешных практиках использования BFF в следующих статьях и докладах:

- [Бэкенд для фронтенда, или Как в Яндекс.Маркете создают API без костылей](https://habr.com/ru/company/yandex/blog/428141/).
- [Архитектура современных корпоративных Node.js-приложений](https://habr.com/ru/company/yandex/blog/514550/)
- [Backend-for-Frontend: когда простого API не хватает](https://trueengineering.ru/ru/cases/backend-for-frontend)
