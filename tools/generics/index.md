---
title: "TypeScript: дженерики"
description: "TypeScript поддерживает дженерики, которые позволяют писать общую логику для работы с разными типами данных."
authors:
  - nerozumime
keywords:
  - тайпскрипт
related:
  - tools/oop
  - tools/static-types
  - tools/css-in-js
tags:
  - article
---

## Кратко

[**Generic**](https://www.typescriptlang.org/docs/handbook/2/generics.html) или **дженерик** (единственное число) — это сущность, которая параметризируется набором дополнительных типов. Сущность одна, а параметров может быть сколько угодно.

Дженерик-поведение можно добавить к разным сущностям, не обязательно типам, поэтому «обобщённый тип» и дженерик — не одно и то же.

## Как пользоваться

Дженерик — механизм, который позволяет функциям, классам, типам и интерфейсам оперировать переменными типов (что хорошо, так как не надо повторять код).

### Дженерик-функции

В примере функция возвращает первый элемент массива, где `T` — параметр дженерик-типа. В `T[]` квадратные скобки означают, что в качестве параметра функция принимает массив элементов дженерик-типа.

```ts
function getFirstElement<T>(arr: T[]): T | null {
  return arr[0] || null;
}
```

`T` может иметь любой тип данных, однако при этом тип будет однозначно определён. Например, функция `getFirstElement`, вызванная для массива чисел, определит тип возвращаемого значения как `number`.

Параметров дженерик-типа может быть несколько. В таком случае их перечисляют через запятую:

```ts
// Тип K должен быть типом ключа T
function getProperty<T, K extends keyof T>(obj: T, key: K) {
  return obj[key];
}
```

В примере ключевое слово **`extends`** определяет ограничение типа.

Оператор [**`keyof`**](https://www.typescriptlang.org/docs/handbook/2/keyof-types.html) извлекает все публичные ключи объекта и представляет их в виде числового или строкового литерального объединения.

**Литеральное объединение** в TypeScript — это тип, который объединяет несколько литеральных значений в _один_ тип:

```ts
type Mode = 'production' | 'development' | 'test'
```

### Дженерик-классы

```ts
// Аргумент value может быть любого типа
class Component<T> {
  constructor(private value: T){}

  getValueWithType(): string {
    return `${this.value} имеет тип ${typeof this.value}`;
  }
}

const componentString = new Component('42');
console.log(componentString.getValueWithType());
// 42 имеет тип string

const componentNum = new Component(42);
console.log(componentNum.getValueWithType());
// 42 имеет тип number
```

## Как понять

Дженерик-тип не означает любой тип. Это определённый тип, неизвестный на момент написания функции, класса или интерфейса. Чтобы в этом убедиться, посмотрим разницу на примере двух функций.

Первая функция будет использовать в параметрах тип `any`, вторая функция будет принимать дженерик-тип.

```ts
// Входной параметр — массив элементов любого типа
function getFirstAnyElement(arr: any[]): any {
  return arr[0];
}
const firstAnyElement = getFirstAnyElement(['1', '2'])
firstAnyElement.toFixed(1);
// Тип переменной — any,
// компилятор игнорирует вызов функции toFixed у нечислового типа

// Входной параметр — массив элементов с дженерик-типом T
function getFirstElement<T>(arr: T[]): T {
  return arr[0];
}
const firstStringElement = getFirstElement(['1', '2'])
firstStringElement.toFixed(1);
// Тип переменной — string,
// компилятор указывает на ошибку вызова функции toFixed у нечислового типа
```

В функции с дженериком TypeScript сам определил тип возвращаемого значения в момент вызова функции.
