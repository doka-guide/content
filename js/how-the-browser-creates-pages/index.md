---
title: "Как браузер рисует страницы"
authors:
  - bespoyasov
tags:
  - article
cover:
  desktop: 'images/cover.png'
---

## Кратко

Чтобы нарисовать на экране результат работы нашего кода, браузеру нужно выполнить несколько этапов:

1. Сперва ему нужно скачать исходники.
2. Затем их нужно прочитать и _распарсить_.
3. После этого браузер приступает к _рендерингу_ — отрисовке.

Каждый из процессов очень сложен, и мы не будем рассматривать их до мельчайших подробностей.

Мы лишь обратим внимание на те детали, которые необходимо знать фронтенд-разработчикам, чтобы лучше понимать, почему разные решения по-разному влияют на производительность и скорость отрисовки.

Начнём по порядку.

## Получение ресурсов, Fetching

Ресурсы браузер получает с помощью запросов к серверу. В ответ он может получить как данные в виде json, так и картинки, видео, файлы стилей и скриптов.

Самый первый запрос к серверу — обычно запрос на получение HTML-страницы (чаще всего `index.html`).

В коде неё содержатся ссылки на другие ресурсы, которые браузер тоже запросит у сервера:

```html
<!DOCTYPE html>
<html lang="en">
  <head>
    <link href="/style.css" rel="stylesheet">
    <title>Document</title>
  </head>
  <body>
    <img src="/hello.jpg" alt="Привет!">
    <script src="/index.js"></script>
  </body>
</html>
```

В примере выше браузер запросит также:

- стилевой файл `style.css`;
- изображение `hello.jpg`;
- и скрипт `index.js`.

## Парсинг, Parsing

По мере того, как скачивается HTML-страница, браузер пытается её «прочитать» — распарсить.

### DOM

Браузер работает не с текстом разметки, а с абстракциями над ним. Одна из таких абстракций, результат парсинга HTML-кода, называется DOM.

_DOM (Document Object Model)_ — абстрактное представление HTML-документа, с помощью которого браузер может получать доступ к его элементам, изменять его структуру и оформление.

DOM — это дерево. Корень этого дерева — это элемент HTML, все остальные элементы — это дочерние узлы.

```html
<!-- Для такого документа: -->
<html>
  <head>
    <meta charset="utf-8">
    <title>Hello</title>
  </head>
  <body>
    <p class="text">Hello world</p>
    <img src="/hello.jpg" alt="Привет!">
  </body>
</html>

<!-- ...получится такое дерево:

                          html
                    ______|_______
                    |             |
                  body           head
                ___|____       ___|___
                |       |     |       |
                p      img   meta    title
                |                     |
            "Hello world"           "Hello"

-->
```

Пока браузер парсит документ и строит DOM, он натыкается на элементы типа `img`, `link`, `script`, которые содержат ссылки на другие ресурсы. Он читает, откуда надо запросить ресурс и запрашивает его _параллельно с парсингом оставшейся части документа_.

Мы можем указывать браузеру, как именно ему следует запрашивать некоторые ресурсы, например, скрипты. Это может быть полезно, когда в скрипте мы собираемся работать с элементами, которые находятся в разметке после тега `script`:

```js
// script.js
const image = document.getElementById("image")
```

```html
<!--  1:
      image === undefined, потому что браузер
      успел распарсить только часть документа
      до этого тега script.
-->
<body>
  <script src="script.js"></script>
  <img src="/hello.jpg" alt="Hello world" id="image">
</body>

<!--  2:
      Всё в порядке, изображение найдётся.
-->
<body>
  <img src="/hello.jpg" alt="Hello world" id="image">
  <script src="script.js"></script>
</body>

<!--  3:
      Тоже порядок, атрибут defer
      скажет браузеру продолжать парсить страницу
      и выполнить скрипт после.
-->
<body>
  <script src="script.js" defer></script>
  <img src="/hello.jpg" alt="Hello world" id="image">
</body>
```

## CSSOM

Когда же браузер находит элемент `link`, который указывает на стилевой файл, браузер скачивает и парсит и его. Результат парсинга `css`-кода — CSSOM.

_CSSOM (CSS Object Model)_ — по аналогии с DOM, представление стилевых правил в виде дерева.

```css
/* Для документа выше с такими стилями: */

body {
  font-size: 14px;
}

.text {
  color: red;
}

img {
  max-width: 100%;
}

/* ...получим такое дерево:

            body
      (font-size: 14px)
      ________|_________
      |                 |
    .text              img
(color: red)    (max-width: 100%)

*/
```

Чтение стилей приостанавливает чтение кода страницы. Поэтому рекомендуется в самом начале отдавать только критичные стили — которые есть на всех страницах и конкретно на этой. Так мы уменьшаем время, которое пользователь ждёт, пока «страница загрузится».

### Render Tree

После того, как браузер составил DOM и CSSOM, он объединяет их в общее дерево рендеринг — Render Tree.

Render Tree — это термин, который используется движком webkit, в других движках он может отличаться. Например, gecko использует термин Frame Tree.

В итоге для нашего документа выше, мы получим такое дерево:

```js
/*

              html
                |
              body
        (font-size: 14px)
        ________|________
        |               |
      p.text           img
    (color: red)  (max-width: 100%)
        |
  "Hello world"

*/
```

Обратите внимание, что в Render tree попадают только видимые элементы. Если бы у нас был элемент, спрятанный через `display: none`, он бы в это дерево не попал. Об этом подробнее мы ещё поговорим дальше.

Общая схема парсинга выглядит вот так:

![Общая схема парсинга HTML и CSS](images/1.png)

На первых шагах мы разбираемся с HTML и CSS, а затем объединяем их в Render Tree.

## Вычисление позиции и размеров, Layout

После того, как у браузера появилось дерево рендеринга (Render Tree), он начинает «расставлять» элементы на странице. Этот процесс называется _Layout_.

Чтобы понимать, где какой элемент должен находиться и как он влияет на расположение других элементов, браузер рассчитывает размеры и положение каждого _рекурсивно_.

Расчёт начинается от корневого элемента дерева рендеринга, его размеры равны размеру вьюпорта. Далее браузере переходит поочерёдно к каждому из дочерних элементов.

Важно помнить, что Layout построен на поточной модели компоновки. Это значит, что если элементы не влияют на расположение и размеры других элементов, то их положение и размеры можно просчитать за один подход.

Именно поэтому при вёрстке макетов рекомендуется «находиться в потоке» — чтобы браузеру не приходилось несколько раз пересчитывать один и тот же элемент, так страница отрисовывается быстрее.

### Глобальный и инкрементальный Layout

_Глобальный Layout_ — это процесс просчёта всего дерева полностью, то есть каждого элемента. _Инкрементальный_ — просчитывает только часть.

Глобальный Layout запускается, например, при изменении размера окна, потому что браузеру требуется подогнать всю страницу под новый размер экрана. Это **очень** дорогой процесс.

Инкрементальный Layout запускает пересчёт только «грязных» элементов.

### «Грязные» элементы

...Это те элементы, которые были изменены их их дети.

Если мы как-то поменяли блок, то браузер перерисует его и его детей, потому что их положение и размеры могут зависеть от родителя.

![Дерево "грязных" и перерисованных элементов](images/2.png)

Дальше браузер приступает к, собственно, отрисовке.

## Непосредственно отрисовка, Paint

Во время отрисовки (Paint) браузер наполняет пиксели на экране нужными цветами в зависимости оттого, что в конкретном месте должно быть нарисовано: текст, изображение, цвет фона, тени, рамки и т. д.

Отрисовка тоже бывает _глобальной_ и _инкрементальной_. Чтобы понять, какую часть вьюпорта надо перерисовать, браузер делит весь вьюпорт на прямоугольные участки. Логика тут та же, как и в Layout — если изменения ограничены одним участком, то пометится грязным и перерисуется лишь он.

Отрисовка — это _самый_ дорогой процесс из всех, что мы уже перечислили.

### Порядок отрисовки

Порядок отрисовки связан со стековым контекстом.

В общих чертах, отрисовки начинается с заднего плана и постепенно переходит к переднему:

- background-color;
- background-image;
- border;
- children;
- outline.

## CPU и композитинг

И Layout, и Paint работают за счёт _CPU (central process unit)_, поэтому относительно медленные. Плавные анимации при таком раскладе невероятно дорогие.

Для плавных анимаций в браузерах предусмотрен композитинг (Compositing).

_Композитинг_ — это разделение содержимого страницы на «слои», которые браузер будет перерисовывать. Эти слои друг от друга не зависят, из-за чего изменение элемента в одном слое не затрагивает элементы из других слоёв, и перерисовывать их становится не нужно.

Именно из-за разнесения элементов по разным композиционным слоям свойство `transform` не так сильно нагружает браузер. Поэтому чтобы анимации не тормозили, их рекомендуется делать с применением `transform` и `opacity`.

![Схема композитинга](images/3.png)

Применение таких свойств, как например, `transform` «выносит» элемент на отдельный композитный слой, где положение элемента не зависит от других и не влияет на них.

:::callout 📝

Чтобы узнать, вызывает ли конкретное CSS-свойство композитинг и перерисовку в браузере, воспользуйтесь инструментом «[CSS Triggers](https://csstriggers.com)».

:::

## Перерисовка, Reflow (relayout) и Repaint

Процесс отрисовки — циклический. Браузер перерисовывает экран каждый раз, когда на странице происходят какие-то изменения.

Если, например, в DOM-дереве добавился новый узел, или изменился текст, то браузер построит новое дерево отрисовки и запустит вычисление позиции и отрисовку заново.

Один цикл обновления — это animation frame.

Зная «расписание отрисовки» браузера, мы можем «предупредить» его, что хотим запустить какую-то анимацию на каждый новый фрейм. Это можно сделать с помощью `requestAnimationFrame`.

```js
const animate = () => {
  /* Эта запускает новый кадр анимации:
    обновляет какое-то свойство или
    перерисовывает canvas. */
}

/* Если мы хотим добиться плавной анимации
  используя функцию выше, мы должны обеспечить
  в среднем 60 обновлений экрана за секунду
  (60 fps — frames per second).

  Это можно сделать топорно, через интервал: */

// 60 раз в 1000 миллисекунд, приблизительно 16 мс.
const intervalMS = 1000 / 60
setInterval(animate, intervalMS)

/* Либо использовать window.requestAnimationFrame: */
window.requestAnimationFrame(animate)
```

Интервалы не всегда запускаются в нужный момент. `setInterval` не учитывает, на какой стадии отрисовки находится страница, и в итоге кадры отрисовки могут быть рваными или дёрганными:

```js
/*
  С интервалом анимация может быть рваной,
  потому что перерисовка может быть запущена
  в неподходящее время.

  А если вкладка была неактивна, то интервал может
  «попытаться догнать время»
  и несколько кадров запустится разом
  ....|....|..||...|....|.........||||..|....|...|...|....|...
*/

/*
  С requestAnimationFrame анимация плавнее,
  потому что браузер знает, что в следующем фрейме
  надо запустить новый кадр анимации.

  Она не гарантирует, что анимация будет запущена
  строго раз в 16 мс, но значение будет достаточно близким.
  ....|....|....|...|....|...|....|....|...|.....|....|....
*/
```
