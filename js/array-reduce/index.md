---
title: "`[].reduce`"
authors:
  - windrushfarer
contributors:
  - ansmtz
keywords:
  - редьюсер
  - свёртка
tags:
  - doka
---

## Кратко

Метод массива `reduce` позволяет превратить массив в любое другое значение с помощью переданной функции-колбэка и начального значения. Функция-колбэк будет вызвана для каждого элемента массива и всегда должна возвращать результат.

## Пример

```js
const nums = [1, 2, 3, 4, 5, 6, 7, 8]

// Находим сумму элементов
const sum = nums.reduce(function (currentSum, currentNumber) {
  return currentSum + currentNumber
}, 0)
// 36
```

```js
const users = [
  { id: "1", name: "John" },
  { id: "2", name: "Anna" },
  { id: "3", name: "Kate" },
]

// Создаем новый объект с ключом в виде id и значением в виде имени юзера
const usernamesById = users.reduce(function (result, user) {
  return {
    ...result,
    [user.id]: user.name,
  }
}, {})
// { '1': 'John', '2': 'Anna', '3': 'Kate' }
```

Интерактивный пример:

<iframe title="Группировка элементов массива при помощи reduce" src="demos/index/" height="920"></iframe>

## Как пишется

Метод `reduce` принимает два параметра: функцию-колбэк и начальное значение для аккумулятора.

Сама функция-колбэк может принимать четыре параметра:

- `acc` — текущее значение аккумулятора
- `item` — элемент массива в текущей итерации
- `index` — индекс текущего элемента
- `arr` — сам массив, который мы перебираем

```js
const nums = [1, 2, 3, 4, 5, 6, 7, 8]

// Не забываем, что аккумулятор идет первым!
function findAverage(acc, item, index, arr) {
  const sum = acc + item

  // В конце вычисляем среднеарифметическое делением на кол-во элементов
  if (index === arr.length - 1) {
    return sum / arr.length
  }

  return sum
}

const average = nums.reduce(findAverage, 0)
// 4.5
```

Ключом к успешному использованию `reduce` является внимательно следить за порядком аргументов и не забывать возвращать значение.

Использование `reduce` похоже на методы [`forEach`](/js/array-foreach/), [`map`](/js/array-map/) и [`filter`](/js/array-filter/), в которые так же передаётся функция-колбэк. Однако в `reduce` есть дополнительный аргумент — это текущее аккумулируемое значение. При этом можно заметить, что порядок аргументов так же немного изменён.

Функция обязательно должна возвращать значение, поскольку в каждой следующей итерации значение в `acc` будет результатом, который вернулся на предыдущем шаге. Логичный вопрос, который может здесь возникнуть, — какое значение принимает `acc` во время первой итерации? Им будет являться то самое начальное значение, которые передаётся вторым аргументом в метод `reduce`.

## Как это понять

Метод `reduce` крайне полезен, когда мы хотим с помощью манипуляции значениями массива вычислить какое-то новое значение. Такую операцию называют **агрегацией**. Таким образом у нас появляется мощный инструмент для обработки данных, например это может быть нахождение суммы величин в массиве или группировка в другие типы данных.

Главной особенностью `reduce`, которую важно запомнить, является наличие **аккумулятора**. Аккумулятор — это и есть то новое вычисляемое значение. Во время выполнения функции-колбэка нужно обязательно возвращать его значение, поскольку оно обязательно попадает в следующую итерацию, где так же будет использоваться для дальнейших вычислений. Таким образом мы можем представить аккумулятор как переменную, значение которой можно поменять в каждой новой итерации. С помощью второго аргумента в `reduce` эта переменная получает своё начальное значение.

Задача: вычислить сумму денег на всех счетах.

```js
const bankAccounts = [
  { id: "123", amount: 19 },
  { id: "345", amount: 33 },
  { id: "567", amount: 4 },
  { id: "789", amount: 20 },
]

const totalAmount = bankAccounts.reduce(
  // Аргумент sum является аккумулятором,
  // в нём храним промежуточное значение
  function (sum, currentAccount) {
    // Каждую итерацию берём текущее значение
    // и складываем его с количеством денег
    // на текущем счету
    return sum + currentAccount.amount
  },
  // Начальное значение,
  // которые инициализирует аккумулятор
  0
)
// Получим 76
```

Чтобы понять этот момент можно ещё посмотреть на код, который делает то же самое, но уже без `reduce`.

Задача: вычислить сумму денег на всех счетах.

```js
const bankAccounts = [
  { id: "123", amount: 19 },
  { id: "345", amount: 33 },
  { id: "567", amount: 4 },
  { id: "789", amount: 20 },
]
```

Определяем где будем хранить сумму, это в нашем случае является аккумулятором, здесь же определяем начальное значение аккумулятора.

```js
let totalAmount = 0

for (let i = 0; i < bankAccounts.length; i++) {
  const currentAccount = bankAccounts[i]

  // В каждой итерации прибавляем
  // к текущей сумме количество денег на счету
  totalAmount += currentAccount.amount
}
```

`totalAmount` здесь будет так же равен 76.

И в том и в том другом примере у нас аккумулятор, где хранится текущее значение и кладётся новое, есть вычисление нового значение. Только `reduce` позволяет сделать это в одном месте и более понятном декларативном стиле.

### Пустое начальное значение аккумулятора

Начальное значение для аккумулятора можно не указывать явно. В таком случае, на первой итерации аккумулятор будет равен значению первого элемента в массиве:

```js
const arr = [1, 2, 3]
const sum = arr.reduce(function (acc, val) {
  return acc + val
})
console.log(sum)
// 6
```

В фрагменте выше `acc` на первой итерации равен 1, а `val` — 2. Затем к полученному
аккумулированному значению 3 прибавляется 3 и возвращается результат.

В этом подходе есть краевой случай. Если массив окажется пустым, то JavaScript выбросит ошибку `TypeError: Reduce of empty array with no initial value`. Этот случай нужно обрабатывать отдельно, например, обернув `reduce` в [`try...catch`](/js/try-catch/), но лучше __всегда указывать начальное значение__.
