---
title: "`for`...`in`"
description: "Обходим имена перечисляемых свойств объекта."
authors:
  - windrushfarer
contributors:
  - vitya-ne
related:
  - js/object
  - js/objects-objects-everywhere
  - js/for
tags:
  - doka
---

## Кратко

Инструкция `for...in` выполняет [цикл](/js/loop/) обхода перечисляемых свойств объекта включая перечисляемые свойства прототипов.

В каждой итерации цикла переменная цикла получает значение соответствующее имени перечисляемого свойства объекта. Порядок обхода свойств строго определён спецификацией ECMAScript.

Перечисляемые свойства – это свойства, которые разработчик добавляет объекту.

В цикл `for...in` не попадут: встроенные свойства, например методы объекта унаследованные от Object.prototype, а также свойства имена которых имеют тип [Symbol](js/symbol/)

## Как пишется

Схематично структура для создания цикла выглядит так:

```js
for (переменная in объект) {
  // действия внутри цикла
}
```

Для цикла необходимо объявить название переменной и указать сам объект, свойства которого нужно обойти. В объявленной переменной будет храниться имя свойства во время итерации:

```js
const cat = {
  name: 'Борис',
  color: 'red',
  age: 8
}

for (const key in cat) {
  console.log(`${key} – ${cat[key]}`)
}
// name – 'Борис',
// color – 'red',
// age – 8
```

## Как понять

Цикл `for...in` — это хороший способ пройти по всем свойствам объекта, но стоит помнить несколько важных особенностей.

### Что такое перечисляемые свойства

Перечисляемые свойства объекта – это свойства, которые явно помечены такими. Сказать свойству, что оно перечисляемое, можно через [специальный метод `defineProperty()`](/js/descriptors/). Но для простоты все свойства, которые добавляются к объекту, являются перечисляемыми по умолчанию. _Встроенные свойства не перечисляется_. Например, метод [`indexOf()`](/js/index-of/) у объекта `String` или метод [`toString()`](/js/object-tostring/) у [любого объекта](/js/objects-objects-everywhere/) не участвуют в цикле `for...in`.

Цикл `for...in` будет перебирать не только собственные свойства объекта, но и все перечисляемые свойства наследуемые от цепочки прототипов. Имена свойств в цикле не повторяются (свойства объекта имеют наивысший приоритет, а ближайших прототипов имеют больший приоритет над свойствами прототипов, находящихся дальше от объекта в его цепочке прототипов):

```js
const grandParent = { a: 1, b: 2 }
const parent = { b: 3, c: 4 }
const object = { c: 5 }

Object.setPrototypeOf(parent, grandParent)
Object.setPrototypeOf(object, parent)

for (const key in object) {
  console.log(key, object[key])
}
// c 5
// b 3
// a 1

```

### Порядок перечисления свойств

Спецификация ECMAScript определяет следующий порядок обхода перечисляемых свойств объекта при выполнении цикла `for...in`:

1. неотрицательные целочисленные ключи (те, которые могут быть индексами массива) в порядке возрастания значений.
1. строковые ключи в порядке возрастания хронологии создания.

В том же порядке будут перебираться свойства протототипов объекта.

Демонстрация порядка обхода целочисленных свойств:

```js
const booksById = {
  341: {
    name: 'Harry Potter'
  },
  144: {
    name: 'Flowers for Algernon'
  },
  202: {
    name: 'Lord of the Rings'
  }
}

for (const key in booksById) {
  console.log(key)
}
// 144
// 202
// 341
```

Демонстрация порядка обхода объетка имеющего строковые и символьные свойств:

```js
const id = Symbol('id')

const developer = {
  name: 'Ваня',
  language: 'JavaScript',
  [id]: '8888',
  company: 'Google'
}

developer.age = 33

for (const key in developer) {
  console.log(key)
}
// name
// language
// company
// age
```

<aside>

❗️ Использовать цикл `for...in` для перебора массивов не рекоменуется по нескольким причинам:
1. в цикл `for...in` попадут не только целочисленные свойства, но и строковые, а также наследуемые.
2. переменная цикла на каждой итерации соответсвующая индексу текущего элемента будет иметь тип строки а не числа.

Для перебора у массива есть собственные методы: [`forEach()`](/js/array-foreach/), [`map()`](/js/array-map/) и другие.

</aside>

### Изменение объекта во время перебора


