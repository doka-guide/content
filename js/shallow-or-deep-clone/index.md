---
title: "Поверхностное и глубокое копирование"
description: "При копировании объектов и массивов в JavaScript, данные копируются только на один уровень вглубь."
authors:
  - nlopin
contributors:
  - rrramble
related:
  - js/spread
  - js/ref-type-vs-value-type
  - js/objects-objects-everywhere
tags:
  - article
---

## Кратко

При копировании объектов или массивов с помощью деструктуризации JavaScript копирует данные только на _один_ уровень вглубь.
Более глубокие уровни вложенности передаются по ссылке. Такой тип копирования называется _поверхностным_ (shallow).

Если необходимо полностью скопировать более сложную структуру данных, например, массив объектов, то нужно _глубокое_ (deep) копирование.

## Проблема поверхностного копирования

Поверхностное копирование работает быстро и его достаточно для несложного кода или для одноуровневых структур.
Проблемы появляются, когда приходится копировать вложенные структуры:

```js
// 1. Поверхностное копирование одноуровневой структуры выполняется без проблем
const productNames = ['Носки', 'Штаны', 'Кепка']
const clonedNames = [...names]

// 2. Поверхностное копирование сложной структуры
const itemsInCard = [
  { product: 'Носки', quantity: 3 },
  { product: 'Штаны', quantity: 1 },
  { product: 'Кепка', quantity: 1 },
]

const clonedCart = [...itemsInCard]
```

Если изменять элементы клонированной переменной `clonedCart` после копирования, то эти изменения будут также видны в исходной переменной `itemsInCard`:

```js
clonedCart[1].quantity = 999

console.log(clonedCart)
// [
//    { product: 'Носки', quantity: 3 },
//    { product: 'Штаны', quantity: 999 },
//    { product: 'Кепка', quantity: 1 },
// ]

console.log(itemsInCard)
// [
//    { product: 'Носки', quantity: 3 },
//    { product: 'Штаны', quantity: 999 },
//    { product: 'Кепка', quantity: 1 },
// ]
```

Непримитивные типы данных, такие как массивы и объекты, хранятся [по ссылке](/js/ref-type-vs-value-type/#ssylochnye-tipy-dannyh). Так как копирование выполняется вглубь только на один уровень, то при копировании массива происходит копирование _ссылок на старые объекты_ в новый массив.

В итоге разные массивы ссылаются на одни и те же объекты в памяти:

```js
console.log(itemsInCard[1] === clonedCart[1])
// true
```

![Результат поверхностного копирования массива](images/shallow.png)

## Как получить глубокую копию

### Функция `structuredClone()`

Функция `structuredClone()` для глубокого копирования появилась в JavaScript начиная с версии EcmaScript 2021.
Функция внедрена в текущие версии браузеров (Firefox, Google Chrome, Microsoft Edge, Apple Safari с ноября 2021 года по март 2022 года, а в Samsung Internet с августа 2022 года).

Но для поддержки более старых браузеров или если неизвестно в какой среде будет выполняться код, лучше рассмотреть другие решения.

### Написать свою функцию

Можно написать функцию глубокого копирования вручную. Скорее функция будет [рекурсивной](/js/recursion/), и она будет работать только для конкретных данных — написать универсальную функцию не просто.

### Воспользоваться готовой библиотекой

Функцию глубокого копирования содержит популярная библиотека утилит [_lodash_](https://lodash.com/docs/4.17.15#cloneDeep). Функция работает в большинстве случаев, потому что используется в десятках тысяч проектов каждый день. Исходный код библиотеки открыт, можно изучить [исходный код функции глубокого копирования](https://github.com/lodash/lodash/blob/4.17.15/lodash.js#L2620).

```js
import cloneDeep from 'lodash.clonedeep'

const deep = cloneDeep(itemsInCart)
console.log(itemsInCart[1] === deep[1])
// false
```

### Сериализация JSON и парсинг

Самый простой и быстрый способ — сериализовать копируемый объект в JSON-объект с помощью метода `JSON.stringify()` и далее распарсить его методом `JSON.parse()`.

```js
const clonedCart = JSON.parse(JSON.stringify(itemsInCart))
console.log(itemsInCart[1] === clonedCart[1])
// false
```

![Результат глубокого копирования массива](images/deep.png)

У этого метода есть ограничение — копируемые данные должны быть сериализуемы.

Примеры несериализуемых данных: примитив `undefined`, функции, [Symbol](/js/symbol/).

Массивы и объекты - сериализуемы. Но если у них ключами или значениями будут несериализуемые данные, то результатом будет:

- для массивов: такие значения будут превращены в null;
- для объектов: такие значения будут опущены, а если symbol является ключом объекта, то он будет проигнорирован, даже при использовании функции replacer.

```js
// 1. Копирование сложного массива с помощью JSON.stringify(), JSON.parse()
const arr = [
  undefined,
  function() { console.log('aaa') },
  Symbol('foo'),
]

const copyArr = JSON.parse(JSON.stringify(arr))

console.log(copyArr)
// [null, null, null]

// 2. Копирование сложного объекта с помощью JSON.stringify(), JSON.parse()
const obj = {
  a: undefined,
  method: () => {},
  [Symbol('foo')]: 'foo',
}
const copyObj = JSON.parse(JSON.stringify(obj), function(k, v) {
  if (typeof k === 'symbol') {
    return 'символ'
  }

  return v
})

console.log(copyObj)
// {}
```
