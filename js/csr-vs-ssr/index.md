---
title: "Сравнение клиентского и серверного рендеринга приложений (CSR vs SSR) на практике"
description: "Сравнение двух основных видов отрисовки приложений в современных веб-фреймворках на практике"
authors:
  - vtcaregorodtcev
related:
  - tools/gateway-bff
  - js/web-app-works
  - js/web-app-types
tags:
  - article
keywords:
  - фреймворк
  - дерево приложения
  - перфоманс
  - web vitals
---

## Кратко

Ознакомится с типами приложений и способами их рендеринга можно в статье о [видах веб-приложений](https://doka.guide/js/web-app-types/). В этой статье мы будем больше говорить про практический аспект.

С первой волной веб-фреймворков, начавшейся в 2010 году и подарившей нам Ember, Knockout, Backbone и AngularJS, разработчики плотно познакомились с новой концепцией - Client Side Rendering.

До 2010 года практически не было инструментов, которые бы позволяли добавлять абстракции поверх обычных HTML страниц. Количество кода на клиентской стороне было минимально и служило лишь для того чтобы добавлять интерактивности при работе с приложением. Вся работа с отображением контента происходила на сервере. Бэкенд имел набор темплейтов, вьюшек, которые он отдавал на определенный запрос с фронтенда.

Такую расстановку сил называли "тонкий клиент", имея в виду, что на клиентской стороне практически ничего не было. Самыми популярными решениями в то время были ASP.NET Web Forms, перекочевавший потом в ASP.NET MVC, фреймворки на PHP и Ruby on Rails. Они и послужили стандартом для написания первых фронтенд фреймворков, предлагая проверенную годами [модель MVC](https://habr.com/ru/post/215605/) (Model-View-Controller).

Как видно, одной из базовых составляющих MVС, является управление представлениями, вьюшками (от слова View). Поэтому, с этого момента приложения на новых фронтенд фреймворках начали называть приложениями с "толстым клиентом", имея в виду, что код загружаемый на клиентскую часть теперь сам знает что и когда нужно показать пользователю, ориентируясь на браузерную строку. Соответственно, сам процесс построения DOM дерева для разных состояний приложения на клиентской стороне и называется CSR (Client Side Rendering).

## Про CSR

Из каких этапов состоит клиентский рендеринг?

1. Пользователь хочет открыть приложение и вводит его адрес в строке браузера.
2. Браузер делает запрос на серверную часть.
3. Сервер отдает файл index.html, который содержит ссылки на скрипты с основным кодом приложения, кодом фреймворка и прочие скрипты, необходимые для корректной работы приложения. Причем сам документ пустой. В теле страницы ничего нет и пользователь видит белый экран.
4. Браузер парсит полученный HTML файл и делает запросы на получение javascript файлов.
5. После получения и парсинга javascript файлов, происходят возможные API запросы на получение данных и пользователь начинает видеть страницу, которую отрендерил фреймворк.

Всегда лучше визуализировать то о чем читаешь, поэтому схема ниже должна лучше раскрыть все шаги CSR.

![Последовательность шагов при клиентском рендеринге](./images/csr-flow.png)
Последовательность шагов при клиентском рендеринге

## Про SSR

Из каких этапов состоит серверный рендеринг?

1. Пользователь хочет открыть приложение и вводит его адрес в строке браузера.
2. Браузер делает запрос на серверную часть.
3. Сервер делает необходимые АПИ запросы и рендерит приложение в виде строки. Наполняет index.html необходимым контентом (сгенерированная строка приложения), вставляет ссылки на дополнительные скрипты и отправляет в ответ на запрос браузера.
4. Браузер получает готовый HTML файл и показывает его пользователю, при этом запрашивая дополнительные скрипты и сам код приложения. В этот момент пользователь видит контент, но еще не может пользоваться приложением, потому что это просто статика. Но это влияет на субъективную оценку скорости работы приложения, так как пользователь видит контент намного раньше чем при CSR.
5. Браузер получает запрашиваемые скрипты, парсит их и фреймворк производит _гидратацию_ приложения. Наполняет приложение интерактивностью. Чаще всего это означает, что фреймворк навешивает обработчики событий на нужные элементы, чтобы пользователь мог с ними взаимодействовать.

Взглянем также на схему.

![Последовательность шагов при серверном рендеринге](./images/ssr-flow.png)
Последовательность шагов при серверном рендеринге

## На практике

Дочитав до этого момента можно вспомнить анекдот.

```txt
- Привет! Хочешь расскажу как построить архитектуру фронтенд приложения?
- Рассказать и я могу, ты построить можешь?
```

Поэтому давайте напишем свой мини-фреймворк, который будет уметь рендерить в режиме CSR и SSR. Так мы на практике разберёмся, какая между ними разница.

Что вообще должен уметь делать современный фреймворк? Как минимум он должен уметь оперировать компонентами и строить из них страницы, которые нам потом покажет браузер. Зачастую, те компоненты, которые пишет разработчик и те сущности, с которыми работает сам фреймворк немного отличаются и имеют разные структуры. Для простоты мы будем считать что наш фреймворк работает с HTML как с обычным JS-объектом.

```ts
// app.ts - описание верстки приложения одним файлом в виде js-объекта

export const app = {
  header: {
    style: "font-size: 20px",
    children: "This is the header for User",
  },
  main: {
    children: [
      {
        button: {
          id: "button-count",
          children: "count button",
          style: "margin-top: 10px",
          click: function () {
            const p = document.querySelector("p.count");

            if (p) {
              const count = +(p?.innerHTML || 0);
              p.innerHTML = String(count + 1);
            }
          },
        },
      }
      // ... more tags
    ]
    // ... more attributes
  }
}
```

Мы описываем наше приложение через обычный js-объект. Все вложенные элементы описываются через _children_, а остальные атрибуты просто в виде свойств нашего объекта.

Пример приложения и реализация псевдофреймворка доступна [по этой ссылке](./demo.zip). Нужно распаковать архив и установить пакеты командой `pnpm i`. Для этого, конечно, нужно чтобы [пакетный менеджер pnpm](https://pnpm.io/ru/) уже был у вас установлен.

## Пишем CSR

Для приложения с клиентским рендерингом нам потребуется всего два файла. Страница index.html и сам код нашего приложения. Мы также будем использовать дополнительный файл _dist/javascript_ для создания псевдонагрузки, поскольку наш фреймворк весит всего несколько сотен байт и такой размер приложения вряд ли удастся увидеть в реальном приложении.

![Файлы необходимые для реализации CSR](./images/files-for-csr.png)
Файлы необходимые для реализации CSR

Готовим наши ингредиенты:

```ts
import { app } from "../app";
import { render } from "../render";

render(app, document.querySelector("#csr-root"));
```

Если мы посмотрим на документацию большинства современных фреймворков, React.js например, то именно так начинается построение приложения. Что же должна делать функция _render()_?

Обычно, такая функция принимает на вход самый главный (верхнеуровневый) компонент вашего приложения и элемент из DOM дерева, куда нужно будет его вмонтировать (вставить).

Функция парсит код вашего компонента, превращает его в набор элементов (иерархию) HTML и при помощи API браузера вставляет в тот элемент, который вы указали вторым аргументом.

Давайте попробуем написать такую функцию с нуля.

```ts
export const render = (component, node) => {
  const tags = Object.keys(component);

  tags.forEach((tag) => {
    const { children, ...props } = component[tag];
    const element = document.createElement(tag);

    const propNames = Object.keys(props);

    propNames.forEach((name) => {
      if (typeof props[name] === "function") {
        element.addEventListener(name, props[name]);
      } else {
        element.setAttribute(name, props[name]);
      }
    });

    render(children, element); // рекурсивно рендерим элементы

    node.appendChild(element);
  });
};
```

Вообще, фантазируя на тему того, как должна выглядеть та или иная реализация, всегда стоит отталкиваться от того, какую проблему мы собираемся решить. Если мы взглянем на наше условное приложение то мы заметим, что данные выглядят как очень специфичная структура - [дерево](https://ru.wikipedia.org/wiki/%D0%94%D0%B5%D1%80%D0%B5%D0%B2%D0%BE_(%D1%81%D1%82%D1%80%D1%83%D0%BA%D1%82%D1%83%D1%80%D0%B0_%D0%B4%D0%B0%D0%BD%D0%BD%D1%8B%D1%85)). У нас есть корень _app_ - это само наше приложение, у нас есть ветви _header_ и _main_ - это верхнеуровневые элементы, и каждая ветвь имеет свои лепестки, которые лежат в _chidlren_.

Дерево - это рекурсивная структура данных. Имеется в виду что, если мы захотим назвать корнем нашего приложения не _app_, а _main_, то по большому счету мало что поменяется. Просто вся иерархия сдвинется вглубь нашего дерева. Отсюда мы можем сделать вывод, что для обработки такой структуры нам также нужен [рекурсивный алгоритм](https://ru.wikipedia.org/wiki/%D0%A0%D0%B5%D0%BA%D1%83%D1%80%D1%81%D0%B8%D1%8F). Собственно, данный алгоритм и представлен выше.

Вообще, рекурсия - это не всегда самый оптимизированный алгоритм, но в нашем случае самый очевидный, поэтому остановимся на нем. Так что же мы делаем в нем?

Самое первое - мы берем объект нашего приложения и достаем все внутренние ключи, которые потом станут DOM элементами или тегами.

```ts
const tags = Object.keys(component); // ['header', 'main']
```

Далее, пробегаемся по всем тегам и, собственно, создаем эти элементы. При этом мы также получаем все атрибуты/пропсы для нашего элемента, по которым мы также пробежимся и добавим к элементу.

```ts
const { children, ...props } = component[tag];
const element = document.createElement(tag);

...

propNames.forEach((name) ....
```

Если у элемента есть дочерние элементы, мы просто еще раз вызываем нашу функцию, но только теперь для каждого дочернего элемента (та самая рекурсия и смещение корня вглубь).

В самом конце функции, после того как все элементы созданы, нам нужно их добавить в указанный элемент (наш второй параметр функции _render_).

```ts
node.appendChild(element);
```

На этом наше приложение закончено. Из корня скачанной директории запускаем команду `pnpm csr`, переходим на `localhost:8080` и видим наше рабочее приложение. При этом, например в _Google Chrome_, можно открыть _DevTools_ на вкладке _Elements_ и увидеть все описанные этапы CSR. Сначала мы видим просто div элемент с `id='csr-root'`, а после загрузки всех скриптов у дива появляются внутренние элементы.

<video style="width: 100%" autoplay loop muted playsinline src="./images/csr-example.mp4"></video>

## Пишем SSR

Теперь очередь серверного рендеринга. Для этого напишем небольшой сервер на [fastify](https://www.fastify.io/), который будет отдавать нам верстку. Поскольку на серверной стороне нем нет необходимости создавать интерактивное приложение нам хватит обычной строки, которая будет содержать всю нашу верстку. После того как мы отправим ее в браузер, браузер сам сделает ее интерактивной. Соответственно, нам также понадобится функция _renderToString()_.

```ts
import Fastify from "fastify";

import { renderToString } from "../renderToString";
import { app } from "../app";

const fastify = Fastify();

fastify.get("/", (req, reply) => { // регистрируем обработчик, на любой урл отдаем верстку в строке
  reply.type("text/html").send(renderToString(app));
});

fastify.listen({ port: 4321 }, (err, address) => {
  if (err) throw err;
  console.log(`Server is now listening on ${address}`);
});
```

Когда мы реализовывали CSR, мы полагались на браузерное API. Именно поэтому мы могли использовать _document_ и _window_. На NodeJs этих интерфейсов нет и нам нужно их имитировать.

На помощь нам придет [JSDOM](https://github.com/jsdom/jsdom) - имплементация АПИ DOM для NodeJs. И поэтому наша функция станет выглядеть следующим образом.

```ts
export const renderToString = (component) => {
  const dom = new JSDOM(`<div id="ssr-root"></div>`);

  const { document } = dom.window;

  render(component, document.querySelector("#ssr-root"), () => document); // указываем третьим параметром document из JSDOM

  return dom.serialize();
};
```

Также мы немного модифицировали саму функцию _render()_, чтобы она могла вызываться и в браузере и на NodeJs. Теперь функция принимает третий параметр, который отвечает за имплементацию _document_. В браузере, по умолчанию, _document_ определен и нам передавать ничего не нужно, но на NodeJs мы явно это указываем.

Теперь, если запустить команду `pnpm ssr` и перейти на `localhost:4321` то мы снова увидим наше приложение, но оно потеряло интерактивность - ничего не происходит если мы будем нажимать на кнопки. Все дело в том, что нам нужно провести гидратацию приложения на стороне клиента. На сервере мы только отрисовали html, а события на кнопки нужно навешивать уже в браузере. Для этого напишем функцию _hydrate()_.

```ts
export const hydrate = (component) => {
  const tags = Object.keys(component);

  tags.forEach((tag) => {
    const { children, ...props } = component[tag];

    const propNames = Object.keys(props);

    propNames.forEach((name) => {
      if (typeof props[name] === "function") {
        const element = document.querySelector("#" + props.id); // находим элементы на которые нужно вернуть интерактивность
        element?.addEventListener(name, props[name]);
      }
    });

    hydrate(children); // рекурсивно возвращаем интерактивность
  });
};
```

Функция очень похожа на _render()_, только теперь мы не занимаемся созданием самих DOM элементов из компонентов, мы берем те атрибуты, которые отвечают за интерактивность, клик хэндлеры и прочие функции, и возвращаем их на свои места.

Здесь стоит заметить, что мы немного схитрили, заранее раздав ID тем компонентам, которые должны быть интерактивными. В реальном фреймворке нужно также решать эту проблему, генерируя специальный ID для компонентов, чтобы версия полученная на серверной стороне совпадала с вариантом на клиентской.

Теперь в _index.html_ подключаем немного другой файл. Данный скрипт будет выполняться только на клиентской стороне, в браузере.

```ts
import { app } from "../app.js";
import { hydrate } from "../hydrate.js";

hydrate(app);
```

Перезапускаем приложение и видим, что интерактивность вернулась.

## Смотрим метрики

Далее, чтобы убедиться, что SSR действительно нам помогает раньше увидеть контент, запустим проверку _Lighthouse_ из Google Chrome DevTools и сравним метрику FCP (First Contentful Paint) между разными режимами. Метрика показывает какое время требуется на отрисовку первой картинки или текста на странице.

![Вкладка Lighthouse](./images/lighthouse.png)
Вкладка Lighthouse

![FCP метрика для CSR](./images/csr-fcp.png)
FCP метрика для CSR

![FCP метрика для SSR](./images/ssr-fcp.png)
FCP метрика для SSR

Видим что метрика FCP для SSR ниже, соответственно пользователи будут более счастливы при работе со второй версией приложения.

Но другие практики оптимизации, конечно, никто не отменял. Если не следить за другими частями приложения, не делать [Tree Shaking](https://webdevblog.ru/chto-takoe-tree-shaking-i-kak-eto-rabotaet/), не откладывать загрузку неважного контента, то SSR может и навредить. Потому что хуже бесконечного спиннера может быть только то, что ты уже видишь контент, но не можешь с ним взаимодействоать, о чем нам может сказать метрика TTI (Time To Interactive - время за которое приложение становится интерактивным). Поскольку для того чтобы гидратация произошла, нам также нужно загрузить некоторые важные скрипты.
