---
title: "`Atomics`"
description: "Специальный объект, который соджержит статические методы для выполнения атомарных операций."
authors:
  - doka-dog
  - vsezol
related:
  - js/weak-ref
  - js/array-isarray
  - js/arrays
  - js/shared-array-buffer
tags:
  - doka
---

## Кратко

`Atomics` - объект, который содержит статические методы для выполнения атомарных операций.
Потребность в использовании атомарных операций возникает при работе с `SharedArrayBuffer`, благодаря которому появляется возможность разделения общей памяти между потоками. При работе с общей памятью есть риск возникновения состояния гонки (race condition) без контроля доступа к общему состоянию.

При правильном использовании `Atomics` мы можем с уверенностью гарантировать, что изменения записываются и читаются, а операции завершаются до начала следующей и не прерываются.

Давайте рассмотрим пример, позволяющий лучше понять важность применения атомарных операций.

```js
sharedMemory[0] = sharedMemory[0] + 5;

// эквивалентная запись (только при выполнении в одном потоке)
let temp = sharedMemory[0];
temp += 5;
sharedMemory[0] = temp;
```

При работе в одном потоке, как все мы привыкли, в такой записи не будет проблемы. Потому что в одном потоке в единый момент времени выполняется только одна функция. Но при работе с общей памятью подобной гарантии быть не может. Пока в одном потоке увеличивается значение переменной `temp`, другой поток может успеть изменить значение `sharedMemory[0]`.
Для решения этой проблемы можно использовать метод `Atomics.add` и `Atomics.load`.


```js
Atomics.add(sharedMemory, 0, 5); // 0

Atomics.load(sharedMemory, 0); // 5
```

## Использование `Atomics`
`Atomics` - мощный многофункциональный инструмент необходимый для работы с многопоточностью, но, к сожалению, он очень не прост в использовании из-за своего низкоуровнего API. По этой причине в чистом виде `Atomics` применяются не часто. Зачастую проще использовать более высокоуровневое API построенное на `Atomics`.

Одним из распространных паттерном многопоточного программирования являются критические секции. Вам могут быть знакомы такие примитивы из других языков программирования, как `Mutex`, `Semaphore`, `ReadWriteLock` и другие. Их возможно реализовать и в JavaScript. Для того, чтобы лучше понять область применения `Atomics`, рассмотрим пример получения состояния гонки.

### Как получить состояние гонки
Допустим, что у нас есть общая переменная. В одном потоке мы хотим 10 000 000 раз увеличить ее на 1, а в другом 10 000 000 раз уменьшить на 1. Что мы получим в результате? 0?

```js
// Main Thread
for (let i = 0; i < 10_000_000; i++) {
  sharedMemory[0] = sharedMemory[0] + 1;
}

// Worker
for (let i = 0; i < 10_000_000; i++) {
  sharedMemory[0] = sharedMemory[0] - 1;
}
```

Вывод в консоль может выглядеть так, но каждый раз он будет случайным, т.к. зависит от ресурсов компьютера и текущей нагрузки на него.

```
> Main Thread Started: 0
> Worker Started: 352
> Main Thread Finished: -2573302
> Worker Finished: -2741254
```

### Разрешение состояния гонки
При разрешении состояния гонки мы можем использовать `Mutex`. `Mutex` обеспечивает механизм критических секций. Критическая секция - это часть кода между вызовами блокировки и разблокировки состояния. Более простыми словами - `Mutex` позволяет только одному потоку в единый момент времени владеть общим состоянием.

Если кратко, то:
- `Mutex` имеет два состояния "заблокирован" и "разблокирован"
- Пока `Mutex` заблокирован, остальные потоки ожидают получения права на блокировку
- В момент разблокировки `Mutex` уведомляет один ожидающий поток
- `Mutex` не может быть разблокирован дважды

### Реализация Mutex на Atomics
`Mutex` на `Atomis` в JavaScript может быть реализован разными способами, но самый распространенный основан на таких методах, как `Atomics.wait`, `Atomics.waitAsync`, `Atomics.compareExchange`, `Atomics.notify`.

Посмотрим на реализацию.

```js
const INDEX = 0;
const UNLOCKED = 0;
const LOCKED = 1;

class Mutex {
  constructor(sharedArrayBuffer) {
    this.arrayView = new Int32Array(sharedArrayBuffer);
  }

  lock() {
    while (true) {
      const oldValue = Atomics.compareExchange(
        this.arrayView,
        INDEX,
        UNLOCKED,
        LOCKED
      );

      if (oldValue === UNLOCKED) {
        return;
      }

      Atomics.wait(this.arrayView, INDEX, LOCKED);
    }
  }

  unlock() {
    const oldValue = Atomics.compareExchange(
      this.arrayView,
      INDEX,
      LOCKED,
      UNLOCKED
    );

    if (oldValue === UNLOCKED) {
      throw new Error("Mutex уже был разблокпирован!");
    }

    Atomics.notify(this.arrayView, INDEX, 1);
  }

  executeLocked(callback) {
    const tryGetLock = async () => {
      while (true) {
        const oldValue = Atomics.compareExchange(
          this.arrayView,
          INDEX,
          UNLOCKED,
          LOCKED
        );

        if (oldValue === UNLOCKED) {
          callback();
          this.unlock();

          return;
        }

        const result = Atomics.waitAsync(this.arrayView, INDEX, LOCKED);

        await result.value;
      }
    };

    tryGetLock();
  }
}
```

Состояние `Mutex` может принимать значения `LOCKED = 1` и `UNLOCKED = 0` и хранится по индексу `INDEX = 0`. Стоит учесть, что в коде используется `Int32Array` для хранения состояния, потому что некоторые атомарные операции, такие как `Atomics.wait`, `Atomics.notify` и другие, работают только с `Int32Array` или `BigInt64Array`.

Метод `lock`, пытается перевести `Mutex` в заблокированное состояние. Это делается с помощью `Atomics.compareExchange` и `Atomics.wait`. Благодаря `Atomics.compareExchange` состояние изменяется на заблокировано только в том случае, если оно было разблокировано. `Atomics.compareExchange` возвращает предыдущее состояние, которое можно использовать, чтобы проверить, удалось ли получить блокировку или нет. Если нет, то с помощью `Atomics.wait` ожидаем, пока кто-нибудь не разблокирует `Mutex` и не уведомит нас об этом.

С методом `unlock` все проще. Состояние изменятеся на разблокировано только в том случае, если оно было заблокировано. В ином случае - выкидывается ошибка. Далее с помощью `Atomics.notify` уведомляется 1 ожидающий агент о возможности получения блокировки. Если же ожидающих агентов нет - уведомление будет проигнорировано.

Метод `executeLocked` реализован по аналогии с `lock`, но является асинхронным для возможности использования в Main Thread.

### Применение Mutex на Atomics

Вот так может быть использован `Mutex`, построенный на `Atomics` для разрешения состояния гонки.

```js
// Main Thread
const mutexBuffer = new SharedArrayBuffer(4);
const mutex = new Mutex(mutexBuffer);

for (let i = 0; i < 10_000_000; i++) {
  // асинхронно получаем блокировку
  mutex.executeLocked(() => {
    sharedMemory[0] = sharedMemory[0] + 1;
  });
}

// Worker
const mutex = new Mutex(mutexBuffer);

for (let i = 0; i < 10_000_000; i++) {
  // синхронно получаем блокировку
  mutex.lock();
  sharedMemory[0] = sharedMemory[0] - 1;
  mutex.unlock();
}
```

Вывод в консоль может выглядеть так. Вне зависимости от ресурсов комьютера или очередности работы потоков, в результате всегда будет 0, т.к. благодаря `Mutex` и в частности `Atomics`, потоки по очереди получают блокировку и изменяют состояние.

```
> Main Thread Started: 0
> Worker Started: 0
> Main Thread Finished: 3232452
> Worker Finished: 0
```

Конечно, в идеале `Mutex` должен быть встраеваемым в структуру данных, с которой происходит работа. Но данный пример служит в ознакомительных целях для наглядного гайда по применению `Atomics` в JavaScript.

## Статические методы
`Atomics.add` прибавляет заданное значение по индексу. Возвращает предыдущее значение.

`Atomics.sub` вычитает заданное значение по индексу. Возвращает предыдущее значение.

`Atomics.and` вычисляет побитовое "И" c заданным значением и значением по индексу. Возвращает предыдущее значение.

`Atomics.or` вычисляет побитовое "ИЛИ" c заданным значением и значением по индексу. Возвращает предыдущее значение.

`Atomics.xor` вычисляет побитовое исключающее "ИЛИ" c заданным значением и значением по индексу. Возвращает предыдущее значение.

`Atomics.compareExchange` обновляет значение по индексу только если оно равно указанному значению. Возвращает предыдущее значение.

`Atomics.exchange` обновляет заданное значение по индексу. Возвращает предыдущее значение.

`Atomics.load` возвращает значение по индексу.

`Atomics.notify` уведомляет определенное число агентов, ожидающих по указанному индексу. Возвращает число уведомленных агентов.

`Atomics.store` сохраняет заданное значение по индексу. Возвращает сохраненное значение.

`Atomics.wait` проверяет значение по индексу и уходит в режим ожидания до уведомления о пробуждении или истечения времени ожидания. Нельзя использовать в главном потоке (Main Thread) в большинстве браузеров, т.к. является блокирующим.

`Atomics.waitAsync` - неблокирующий аналог `Atomics.wait`, возвращает `Promise`.

