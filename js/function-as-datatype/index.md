---
title: "Функция как тип данных"
description: "С функцией можно работать, как с любым другим типом данных: сохранять в переменную, передавать, возвращать из функции"
authors:
  - nlopin
tags:
  - doka
---

## Кратко

Функции — это объект первого класса. Это означает, что функцию можно использовать так же, как и другие типы данных: сохранять в переменную, передавать аргументов и возвращать из функции.

Технически, функция — это [объект JavaScript](/js/object) у которого есть внутренний метод `Call`, который добавляет возможность вызова функции.

Если вы хотите узнать о синтаксисе функций, читайте статью [`function`](/js/function).

## Как понять

Во многих языках функции — это специальные конструкции языка. Они не являются типом данных, и набор операций, которые с ними можно делать ограничен — их можно только объявлять и вызывать.

В JavaScript функция — это тип данных, примерно такой же как объект или строка. Это означает, что с ним можно работать так же, как и с любым другим типом данных — сохранять в переменную, передавать в качестве аргумента функции, возвращать из функций.

О функции удобно думать как об объекте, который поддерживает операцию вызова.

### Хранение функции в переменной

Функции можно объявлять различными способами. Объявление функции с помощью функционального выражения ни что иное, как присваивание безымянной функции переменной:

```js
const answer = function() {
  console.log('42!')
}

answer()
// 42!
```

Можно сохранять в переменную и функцию, объявленную другим способом. При этом оба имени функции будут работать:

```js
function answerNumber() {
  console.log('42!')
}

const answer = answerNumber

answerNumber()
// 42!
answer()
// 42!
```

Переменная хранит ссылку на функцию, поэтому мы можем создавать столько переменных, сколько нам нужно и все они будут именами функции:

```js
const answer = function() {
  console.log('42!')
}

const answerNumber = answer
const fn = answer
```

### Передача функции в вызов другой функции

Функция может передаваться в качестве аргумента при вызове другой функции.

Например, функция, которая может выполнить произвольную операцию между двумя числами. Два числа хранятся внутри функции, а операция, которую нужно выполнить, передаётся при вызове:

```js
function performOperation(operation) {
  const a = 10
  const b = 99
  return operation(a, b)
}

const sum = performOperation(function(one, two) { return one + two })
console.log(sum)
// 109

const result = performOperation(function(num1, num2) { return num1 ** (num1 / num2)})
console.log(result)
// 1.2618568830660204
```

Таким образом логика операции может определяться вне функции, что делает её гибкой.

Функции, которые ожидают получить другую функцию в качестве параметра — стандартное явление в JavaScript. Даже встроенные методы, такие как [`forEach`](/js/array-foreach) и [`filter`](/js/array-filter) используют этот подход.

Другой случай использования — [колбэки в асинхронном коде](/js/async-in-js/#kolbeki). Иногда необходимо выполнить операцию после того, как закончится какое-то действие. Например, когда пользователь кликнет на кнопку. В этом случае используется метод [`addEventListener`](/js/element-addeventlistener), который принимает имя события и колбэк, который нужно вызвать при его наступлении:

```js
document.getElementsByTagName('button')[0].addEventListener('click', function() {
  console.log('пользователь кликнул!')
})
```

### Возвращение функции как результат вызова

Функцию можно вернуть как результат работы другой функции. Например, можно сохранить данные для математической операции, но не выполнять её сразу, а вернуть функцию, которая выполнит операцию над указанными числами:

```js
function lazySum(a, b) {
  return function() {
    return a + b
  }
}
```

Здесь очень легко запутаться во вложенности. При вызове `lazySum` мы передаём два аргумента. Эти аргументы не используются тут же — мы создаём новую функцию, которая складывает два числа и возвращаем её. После вызова `lazySum` мы можем сохранить эту функцию в переменную и использовать её, когда нужно:

```js
const performSum = lazySum(99, 1)
console.log(performSum)
// function lazySum()

console.log(performSum())
// 100
```

Такой подход также активно используется при разработке на JavaScript.
