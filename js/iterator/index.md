---
title: "Итератор"
authors:
  - kanishev
keywords:
  - Итератор
  - Итерируемый объект
  - Symbol.iterator
  - iterator
tags:
  - doka
---

## Кратко

Итератор - это объект, который умеет обращаться к элементам коллекции по одному за раз, при этом отслеживая своё текущее положение внутри этой последовательности.

Иными словами итератор - это такой механизм, который позволяет перемещаться (_итерироваться_) по элементам коллекции в определённом порядке и делает их доступными.

## Как это понять

В JavaScript итератор - это объект, который возвращает следующий элемент последовательности, через метод `next()`. Этот метод возвращает объект с двумя свойствами:

- `value` - значение текущего элемента коллекции.
- `done` - индикатор, указывающий, есть ли ещё в коллекции значения, доступные для перебора.

```js
function makeIterator(array) {
  let nextIndex = 0;

  return {
    next: function () {
      if (nextIndex < array.lenght) {
        return { value: array[nextIndex++], done: false };
      } else {
        return { done: true };
      }
    },
  };
}
```

После создания, объект-итератор может быть явно использован, с помощью вызовов метода next():

```js
let iterator = makeIterator(["Hello", "world"]);
console.log(iterator.next().value); // 'Hello'
console.log(iterator.next().value); // 'world'
console.log(iterator.next().done); // true
```

Как только метод _next_ завершает перебор, то возвращается _{ done: true }_. Это является сигналом, что итерирование завершено.

## Зачем это нужно

Практически везде, где нужен перебор, он осуществляется через итераторы. Это включает в себя не только [_строки_](/js/string), [_массивы_](/js/arrays), но и другие структуры данных.
В современный JavaScript добавлена новая концепция «итерируемых»(_iterable_) объектов, например Map, представленный [_ES6_](https://262.ecma-international.org/6.0).

Это позволяет использовать любой объект в цикле `for..of`:

```js
for (let value of ["a", "b", "c"]) {
  console.log(value); // a, b, c
}
```

<aside>

⚠️ Чтобы быть итерируемым, объект должен реализовать метод _@@iterator_.
Это означает, что он (или один из объектов в цепочке прототипов) должен иметь свойство `Symbol.iterator`

</aside>

Предположим, у нас есть объект range, который представляет диапазон чисел:

```js
let range = {
  from: 1,
  to: 3,
};
```

Чтобы сделать такой объект итерируемым (и позволить _for..of_ работать с ним), в нем нужно определить _Symbol.iterator_:

```js
range[Symbol.iterator] = function () {
  return {
    next() {
      if (this.from <= this.to) {
        return { done: false, value: this.from++ };
      } else {
        return { done: true };
      }
    },
  };
};
```

Убедимся, что объект _range_ действительно итерируется:

```js
for (let x of range) {
  console.log(x); // 1, 2, 3
}
```

## Встроенные итераторы

В некоторых случаях интерфейс итератора вызывается по умолчанию. Такие объекты как _String_, _Array_, _Map_ и _Set_ являются итерируемыми, потому что их прототипы содержат _Symbol.iterator_.

Помимо цикла _for-of_, итераторы используют:

**Деструктуризация**.

При деструктуризации итератор используется для доступа к элементам коллекции:

```js
const [a, b] = new Set(["a", "b", "c"]);
// a
// b
```

**Array.from()**

[`Array.from()`](js/array-from) позволяет конвертировать итерируемый объект в Array:

```js
const arr = Array.from(new Set(["a", "b", "c"]));
// ['a', 'b', 'c']
```

**Spread оператор**.

Оператор распространения также вызывает интерфейс итератора по умолчанию:

```js
const arr = [...new Set(["a", "b", "c"])];
// ['a', 'b', 'c']
```

**Map, Set**.

Конструкторы Map и Set преобразуют итерируемые значения в соответственно Map и Set:

```js
const map = new Map([
  ["uno", "one"],
  ["dos", "two"],
]);
map.get("uno"); // one
map.get("dos"); // two

const set = new Set(["red", "green", "blue"]);
set.has("red"); // true
set.has("yellow"); // false
```
