---
title: "Сложность алгоритмов: понимание и применение"
description: "Разбираем ключевые концепции сложности алгоритмов, включая обозначения O(n), Ω(n) и ϴ(n)."
authors:
  - eshevlyakova
related:
  -
tags:
  - doka
---

## Кратко

Начнём раздел об алгоритмах с понятия — сложность алгоритмов. Это показатель, который описывает насколько быстро работает алгоритм в зависимости от размера входных данных. Однако это не всегда так. Например, для алгоритмов со сложностью `O(1)` время работы не зависит от размера входных данных.

## Обозначения

Существует несколько обозначений сложности алгоритмов, которые используются для описания того, как быстро работает алгоритм. Вот некоторые из них:

- `O(n)` — описывает наихудшую временную сложность алгоритма. Оно читается как «О большое от n» или «биг О от n». Если алгоритм имеет временную сложность `O(n)`, то время его работы будет увеличиваться вместе с увеличением количества входных данных n. Это означает, что если количество входных данных удвоится, то время выполнения алгоритма также удвоится. Однако следует помнить, что время выполнения может зависеть от многих факторов, таких как состояние системы, ресурсы процессора и т. д., поэтому оно может быть различным для одного и того же количества входных данных. Также количество входных данных не равно количеству операций. Оно может быть больше или меньше, но будет изменяться вместе с размером входных данных.
- `Ω(n)` — описывает наилучшую временную сложность алгоритма. Оно читается как «Омега большое n». Если алгоритм имеет временную сложность `Ω(n)`, то время работы пропорционально количеству входных данных n.
- `ϴ(n)` — описывает среднюю временную сложность алгоритма. Оно читается как «Тета большое n». Если алгоритм имеет временную сложность `ϴ(n)`, то время работы пропорционально количеству входных данных n.

## Примеры

Для лучшего понимания давайте рассмотрим примеры. Представим, что мы хотим сменить наш логотип и выбрать дизайнера с наибольшим опытом. У нас есть массив с числами в годах и, следовательно, нам нужно найти максимальное число:

```js
function findMax(arr) {
  let max = arr[0];
  for (let i = 1; i < arr.length; i++) {
    if (arr[i] > max) {
      max = arr[i];
    }
  }
  return max;
}
```

Этот код имеет временную сложность `O(n)`, потому что он выполняет одну операцию для каждого элемента массива. Если есть массив из x элементов, то этот код выполнится за x операций.

Теперь представим, что у нас есть отсортированный по возрастанию массив с опытом дизайнеров, и мы всё так же хотим найти самого опытного дизайнера:

```js
function findMax(arr) {
  return arr[arr.length - 1];
}
```

Этот код имеет временную сложность `Ω(1)`, потому что он выполняет только одну операцию, независимо от размера массива.

Наконец, представим, что у есть массив чисел, которые также обозначают опыт дизайнеров, и мы должны отсортировать числа по возрастанию:

```js
function sortArray(arr) {
  for (let i = 0; i < arr.length; i++) {
    for (let j = i + 1; j < arr.length; j++) {
      if (arr[i] > arr[j]) {
        let temp = arr[i];
        arr[i] = arr[j];
        arr[j] = temp;
      }
    }
  }
  return arr;
}
```

Этот код имеет временную сложность `ϴ(n^2)`, потому что он выполняет две операции для каждой пары элементов массива. Если массив состоит из 10 элементов, то код выполнится за 100 операций. То есть, если массив состоит из n элементов, код выполнится за n^2 операций.
