---
title: "Как анализировать алгоритмы?"
description: "Разбираемся, что такое сложность алгоритмов, как посчитать сложность по времени и по памяти."
authors:
  - eshevlyakova
related:
  -
tags:
  - doka
---

## Кратко
Разбираемся с понятием «вычислительная сложность алгоритма». Обычно оценивают две сложности:
- _временную сложность_: как связано количество операций, которые будут выполняться при работе алгоритма с объёмом данных на вход;
- _сложность по памяти_: как связано количество памяти, нужной алгоритму с размером входных данных.

Для обоих определений мы хотим оценить связь потребляемого алгоритмом ресурса (время или память) с количеством данных на входе. Интуитивно кажется, что, чем больше размер входных данных, тем медленнее будет работать алгоритм и тем больше он будет потреблять памяти, однако это не всегда так. Например, время работы функции `const doNothing = (...asManyDataAsYouLike) => { }` скорее всего не будет зависеть от количества переданных ей аргументов. Оценка сложности такой функции `O(1)`. Попробуем разобраться, что это значит.

## Обозначения
Есть несколько способов оценки сложности алгоритмов. Основная идея этих оценок – получить какое-то ограничение для функции, которая связывает размер входных данных и количество операций или размер памяти. При этом не нужно определять эту функцию точно. Нам нужна именно оценка.
Более точный термин – _асимптотическая_ сложность. Это значит, что для какого-то _достаточно большого_ значения входных данных эта оценка будет верна, но она не обязательно верна для небольшого количества данных. Точное определение можно найти [в Википедии](https://ru.wikipedia.org/wiki/%D0%92%D1%8B%D1%87%D0%B8%D1%81%D0%BB%D0%B8%D1%82%D0%B5%D0%BB%D1%8C%D0%BD%D0%B0%D1%8F_%D1%81%D0%BB%D0%BE%D0%B6%D0%BD%D0%BE%D1%81%D1%82%D1%8C).
Вот некоторые способы оценки сложности алгоритма:
- `O(n)`: это обозначение описывает наихудшую временную сложность алгоритма. Оно читается как “О большое от n” или “биг о of n”. Если алгоритм имеет временную сложность `O(n)`, то время его работы будет увеличиваться вместе с увеличением количества входных данных n. Это означает, что если количество входных данных удвоится, то время выполнения алгоритма также удвоится. Однако следует помнить, что время выполнения может зависеть от многих факторов, таких как состояние системы, ресурсы процессора и т.д., поэтому оно может быть различным для одного и того же количества входных данных. Также количество входных данных не равно количеству операций,  оно может быть больше или меньше, но оно будет изменяться вместе с размером входных данных.
- `Ω(n)`: это обозначение описывает наилучшую временную сложность алгоритма. Оно читается как “Омега большое n”. Если алгоритм имеет временную сложность `Ω(n)`, то время его работы будет пропорционально количеству входных данных n.
- `ϴ(n)`: это обозначение описывает среднюю временную сложность алгоритма. Оно читается как “Тета большое n”. Если алгоритм имеет временную сложность `ϴ(n)`, то время его работы будет пропорционально количеству входных данных n.

## Примеры

Для лучшего понимания давайте рассмотрим примеры. Представим, что мы хотим сменить наш логотип и выбрать дизайнера с наибольшим опытом. У нас есть массив с числами в годах и, следовательно, нам нужно найти максимальное число:

```js
function findMax(arr) {
  let max = arr[0];
  for (let i = 1; i < arr.length; i++) {
    if (arr[i] > max) {
      max = arr[i];
    }
  }
  return max;
}
```

Этот код имеет временную сложность `O(n)`, потому что он выполняет одну операцию для каждого элемента массива. Если есть массив из x элементов, то этот код выполнится за x операций.

Теперь представим, что у нас есть отсортированный по возрастанию массив с опытом дизайнеров, и мы всё так же хотим найти самого опытного дизайнера:

```js
function findMax(arr) {
  return arr[arr.length - 1];
}
```

Этот код имеет временную сложность `Ω(1)`, потому что он выполняет только одну операцию, независимо от размера массива.

Наконец, представим, что у есть массив чисел, которые также обозначают опыт дизайнеров, и мы должны отсортировать числа по возрастанию:

```js
function sortArray(arr) {
  for (let i = 0; i < arr.length; i++) {
    for (let j = i + 1; j < arr.length; j++) {
      if (arr[i] > arr[j]) {
        let temp = arr[i];
        arr[i] = arr[j];
        arr[j] = temp;
      }
    }
  }
  return arr;
}
```

Этот код имеет временную сложность `ϴ(n^2)`, потому что он выполняет две операции для каждой пары элементов массива. Если массив состоит из 10 элементов, то код выполнится за 100 операций. То есть, если массив состоит из n элементов, код выполнится за n^2 операций.
