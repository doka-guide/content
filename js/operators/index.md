---
title: "Базовые операторы в JS"
description: "Обзор ключевых операторов JavaScript: арифметика, приоритет, инкремент, декремент и присваивание"
authors:
  - anton-fomichev
keywords:
  -
related:
  -
tags:
  - doka
---

<!--
1. В description есть описание для соцсетей и поисковиков, не больше 200 символов
2. В authors есть ники авторов основного текста
3. В contributors перечислены ники всех соавторов и тех, кто работал над текстом (дописали «На практике»? Переписали блок? Вам сюда)
4. В keywords записаны ключевые слова для SEO: пишем сюда слова или фразы, которых нет в тексте статьи, но по ним могут искать этот материал
5. Удалены все пустые теги в шапке
6. Подпапка автора есть в папке _people/_
7. Демки лежат в подпапке _demos/_
8. В related добавлено три ссылки на материалы Доки, которые будут предлагаться в конце. Не добавляем следующий или предыдущий материал в разделе
-->

## Кратко

В JavaScript есть несколько базовых операторов, с которыми разработчики сталкиваются постоянно в ходе своей работы. Они позволяют выполнять арифметические действия, изменять значения переменных, а также помогают разработчику упростить некоторые операции в коде.

## Кто такие: «оператор», «операнд»?

JavaScript (как и многие другие языки) использует понятия «операторы» и «операнды»:

- **Оператор** — это специальный символ или ключевое слово, указывающее движку JavaScript выполнить какое-то действие

- **Операнд** — это то, над чем оператор выполняет действие (например: число, строка, переменная)

## Типы операторов

В зависимости от количества операндов операторы делят на 2 типа:

1. Унарные операторы,
1. Бинарные операторы.

### Унарные операторы

Унарные операторы зависят от одного операнда. Другими словами, они действуют только на один объект.

Примером может послужить знакомый нам из курса школьной математики оператор _унарный минус_ `-`, который меняет знак числа на противоположный:

```js
let x = 5;
x = -x;
console.log(x); // -5
```

### Бинарные операторы

Бинарные операторы применяются к двум операндам.

В приведенном ниже примере оператор `+` применяется к операндам `x` и `y` и возвращает значение — сумму операндов:

```js
const x = 5, y = 2;
const sum = x + y;
console.log(sum); // 7
```

Рассмотрим более интересный пример: оператор _больше чем_ `>`. Проверим возраст пользователя перед показом фильма в интернет-кинотеатре. Оператор `>` применяется к операндам `user.age` и `movie.ageLimit` и вернет значение логического типа — результат сравнения двух чисел:

```js
const movie = {
  title: "Во все тяжкие",
  ageLimit: 18,
};

const user = {
  age: 19,
  name: "Прохор",
};

const isUserAllowed = user.age > movie.ageLimit; // true

if (isUserAllowed) {
  console.log("Удачного просмотра!");
}
```

## Математика

JavaScript поддерживает стандартные арифметические операторы, которые помогают складывать, вычитать, умножать и делить числа. Ниже перечислены самые популярные из них:

### Сложение

Оператор сложения `+` складывает два числа и возвращает результат:

```js
const sum = 5 + 2;
console.log(sum); // 7
```

### Вычитание, умножение и деление

Операторы `-`, `*`, `/` — операторы вычитания, умножения и деления. Применяются для работы только с числами. Если хотя бы одно из значений не может быть преобразовано к числу, итогом будет `NaN` (Not a Number).

```js
const a = 10;
const b = 3;
const invalidOperand = "Блаблабла";

console.log(a - b); // 7
console.log(a * b); // 30
console.log(a / b); // 3.333333..
console.log(a - invalidOperand); // NaN
```

### Остаток от деления

Оператор остатка от деления `%` возвращает остаток при делении одного числа на другое:

```js
console.log(10 % 3); // 1
console.log(8 % 2); // 0 (делится без остатка)
```

### Возведение в степень

Оператор возведения в степень `**` работает аналогично функции `Math.pow(a, b)`, только записывается короче:

```js
console.log(2 ** 2); // 4
console.log(2 ** 5); // 32
```

Важно, что привычный многим оператор `^` не является оператором возведения в степень. На самом деле, это [исключающее «или»](https://ru.wikipedia.org/wiki/Исключающее_«или»).

## Не только математика

JavaScript позволяет применять операторы не только к числам — на практике можно встретить ситуации, когда один или оба операнда оказываются строками, булевыми значениями или даже объектами. Всё это благодаря тому, что [почти всё в JavaScript — объект](/js/objects-objects-everywhere/).

### Конкатенация строк

Если хотя бы один операнд у оператора `+` — строка, в результате получится склейка (конкатенация). Например:

```js
console.log("Hello" + " " + "world"); // "Hello world"
console.log("5" + 2); // "52"
```

### Сравнение строк

Операторы сравнения, такие как `>` или `<`, могут применяться к строкам. При этом строки сравниваются _лексикографически_ — посимвольно в порядке символов, а не по их «числовому» содержанию.

Следующее выражение возвращает `true` после сравнения первых символов строк `"2"` и `"15"` — `"2"` и `"1"`:

```js
console.log("2" > "15"); // true
```

Каждому символу соответствует код из [UTF-16](https://ru.wikipedia.org/wiki/UTF-16), с помощью которого и происходит сравнение двух символов.

### Преобразование объектов

При попытке использовать арифметические операторы вроде `+`, `-` или `*` с объектами или массивами, JavaScript попытается привести их к примитиву через метод `toString()` или `valueOf()`. Порой это приводит к результатам, которые сложно предсказать, если не знать механизма преобразований:

```js
console.log({} + {}); // "[object Object][object Object]"

// В массиве по умолчанию toString() склеивает элементы:
console.log([1, 2, 3] + [4, 5]); // "1,2,34,5"
```

### Булевые значения

В арифметическом контексте `true` приводится к `1`, а `false` — к `0`. Однако при конкатенации строк (`+`) булевые значения не будут автоматически превращаться в числа:

```js
console.log(true + 1); // 2
console.log(false + 10); // 10
console.log(true + "1"); // "true1"
```

## Приоритет операторов

В JavaScript у операторов есть жёстко определённый порядок (приоритет) выполнения. Это означает, что некоторые операции будут выполняться раньше других, если в выражении нет дополнительных скобок.

Рассмотрим отрывок из [таблицы приоритетов](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Operators/Operator_precedence#таблица):

| Приоритет | Название               | Обозначение |
|-----------|------------------------|-------------|
| …         | …                      | …           |
| **15**    | унарный плюс          | `+`         |
| **15**    | унарный минус         | `-`         |
| **14**    | возведение в степень  | `**`        |
| **13**    | умножение             | `*`         |
| **13**    | деление               | `/`         |
| **12**    | сложение              | `+`         |
| **12**    | вычитание             | `-`         |
| …         | …                      | …           |
| **2**     | присваивание          | `=`         |
| …         | …                      | …           |

Нетрудно заметить, что приоритет _унарных_ операторов выше, чем приоритет _бинарных_ (за некоторыми исключениями: оператор группировки, вызов функции, доступ к свойствам и т. п.).

На практике запоминать приоритет всех операторов не нужно: в спорных случаях всегда лучше проставить скобки явно. Опытным разработчикам это может показаться избыточным, но главное — правильность выполнения и прозрачность написанного кода для всей команды разработчиков, в том числе — для новичков.

### Присваивание

Оператор присваивания `=` в JavaScript находится почти в самом низу приоритетов. Его суть проста: взять значение выражения справа и присвоить переменной слева. Например:

```js
const result = 10;
```

Важно, что оператор присваивания возвращает значение, которое было присвоено переменной:

```js
let a;
console.log(a = "Hello world!"); // "Hello world!"
```

Оператор присваивания выполняется справа налево. В примере ниже, сначала выполнится `b = 5`, вернётся `5`, а затем значение присвоится `a`. В итоге `a` и `b` оба станут равны `5`:

```js
let a, b;
console.log(a = b = 5); // 5
console.log(a, b); // 5 5
```

#### Как делать не надо

Иногда можно увидеть слишком хитрые конструкции, где в одном выражении смешиваются разные операторы, в том числе присваивания. Они затрудняют понимание кода и приводят к неочевидному порядку вычислений. Например, когда люди пытаются скомбинировать много логики в одной строке:

```js
const a = 2 + (b = 3 * 5); // a = 17, b = 15
```

Такой код работает, но его сложно читать и поддерживать, особенно если в нём участвуют более сложные вычисления. В большинстве случаев лучше разбить логику на несколько строк — так понятнее и надёжнее:

```js
const b = 3 * 5; // 15
const a = 2 + b; // 17
```

### Инкрементное присваивание

Помимо обычного оператора `=`, в JavaScript есть целая группа **сокращённых операторов присваивания**. Они позволяют одновременно выполнить арифметическую операцию и присвоить результат переменной. Например:

- `x += 1` эквивалентно `x = x + 1`;
- `x -= 2` эквивалентно `x = x - 2`;
- `x *= 3` эквивалентно `x = x* 3`;
- `x /= 4` эквивалентно `x = x / 4`;
- `x %= 5` эквивалентно `x = x % 5`;
- `x **= 6` эквивалентно `x = x ** 6`.

Зачем это нужно?

1. **Короткая запись**. Вместо `x = x + 10` можно использовать `x += 10`;
1. **Удобство при изменении счётчика**. В циклах или при пошаговом изменении переменной такие записи упрощают код и делают его немного выразительнее.

## Инкремент и декремент

Инкремент и декремент — это унарные операторы, которые увеличивают или уменьшают значение переменной на `1`. Выглядят они так:

- **Инкремент**: `++`,
- **Декремент**: `--`.

При этом существует две формы — _префиксная_ и _постфиксная_, и они отличаются моментом, когда переменная меняет своё значение.

### Постфиксная форма

Постфиксные операторы (`x++`, `x--`) сначала _возвращают старое значение_, а лишь затем меняют переменную:

```js
let x = 5;
console.log(x++); // 5 (возвращаем старое значение)
console.log(x); // 6 (теперь переменная увеличена)
```

### Префиксная форма

Префиксные операторы (`++x`, `--x`) сначала изменяют переменную, а затем возвращают новое значение:

```js
let count = 5;
console.log(++count); // 6 (значение уже увеличено)
console.log(count); // 6 (значение остаётся увеличенным)
```

### Когда использовать

Инкремент и декремент нередко применяют в циклах `for` или `while`, чтобы удобнее управлять переменными-счётчиками. Поочередный вывод чисел от 0 до 4 (включительно) в консоль может выглядеть так:

```js
for (let i = 0; i < 5; i++) {
  console.log(i);
}
```

### Подводные камни

Чаще всего проблемы в использовании инкремента или декремента в JavaScript связаны с особенностями постфиксной или префиксной формы. Если не помните, когда возвращается старое значение, а когда новое, лучше используйте отдельные инструкции присваивания.

<!-- Заметки -->
<!-- Показать isEven/isOdd -->
<!-- Можно показать задачу на UTF-8, где алфавит -->
