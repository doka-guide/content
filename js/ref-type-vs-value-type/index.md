---
title: "Передача данных по ссылке и по значению"
description: "Простое значение копируется как есть, но когда неизвестно насколько оно простое, то нужен другой подход."
authors:
  - windrushfarer
contributors:
  - rrramble
keywords:
  - reference
  - value
related:
  - js/arrays
  - js/object
  - js/function-as-datatype
tags:
  - article
---

## Кратко

Переменные передаются в функции, а также присваиваются другим переменным, двумя способами:

1. **По значению** — передаются **примитивы** (числа, числа BigInt, булевы значения, строки, null, undefined, символы);
1. **По ссылке** — передаются **объекты** (массивы ассоциативные и обычные, функции, классы).

«По значению» означает, что в другую переменную или в функцию копируется (дублируется) **значение** исходной переменной.

«По ссылке» означает, что другая переменная **ссылается** на ту же область памяти, что и исходная. Копирование (дублирование) самих значений не выполняется.

## Как понять

Пример передачи по значению:

```js
// Число '42' это примитив
let first = 42

// поэтому во вторую пременную 'second' копируется значение '42'
let second = first

// Если изменить 'second' на число '33' ...
second = 33

// то в переменной 'first' останется первоначальное значение
// так как переменная 'first' не зависит от переменной 'second'
console.log(first)
// 37
```

При передаче по ссылке результат интереснее: изменение второй переменной влияет на исходную переменную.

```js
// Для передачи по ссылке переменная должна быть объектом
const first = { something: 42 }
const second = first

// Если поменять значение у второй переменной, то первая тоже изменится!
second.something = 33
console.dir(first)
// { something: 33 }
```

Ниже пример передачи по ссылке внутрь функции. В функции можно _нечаянно_ изменить переданный объект:

```js
const first = { something: 42 }

function subtract9(item) {
  item.something -= 9
  return item
}

// Функция дает ожидаемый результат...
console.log(subtract9(first));
// { something: 33 }

// но также и изменяет исходный объект
console.log(item)
// { something: 33 }
```

Представьте, что вы кладёте ложку в ящик. Когда вы захотите взять ложку, вы открываете ящик и берёте это значение-ложку.

Теперь представим, что нужно хранить предметы размером от ложки до квартиры.
Так как заранее не известно, какого размера предмет, то в ящике хранится бумажка с записью: где реально находится квартира.

Примитивы гораздо проще, поэтому их легче скопировать при присвоении или передаче в функцию.

Объекты обычно сложные или большие: представьте массив из миллиона чисел. Копирование привело бы к повторному выделению такого-же объёма памяти как исходный объект.

**В чем же фундаментальное отличие?**

Отличий несколько, некоторые могут приводить к неприятным последствиями в коде.

То, как будут храниться данные, жёстко связано с типом данных. Нельзя заставить значение примитивного типа храниться по ссылке, и наоборот.

Для того чтобы понять, как хранятся разные типы данных, заглянем в память компьютера.

## Примитивные типы данных

Когда мы объявляем переменную и сохраняем в неё примитивное значение, то в память записывается какое-то количество байт, которое описывает это значение. Таким образом можно сказать, что наша переменная уже сразу содержит эти байты.

```js
const seven = 7 // 0b0111
const eight = 8 // 0b1000
```

Если присвоить какое-то значение переменной в другую, то мы просто скопируем это же количество байт в новое место.

```js
const sevenAgain = seven // 0b0111
```

В итоге все наши переменные можно схематически отобразить таким образом:

![Схематическое отображение переменных](images/1.png)

Когда мы сравниваем два значения, то у нас по сути произойдёт побайтовое сравнение этих величин.

```js
console.log(seven === sevenAgain)
// true
```

![Побайтовое сравнение величин с результатом true](images/2.png)

```js
console.log(seven === eight)
// false
```

![Побайтовое сравнение величин с результатом false](images/3.png)

Из-за того, что все примитивные значения хранятся в небольшом и фиксированном количестве байт, операции над ними выполнять несложно. Такие типы данных называют _примитивными_. В них входят числа ([`number`](/js/number/)), строки ([`string`](/js/string/)), булевы ([`boolean`](/js/boolean/)), а так же специальные значения [`null`](/js/null-primitive/) и [`undefined`](/js/undefined/).

## Объектные типы данных

С объектами и другими сложными данными дела обстоят сложнее из-за того, что мы не знаем, какое количество памяти для них понадобится. Во время работы с такой структурой компьютеру необходимо следить за тем, сколько памяти уже есть, сколько понадобится, и выделять новую. Работать с такими данными сложнее. Для этого компьютер отдаёт нам ссылку на место, где данные хранятся, и самостоятельно будет работать с ними по инструкциям, которые мы ему даём. Таким образом в переменную мы получаем лишь ссылку на данные.

```js
const myData = {}
```

![Схематичное изображение переменной myData со ссылкой на участок памяти](images/4.png)

Обратите внимание, что направление стрелки поменялось. Так мы обозначим, что наша переменная ссылается на участок памяти.

☝️ Если сейчас присвоить значение из `myData` в другую переменную, то мы скопируем ссылку, а не само значение.

```js
const yourData = myData
```

![Схематичное изображение переменных myData и yourData со ссылкой на общий участок памяти](images/5.png)

В такие типы данных входят **объекты**, **массивы** и **функции**. На самом деле и массивы и функции также являются объектами, но это другая история.

Можно ли в таком случае рассчитывать, что значения будут равными? Конечно, можно! В этом случае сравниваться будут ссылки на объект, а не их содержимое. Потому, если обе переменных указываются на одно и то же, смело можно сказать, что значения равны.

```js
const data = {}
const anotherData = data

console.log(data === anotherData)
// true
```

Сравнение по значению не будет выполняться, даже если создаются объекты с абсолютно одинаковыми данными.

```js
const cat = { name: 'Феликс' }
const dog = { name: 'Феликс' }

// Странно ожидать равность кошки и собаки ¯\_(ツ)_/¯ но теперь мы знаем причину
console.log(cat === dog)
// false
```

Факт того, что различные переменные ссылаются на один и тот же объект означает и некоторые другие особенности. Если какой-то из владельцев ссылки изменит объект, то изменения отразятся на всех.

```js
yourData.name = 'Саша'
console.log(myData)
// { name: 'Саша' }

myData.name = 'Михаил'
console.log(yourData)
// { name: 'Михаил' }
```

Эта особенность часто становится причиной ошибок при работе с объектами, так как можно легко забыть или даже не знать, что же ещё ссылается на тот же объект.

Если переменная потеряет ссылку на объект, то изменения уже не будут на него влиять:

```js
let user = { name: 'Анна', age: 21 }
const admin = user

// Переопределение не повлияет на admin, потому что создаётся новый объект
user = { name: 'Иван' }

console.log(admin) // { name: 'Анна', age: 21 }

admin.isAdmin = true

console.log(user) // { name: 'Иван' }
console.log(admin) // { name: 'Анна', age: 21, isAdmin: true }
```

### Мутации и неизменяемость

Изменение значений у полей объекта, добавление или удаление их отразится на всех, кто владеет ссылкой на этот объект. Изменение значения переменной называется **мутацией**.

В современной веб-разработке мутаций стараются избегать, потому что мутирование объектов может приводить к ошибкам, которые трудно отследить. Однако если мы уверены, что объект чётко контролируется, то проще напрямую изменить объект

Если нужно безопасно модифицировать объект, то вначале нужно его скопировать. Скопировать объект можно тремя способами:

- через `Object.assign()`;
- используя [спред-синтаксис `...`](/js/spread/);
- в современных браузерах можно использовать [функцию `structuredClone()`](https://developer.mozilla.org/en-US/docs/Web/API/structuredClone).

```js
const admin = {
  name: 'Анна',
  age: 21,
  isAdmin: true,
}

// Чтобы скопировать через Object.assign() нужно передать пустой объект
const adminCopy = Object.assign({}, admin)

const anotherCopy = {
  ...admin,
}
```

Таким образом создается новая сущность, которая содержит такие же значения. Любые изменения в новом объекте уже не затронут предыдущий объект.

```js
anotherCopy.age = 30
anotherCopy.isAdmin = false

console.log(anotherCopy)
// {name: 'Анна', age: 30, isAdmin: false }

console.log(admin)
// {name: 'Анна', age: 25, isAdmin: true }
```

Важная оговорка о вложенных объектах: при копировании объекта указанным способом копируются только поля первого уровня вложенности ([поверхностное копирование](/js/shallow-or-deep-clone/)). Все объекты со второго уровня вложенности и ниже **копируются по ссылке**. Их изменение затронет и первоисточник:

```js
const original = {
  b: {
    c: 1,
  },
}

const copy = { ...original }
copy.b.c = 2

// Тоже изменился!
console.log(original)
// { b: { c: 2 }}
```

Изменения можно так же внести при копировании.

```js
const cat = {
  name: 'Феликс',
  color: 'чёрный',
  isHomeless: false,
}

const catInBoots = {
  ...cat,
  name: 'Пушок',
  hasBoots: true,
}

console.log(catInBoots)
// {name: 'Пушок', color: 'чёрный', isHomeless: false, hasBoots: true }

const redCat = Object.assign(cat, { color: 'рыжий', name: 'Борис' })

console.log(redCat)
// {name: 'Борис', color: 'рыжий', isHomeless: false }
```

Принцип, при котором для внесений изменений создается новый объект, независимый от исходного, называется **иммутабельностью (immutability)** или **неизменяемостью**.

С копированием массивов по ссылке ситуация такая же — если изменить содержимое, то изменения отразятся на всех владельцев ссылки. Для немутируемого копирования массивов, кроме оператора троеточия, можно использовать методы массива `slice()`, [`map()`](/js/array-map/) и [`filter()`](/js/array-filter/).

Другие методы (например `sort()`, `splice()`) мутируют исходный массив, потому использовать их стоит с осторожностью. Узнать какие методы мутируют массив можно на [сайте Does It Mutate](https://doesitmutate.xyz/).

Минус иммутабельности — большее использование памяти. Однако в современной разработке это часто не проблема, учитывая те плюсы, которые мы получаем.

#### Аргументы функций

При передаче аргументов в функцию все свойства передачи сохраняются:

- При передаче примитивного типа данных, его значение копируется в аргумент.
- При использовании объектного типа данных копируется ссылка на объект. Все изменения в объекте, который был передан в качестве аргумента, доступны всем, кто владеет ссылкой:

```js
const member = { id: '123', name: 'Иван' }

function makeAdmin(user) {
  user.isAdmin = true

  return user
}

const admin = makeAdmin(member)

console.log(admin)
// { id: '123', name: 'Иван', isAdmin: true }
console.log(member)
// { id: '123', name: 'Иван', isAdmin: true }

// Это один и тот же объект
console.log(admin === member)
// true
```

## Заключение

Итак, что мы узнали?

- **Примитивные** типы данных (числа, булевы и строки) передаются и сравниваются по значению. Можно безопасно менять значение переменной, не опасаясь, что изменится другая переменная.
- **Объектные** типы данных (объекты, массивы, функции) передаются и сравниваются по ссылке. При этом при сравнении будет учитываться именно факт того, что две переменные ссылаются на один и тот же объект. Даже если два объекта содержат идентичные значения это ни на что не повлияет.
- Изменения внутри объекта доступны всем у кого есть ссылка на этот объект. Прямое изменение данных объекта называется **мутирование**. Лучше стараться избегать мутации объекта, так как это может приводить к неочевидным ошибкам.
- Чтобы безопасно изменить объект его необходимо скопировать специальным образом. Таким образом будет создана другая ссылка и любые изменения не затронут старый объект.
