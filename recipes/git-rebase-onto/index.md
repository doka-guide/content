---
title: "Как ребейзить ветку и не думать ни о чём"
description: "Чтобы легко управлять вашими изменениями и историей git, используйте git rebase --onto."
authors:
  - hellsquirrel
keywords:
  - git
tags:
  - article
---

## Управление историей git

Представим что у вас есть git-репозиторий с несколькими ветками. Вы работаете в одной из них и хотите перенести свои изменения в другую ветку.
Такое приходится делать очень часто, если вы хотите актуализировать свои изменения.

Рассмотрим несколько распростанëнных сценариев.

Вы начали разрабатывать фичу и создали ветку из основной `main`, за время разработки в ветку `main` приехали изменения ваших коллег. Как переместить ваши изменения на актуальный `main`?

![Схема веток Гит, где одна ветка отстаёт от главной](images/lag.png)

В вашей команде есть фронтенд и бекенд разработчики. Вы работаете в одном репозитории. Вы создали frontend-ветку из основной ветки, ваши коллега создал backend-ветку из основной. Теперь вы хотите потестировать ваш фронтенд с новым бекендом. Как это сделать?

![Схема двух веток Гит, бэкенд и фронтенд](images/to-rebase.png)

В вашей ветке есть _несколько_ коммитов, которые нужны вашему коллеге, но кроме этого в вашей ветке есть коммиты которые сломают ветку вашего коллеги, как потестировать только не ломающие изменения?

![Схема двух веток Гит, где одна содержит коммит, ломающий код из другой ветки](images/break.png)

Все эти задачи решаются с помощью команды `git rebase --onto`.

## Немного теории

Git хранит коммиты (commits). Коммит - это просто ссылка на какое-то состояние вашего репозитория которое вы сохранили: немножко метаданных и ссылка на _предудыщий_ коммит. Сам по себе коммит это 40 символов SHA-1 хеша этого состояния.

Ветка (branch) это ссылка на определенный коммит. У вас может быть только одна активная ветка. На нее (т. е. на опредленный коммит) указывает специальный указатель `HEAD`.

Многие команды гит принимают в качестве параметре ревизию. Так как все в гите это захешированные объекты, то в качестве ревизии мы можете передавать.

- Длинный хеш, например вот так `29aeb39eac6b8d9e0f4cdc1459376599d1aba43c`.
- Короткий хеш, например вот так `29aeb39e`.
- Тег, если он имеется, например вот так `v1.0.0`.
- Имя ссылки. В отсновном используется для веток. Например `main`, `origin/dev`, `refs/heads/foo`.

Вы можете добавлять магические символы (`@{n}, ^, :`) к этим параметрам, чтобы еще эффективнее выбирать нужные коммиты. Подробности можно посмотреть [вот тут](https://git-scm.com/docs/gitrevisions). Особенно полезен символ `^` который позволяет вам выбирать предыдущие коммиты.

## Как готовить

Подробности можно найти например, [здесь](https://git-scm.com/docs/git-rebase).

Команда `git rebase` с флагом `--onto` принимает несколько аргументов:

- `--onto` — коммит на который нужно перенести изменения. Новые коммиты добавятся сразу после него.
- `from` — коммит с которого нужно перенести изменения Коммит который вы укажете не перенесется, а следующие за ним перенесутся.
- `to` — коммит до которого нужно перенести изменения. Коммит который вы укажете перенесется.

Последний аргумент можно не использовать, тогда перенесутся все коммиты начиная от следующего за `from` коммита до конца ветки.

Например:

```bash
git rebase --onto main feature1
```

Помните что коммит это всего лишь хеш? В качестве каждого аргумента вы можете указывать хеш, например вот так:

```bash
git rebase --onto 29aeb39e 5fd88295
```

Хеши вообще-то длиннее 8 символов, но git понимает короткую версию. Вы можете также указать полный хеш, например вот так:

```bash
git rebase --onto 29aeb39eac6b8d9e0f4cdc1459376599d1aba43c 5fd882953924b47a10794619c3063e7a50257af6
```

Вы можете указать название ветки вместо хеша, например вот так:

```bash
git rebase --onto main feature
```

Если вы хотите перенести несколько коммитов из основной ветки, вы можете использовать магию `HEAD` нотации.

```bash
git rebase --onto main HEAD^3 HEAD^
```

Эта команда перенесет 2 коммита из текущей ветки в ветку `main`. Самый последний не перенесет.

Рассмотрим один из примеро выше.

Было так:

![Схема двух веток Гит, бэкенд и фронтенд](images/to-rebase.png)

Нужно вот так:

![Схема Гит, где коммиты из одной ветки перенесены в другую](images/rebased.png)

Для этого нужно выполнить команду:

```bash
git rebase --onto backend main frontend
```

- `git rebase --onto` — переносим.
- backend — на последний коммит ветки backend, т. е. на API2.
- main — все коммиты в моей ветке frontend, начиная с того которым заканчивается ветка main (Статья3).
- frontend — заканчивая последним коммитом ветки frontend (Тултипчик2).

## Бонус

Если вы хотите посмотреть какой красивой стала ваша история, используйте команду

```bash
git log --oneline --decorate --graph --all
```
