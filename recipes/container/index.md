---
title: "Как создать колонку с контентом по центру экрана"
authors:
  - gartonot
tags:
  - article
---


## Задача

Перед вами встала задача центрировать контент на всей странице
Предположим, это нужно сделать почти у каждой секции, но какие-то секции должны быть растянуты на весь экран.
В этом рецепте разберём как и какими способами мы можем это сделать.


## Немного терминов

`container` - специальный рукописный класс, который сжимает (ограничивает по ширине) и центрирует контент на странице.

Имя для такого класса может меняться в зависимости от договорённостей внутри конкретной команды, или от привычек верстальщика.

## Пример

В вёрстке мы можем использовать класс в нужном нам месте следующим образом:

```html
  <div class="container">
    <!-- Контент -->
  </div>
```

Опишем стили для класса `container`:

```css
  .container {
    max-width: 1024px;
    margin-inline: auto;
  }
```

Значение для [`max-width`](/css/width/) может быть любым, всё зависит от дизайна и от того, насколько нужно ограничить ширину контента.

В примере значение `1024px` служит для ограничения контента, больше чем `1024px` контент не будет растягиваться и выходить за эти рамки, а свойство [`margin`](/css/margin/) сделает контент по центру.

## Готовое решение

Учитывая, что сайты делаем адаптивными и мы применяем для этого [@media](/css/media/) директиву, то и контейнер тоже нужно будет адаптировать.

```css
  .container {
    max-width: 1024px;
    margin-inline: auto;
  }

  @media screen and (max-width: 1024px) {
    .container {
      padding-inline: 128px;
    }
  }

  @media screen and (max-width: 768px) {
    .container {
      padding-inline: 64px;
    }
  }

  @media screen and (max-width: 425px) {
    .container {
      padding-inline: 24px;
    }
  }
```

Пример вёрстки:

```html
  <section class="section-one">
    <div class="container">
    <!-- Контент -->
    </div>
  </section>
  <section class="section-two">
    <div class="container">
    <!-- Контент -->
    </div>
  </section>
```

## Разбор решения

При таком подходе, используя [padding](/css/padding/) на каждой точке перехода, контент внутри `container` не будет прижат к краям страницы, а будет иметь отступ слева и справа.

<iframe title="Адаптивный контейнер" src="demos/container-media/" height="370"></iframe>

При изменении ширины фрейма срабатывает медиавыражение, которое добавляет отступы слева и справа


## Готовое решение №2

Так же, мы можем не писать несколько медиа запросов для каждого экрана, а воспользоваться функцией `clamp()` прямо из наших стилей и рассчитать нужную нам ширину для `container`

В этом примере мы сделаем вёрстку таким образом, что у нас какие-то секции будут иметь контейнер и контент будет сжат по размещён по центру, а в какой-то секции не будет указан `container` и контент будет растянут на всю ширину экрана

```html
  <section class="section-one">
    <div class="container">
      Lorem ipsum dolor sit amet consectetur adipisicing elit.
    </div>
  </section>
  <section class="section-two">
    Lorem ipsum dolor sit, amet consectetur
  </section>
  <section class="section-third">
    <div class="container">
      Lorem ipsum dolor sit amet consectetur adipisicing elit.
    </div>
  </section>
```

А в стилях мы укажем ту самую волшебную функцию `clamp()`

```css
  .container {
    width: clamp(360px, 90%, 1024px);
    margin-inline: auto;
  }
```

## Разбор решения №2

Мы можем заметить насколько сильно у нас сократился код, стал выглядеть приятнее, а что самое главное работает так, как нам и нужно.
Но что же происходит и как именно эта функция у нас рассчитывает `width``:
- Первое параметр `360px` - говорит нам о минимальном значении
- Последний параметр `1024px` - говорит нам о максимальном значении
- А вот `90%` - этот параметр будет применён между минимальным и максимальным значением

Тем самым мы добились того, что теперь наш `container` не только сам подстраивается под ширину, но и мы можем этими значениями управлять, в зависимости от наших задач.

<iframe title="Адаптивный контейнер вместе с clamp()" src="demos/container-clamp/" height="450"></iframe>


## И напоследок

Использование такого класса не говорит о том, что нам нужно ограничиваться только тем, чтоб указывать его в самых верхних слоях.
Мы можем вкладывать подобное поведение друг в друга, где каждая подобная обёртка будет уникальна и решать собственные задачи

Представим наш "макет" в виде блога, где весь контент расположен в `container`, а вот основное содержимое блога будет ещё меньше основного контента под классом `wrapper`:

```html
  <section class="section">
    <div class="container">
      <h1>Заголовок для блога</h1>
      <div class="wrapper">
        <!-- Blog content -->
      </div>
    </div>
  </section>
```

Так же не забудем стилизовать любым удобным нам способом или через [`max-width`](/css/width/) или используя функцию `clamp()`

```css
  .container {
    width: clamp(360px, 90%, 1024px);
    margin-inline: auto;
  }
  .wrapper {
    width: clamp(280px, 90%, 768px);
    margin-inline: auto;
  }
```

<iframe title="Адаптивный container c дополнительным содержимым" src="demos/container-wrapper/" height="370"></iframe>

## Зачем нужно

Чаще всего контент расположенный по центру, имеет некие отступы слева и справа и чтоб реализовать удобный и универсальный способ центрирования контента, создаётся класс, который описывает как должен вести себя контент и насколько он должен быть ограничен, чтоб не писать несколько раз, для каждой секции свои отступы
