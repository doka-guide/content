Ниже я говорю только о разнице их поведения при работе с массивами, т.к. они не привязаны только к этим структурам данных.

Разница между `forEach()` и `map()` заключается в их поведении.

Оба метода массива принимают колбэк, который вызывается для каждого элемента массива. Разница заключается в том, что `forEach()` ничего не возвращает, а `map()` возвращает новый массив с результатами вызова колбэка на каждом исходном элементе или [`undefined`](/js/undefined/) если переданный колбэк ничего не возвращает.

Стоит поговорить о `forEach()` ещё немного:

```js
[1,2,3].forEach(a => a + 3);
```

Код, как в примере выше не упадет с ошибкой. Он абсолютно валиден, но при этом не выдаст того же результата, что и `map()`

Благодаря такой разнице в поведении, после выполнения `map()` мы можем продолжить цепочку вызова методов массива, чего не получится сделать с помощью `forEach()`.

```js
const myArray = [4, 2, 8, 7, 3, 1, 0];
const myArray2 = myArray.map(item => item * 2).sort((a, b) => a - b);

console.log(myArray); // [4, 2, 8, 7, 3, 1, 0]
console.log(myArray2); // [0, 2, 4, 6, 8, 14, 16]
```

Как мы видим из примера, исходный массив остался не тронутым, а `myArray2` преобразился. Использовать такую цепочку вызова методов на `forEach()` не получится.

Для закрепления, напишу пример на `forEach()` для получения такого же результата, как в примере выше.

```js
const myArray = [4, 2, 8, 7, 3, 1, 0];
let myArray2 = [];

myArray.forEach(item => {
  myArray2.push(item * 2);
});

myArray2 = myArray2.sort((a, b) => a - b);

console.log(myArray); // [4, 2, 8, 7, 3, 1, 0]
console.log(myArray2); // [0, 2, 4, 6, 8, 14, 16]
```
