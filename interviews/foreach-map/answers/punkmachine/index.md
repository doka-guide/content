Разница между `forEach()` и `map()` заключается в их изначальном поведении.

Переданный в `map()` колбэк вызывается для каждого элемента массива. В переданном колбэк обязательно должно возвращаться новое значение элемента массива, на котором вызывается `map()`, если это значение не будет возвращено явно, то будет возвращено [`undefined`](/js/undefined/). Благодаря такому поведению, в результате выполнения `map()` мы получим совершенно новый массив.

`forEach()` же является просто альтернативой синтаксиса стандартного цикла `for`. Переданный в него колбэк не должен ничего возвращать.

Благодаря такой разницы в поведении, на массиве, после вызова `map()` мы можем вызывать и другие методы массива, которые не можем вызвать после `forEach()`. Пример:

```js
const myArray = [4, 2, 8, 7, 3, 1, 0];
const myArray2 = myArray.map(item => item*2).sort((a, b) => a - b);

console.log(myArray); // [4, 2, 8, 7, 3, 1, 0]
console.log(myArray2); // [0, 2, 4, 6, 8, 14, 16]
```

Как мы видим из примера, исходный массив остался не тронутым, а `myArray2` преобразился: каждый его элемент был умножен на два, а после завершения преобразования массива он был ещё и отсортирован. Использовать такую цепочку вызова методов на `forEach()` не получится.

Для закрепления, напишу пример на `forEach()` для получения такого же результата, как в примере выше.

```js
const myArray = [4, 2, 8, 7, 3, 1, 0];
let myArray2 = [];

myArray.forEach(item => {
  myArray2.push(item*2);
});

myArray2 = myArray2.sort((a, b) => a - b);

console.log(myArray); // [4, 2, 8, 7, 3, 1, 0]
console.log(myArray2); // [0, 2, 4, 6, 8, 14, 16]
```