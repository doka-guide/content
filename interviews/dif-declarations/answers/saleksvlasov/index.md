В первом случае просто была вызвана функция, которая ничего не возвращает. Значение переменной будет равно `undefined`
```js
const animal = Animal() // ❌
console.log(animal) // undefined
```

Во втором случае перед функцией `Animal` стоит оператор `new`. Функция `Animal` становится конструктором. Она выполняется, но так как `this` внутри функции не используется, и сама функция ничего не возвращает, то ничего не происходит. Результатом операции становится новый объект, который ссылается на функцию `Animal` как на конструктор. Этот объект присваивается переменной `animal`

```js
const animal = new Animal() // ✅
```

Если `Animal` имеет вид:
```js
function Animal() {
  this.name = 'Cat'
}
```
То переменная `animal`, созданная с помощью `new`, будет иметь доступ к полю `name`:
```js
console.log(animal)
// Animal { name: 'Cat' }
// Если мы явно не возвращаем ничего из конструктора,
// то получаем сам объект в качестве результата.
```

#### Рассмотрим возврат значения из конструктора

Обычно в функции-конструкторе не используется оператор `return`. Если `return` используется срабатывают два правила:
1. При вызове `return` с объектом, вместо `this` вернётся этот объект.
2. При вызове `return` с пустым или с примитивным значением, оно будет проигнорировано.

`return` с объектом возвращает этот объект, во всех остальных случаях возвращается `this`
```js
function Animal() {
  this.foo = 'BARBARBAR'
  return {
    foo: 'bar' // ⬅️ возвращает этот объект
  }
}

const animal = new Animal()
console.log(animal.foo)
// Вернет `bar`
```
А вот пример с примитивом после `return`:
```js
function Animal() {
  this.foo = 'BARBARBAR'
  return 'bar' // ⬅️ возвращает this
}

const animal = new Animal()
console.log(animal.foo)
// Вернет BARBARBAR
```
