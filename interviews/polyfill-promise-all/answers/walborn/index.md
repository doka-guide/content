---
excluded:
  - js/promise
---
### Для начала вспомним работу оригинального `Promise.all`

Он принимает на вход массив промисов и начинает выполнять их одновременно, все сразу. Ждёт, пока все промисы не выполнятся, и только тогда возвращает массив результатов. Но если какой-то промис вылетел с ошибкой, то работа `Promise.all` прекращается и возвращается лишь эта ошибка.

Таким образом у нас есть два сценария:

- Позитивный: Когда все промисы завершились успешно. Тут в ответ придёт массив результатов
- Негативный: Когда хотя бы какой-то промис завершился с ошибкой. Тут `Promise.all` не будет ждать завершение оставшихся, а сразу перейдёт в состояние `rejected` с полученной ошибкой.

### Подсказки (Постарайтесь решить самостоятельно)
1. Нам понадобится массив `results`, где будем хранить результаты успешно завершённых промисов.
2. Мы должны как-то понять, что все промисы выполнились, чтобы разрешить промис с полученными результатами. Я предлагаю использовать переменную `left`, где будем хранить количество ещё не выполненных промисов. 
3. Наша функция должна возвращать промис, внутри которого мы проходимся по всем промисам. И если  - какой-то промис завершился успешно - добавляем его в `results`, причём под тем же индексом, который был изначально в массиве промисов. Не забываем уменьшить количество оставшихся промисов на `1`
- промис завершился с ошибкой: просто реджектим промис с этой ошибкой

### Решение (Код)
```jsx
// На вход к нам приходит массив промисов
const promiseAll = (promises) => {
  // Здесь будем хранить результаты успешно завершенных промисов
  const results = []
  
  // Количество промисов, которые осталось выполнить
  // На данный момент не выполнился еще ни один промис!
  let left = promises.length 

  // Возвращаем, естественно, новый промис
  return new Promise((resolve, reject) => {
    // Проходимся по списочку
    promises.forEach((promise, index) => {
      promise
        // Если промис завершается успешно
        .then((result) => {

          // Кладём его в наше хранилище
          // Причём сохраняем индекс, под которым он был в массиве `promises`
          results[index] = result
          
          // На один невыполненный промис стало меньше!
          left -= 1

          // Если активных промисов больше нет, то резолвим результат
          if (left === 0) resolve(results)
        })
        // Если промис упал с ошибкой, то реджектим ошибку
        .catch((err) => {
          reject(err)
        })
    })
  })
}
```

### Теперь протестируем наш полифил

```jsx
// Сделаем искусственную задержку
const delay = (timeout) => new Promise((resolve) => setTimeout(resolve, timeout))

// И создадим несколько промисов для тестирования
const fetchUsers = () => delay(1000).then(() => [ 'Маша', 'Петя', 'Оля' ])
const problemPromise = delay(2000).then(() => { throw 'Houston, we have a problem' })
const stringPromise = delay(5000).then(() => 'Lorem ipsum dolor sit amet')

// Прогоним позитивный случай
promiseAll([ fetchUsers(), stringPromise ])
  .then(console.log)
// [ [ 'Маша', 'Петя', 'Оля' ], 'Lorem ipsum dolor sit amet' ]

// Прогоним негативный случай, когда возникает ошибка
promiseAll([ fetchUsers(), problemPromise, stringPromise ])
  .then(console.log)
// Uncaught (in promise) Houston, we have a problem
```
