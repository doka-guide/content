### Теория

Для начала вспомним работу оригинального `Promise.any`.

Метод `Promise.any` принимает коллекцию промисов и возвращает промис, который выполняется с результатом самого первого
успешно выполненного промиса. Если все промисы завершаются с ошибкой, возвращается отклонённый промис с ошибкой
`AggregateError`, содержащей массив всех ошибок.

```text
AggregateError — это встроенный объект ошибки в JavaScript, который используется для объединения нескольких ошибок. Он применяется в методе Promise.any() и содержит свойство errors, представляющее массив всех ошибок.
```

### Подсказки

Сначала попробуйте решить самостоятельно. Если не получается, вот подсказки:

1. Считаем количество отклонённых промисов, чтобы понять, если все они завершились ошибкой.
2. Как только найдём первый успешно выполненный промис, возвращаем его результат.
3. Если всё-таки все промисы отклонились, создаём `AggregateError` с массивом ошибок и возвращаем его.

## Решение

Напишем реализацию метода `Promise.any`:

```js
Promise.any = (promises) => {
  // Проверяем, что переданный аргумент — массив
  if (!Array.isArray(promises)) {
    return Promise.reject(new TypeError("Аргумент должен быть массивом"));
  }

  // Если массив пустой, сразу возвращаем отклонённый промис
  if (promises.length === 0) {
    return Promise.reject(new AggregateError([], "Все промисы были отклонены"));
  }

  return new Promise((resolve, reject) => {
    const errors = [];

    promises.forEach((promise, index) => {
      // Оборачиваем каждый элемент массива в `Promise.resolve`, чтобы корректно обрабатывать непромисы
      Promise
        .resolve(promise)
        .then(resolve) // Резолвим с первым успешным значением
        .catch((error) => {
          errors[index] = error; // Сохраняем ошибку

          // Если все промисы отклонены, формируем AggregateError
          if (errors.length === promises.length) {
            reject(new AggregateError(errors, "Все промисы были отклонены"));
          }
        });
    });
  });
};
```

### Как это работает

1. Проверяем, что входные данные — это массив. Если массив пустой, сразу возвращаем `AggregateError`.
2. Создаём массив для хранения ошибок `errors` и счётчик отклонённых промисов `rejectedCount`.
3. Для каждого промиса:
  - Если он выполняется успешно, вызываем `resolve` с его результатом.
  - Если он отклоняется, сохраняем ошибку в `errors` и увеличиваем счётчик `rejectedCount`.
4. Если все промисы отклонены, вызываем `reject` с `AggregateError`, содержащим массив всех ошибок.

## Тесты

### Вспомогательная функция

Для тестов используем искусственную задержку:

```js
const delay = (timeout, result, shouldReject = false) =>
  new Promise((resolve, reject) =>
    setTimeout(() => (shouldReject ? reject(result) : resolve(result)), timeout)
  );
```

### Пример 1: Первый успешный промис

Представьте, что у нас есть три промиса с разным временем выполнения. Один из них завершится с ошибкой:

```js
const p1 = delay(1000, "Первый успешный");
const p2 = delay(500, "Второй успешный");
const p3 = delay(1500, "Третий успешный", true);

Promise.any([p1, p2, p3])
  .then(console.log) // Ожидаемый результат: "Второй успешный"
  .catch(console.error);
```

### Пример 2: Все промисы отклонены

Теперь представим, что все промисы завершаются с ошибками:

```js
const allRejected = [
  delay(500, "Ошибка 1", true),
  delay(1000, "Ошибка 2", true),
  delay(1500, "Ошибка 3", true),
];

Promise.any(allRejected)
  .then(console.log)
  .catch((error) => {
    console.error(error); // AggregateError: Все промисы были отклонены
    console.error(error.errors); // ["Ошибка 1", "Ошибка 2", "Ошибка 3"]
  });
```
