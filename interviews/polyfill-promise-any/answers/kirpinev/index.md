### Теория

Для начала вспомним работу оригинального `Promise.any`.

Метод `Promise.any` принимает коллекцию промисов и возвращает новый промис, который выполняется с результатом самого первого успешно выполненного промиса. Если все промисы завершаются с ошибкой, возвращаемый промис завершается с ошибкой `AggregateError`, содержащей массив всех ошибок.

```text
AggregateError — это встроенный объект ошибки в JavaScript, который используется для объединения нескольких ошибок. Он применяется в методе Promise.any() и содержит свойство errors, представляющее массив всех ошибок.
```

### Подсказки

Сначала попробуйте решить самостоятельно. Если не получается, вот подсказки:

1. Считаем количество отклонённых промисов, чтобы понять, если все они завершились ошибкой.
2. Как только найдём первый успешно выполненный промис, возвращаем его результат.
3. Если всё-таки все промисы отклонились, создаём `AggregateError` с массивом ошибок и возвращаем его.

## Решение

Напишем реализацию метода `Promise.any`:

```js
Promise.any = (iterable) => {
  // Проверяем, что переданный аргумент итерируемый.
  if (typeof iterable?.[Symbol.iterator] !== "function") {
    return Promise.reject(new TypeError("Аргумент должен быть итерируемым"));
  }

  // Приводим итерируемый объект к массиву.
  const promises = [...iterable];

  // Если массив пустой, сразу возвращаем отклонённый промис
  if (promises.length === 0) {
    return Promise.reject(new AggregateError([], "Все промисы были отклонены"));
  }

  return new Promise((resolve, reject) => {
    const errors = [];
    let rejectedCount = 0;

    promises.forEach((promise, index) => {
      // Оборачиваем каждый элемент массива в Promise.resolve, чтобы корректно обрабатывать непромисы
      Promise
        .resolve(promise)
        .then(resolve) // Резолвим с первым успешным значением
        .catch((error) => {
          errors[index] = error; // Сохраняем ошибку
          rejectedCount += 1;

          // Если все промисы отклонены, формируем AggregateError
          if (rejectedCount === promises.length) {
            reject(new AggregateError(errors, "Все промисы были отклонены"));
          }
        });
    });
  });
};
```

### Как это работает

1. Проверяем, что входные данные являются итерируемыми. Если аргумент не соответствует требованию, возвращаем `TypeError`.
2. Преобразуем итерируемый объект в массив. Если он пустой, сразу возвращаем отклонённый промис с `AggregateError`.
3. Создаём массив для хранения ошибок `errors` и счётчик отклонённых промисов `rejectedCount`.
4. Для каждого промиса:
  - Если он выполняется успешно, вызываем `resolve` с его результатом.
  - Если он отклоняется, сохраняем ошибку в `errors` и увеличиваем счётчик `rejectedCount`.
5. Если все промисы отклонены, вызываем `reject` с `AggregateError`, содержащим массив всех ошибок.

## Тесты

### Вспомогательная функция

Для тестов используем искусственную задержку:

```js
const delay = (timeout, result, shouldReject = false) =>
  new Promise((resolve, reject) =>
    setTimeout(() => (shouldReject ? reject(result) : resolve(result)), timeout)
  );
```

### Пример 1: Первый успешный промис

Представьте, что у нас есть три промиса с разным временем выполнения. Один из них завершится с ошибкой:

```js
const promise1 = delay(1000, "Первый успешный");
const promise2 = delay(500, "Второй успешный");
const promise3 = delay(1500, "Третий с ошибкой", true);

Promise.any([promise1, promise2, promise3])
  .then(console.log) // Ожидаемый результат: "Второй успешный"
  .catch(console.error);
```

### Пример 2: Все промисы отклонены

Теперь представим, что все промисы завершаются с ошибками:

```js
const allRejected = [
  delay(500, "Ошибка 1", true),
  delay(1000, "Ошибка 2", true),
  delay(1500, "Ошибка 3", true)
];

Promise.any(allRejected)
  .then(console.log)
  .catch((error) => {
    console.error(error); // AggregateError: Все промисы были отклонены
    console.error(error.errors); // ["Ошибка 1", "Ошибка 2", "Ошибка 3"]
  });
```

### Пример 3: Число как аргумент

Проверим поведение полифила с числом как аргументом:

```js
Promise.any(123)
  .then(console.log)
  .catch((error) => console.error(error)); // TypeError: "Аргумент должен быть итерируемым"
```

### Пример 4: Строка как аргумент

И наконец проверим как `Promise.any()` поведёт себя со строкой:

```js
Promise.any("Тест")
  .then(console.log) // Ожидаемый результат: "Т"
  .catch(console.error);
```
