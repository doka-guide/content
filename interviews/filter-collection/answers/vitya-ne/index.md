Основной сложностью данной задачи является определение уникальности элементов коллекции.

Попробуем для начала упростить задачу. Допустим, элементами коллекции являются примитивные значения, а сама коллекция - это массив. В этом случае наше решение может быть таким:

```js
function getUnique (array) {
  // Если это не массив, возвращаем пустой массив
  if (Array.isArray(array) === false) {
    return []
  }

  const uniqueArray = []

  array.forEach(item => {
    if (uniqueArray.includes(item)) {
      return
    }
    uniqueArray.push(item)
  })

  return uniqueArray
}
```

Сначала проверяем, что аргументом функции является массив, а затем перебираем коллекцию и накапливаем в новом массиве `uniqueArray` только уникальные элементы. Для проверки уникальности используем метод массивов `.includes()`.

Проверим работу нашей функции:

```js
const result = getUnique([1,2,2,1,3,0,2])
console.log(result)
// [ 1, 2, 3, 0 ]
```

Функция работает как ожидалось, но такое решение не самое оптимальное. Если оценить сложность алгоритма, то окажется что она равна O(n^2). Для каждого элемента исходного массива необходимо осуществлять поиск в создаваемом массиве уникальных элементов.

JavaScript имеет специальный тип для создания уникальных коллекций — [Set](/js/set/). С его помощью решение будет намного проще:

```js
function getUnique (array) {
  // Если это не массив, возвращаем пустой массив
  if (Array.isArray(array) === false) {
      return []
  }

  return [ ...new Set(array) ]
}
```

Это решение не требует перебора коллекции, так как при создании объекта `Set` в него попадут только уникальные элементы переданого массива. Затем, используя дестрктуризацию, мы преобразуем `Set` обратно в массив.
По сравнению с предыдущим вариантом, это улучшит производительность, так как поиск в коллекции Set выполняется быстрее чем при использовании `.includes()`.

А как быть с объектами в качестве элементов коллекции? С точки зрения JavaScript следующие элементы являются уникальными:

```js
console.log(new Set([{},{},{},{}]))
// Set(4) { {}, {}, {}, {} }
```

Если определяете «равенство» объектов, можно воспользоваться [библиотекой Lodash](https://lodash.com). В библиотеку входит метод `.isEqual()`, позволяющий сравнивать объекты:

```js
function getUnique (array) {
  // Если это не массив, возвращаем пустой массив
  if (Array.isArray(array) === false) {
    return []
  }

  const uniqueArray = []

  array.forEach(item => {
    if (uniqueArray.some(uniqueItem => _.isEqual(item, uniqueItem))) {
      return
    }
    uniqueArray.push(item)
  })

  return uniqueArray
}
```

Теперь перебираем элементы коллекции и накапливаем уникальные элементы в новом массиве `uniqueArray`, используя для поиска повторений метод массивов `.some()` и метод библиотеки Lodash `.isEqual()`. Сложность этого алгоритма равна O(n^2), так как требуется внутренний цикл для тестирования уникальности каждого элемента.

Можно улучшить гибкость нашего решения:
- адаптировать для использования не только массивов, но и других коллекций;
- устранить зависимость от библиотеки Lodash и дать возможность использовать собственную функцию для проверки уникальности элемента.

Для этого проверим что аргументом функции является итерируемый объект, а обход будем осуществлять с использованием [for..of](/js/for-of/). Кроме этого, добавим возможность передавать в качестве второго аргумента функцию сравнения. Если функция не передана, используем для сравнения метод `Object.is()`:

```js
function getUnique (collection, comparator) {
  // Если это не итерируемая коллекция, возвращаем пустой массив
  if (collection === null || typeof collection[Symbol.iterator] !== 'function') {
    return []
  }

  // Если функция сравнения не передана, используем метод Object.is
  const isEqual = typeof comparator === 'function'
    ? comparator : (a, b) => Object.is(a, b)

  const uniqueArray = []

  for (const item of collection) {
    if (uniqueArray.some(uniqueItem => isEqual(item, uniqueItem))) {
      // Элемент уже есть, переходим к следующему элементу
      continue
    }
    uniqueArray.push(item)
  }

  return uniqueArray
}
```
