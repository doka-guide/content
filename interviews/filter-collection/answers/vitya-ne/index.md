Основной сложностью данной задачи является определение уникальности элементов коллекции.

Попробуем для начала упростить задачу. Допустим, элементами коллекции являются примитивные значения, а сама коллекция - это массив. В этом случае наше решение может быть таким:

```js
function getUnique (array) {
  // Если это не массив, возвращаем пустой массив
  if (Array.isArray(array) === false) {
    return []
  }

  const uniqueArray = []

  array.forEach(item => {
    if (uniqueArray.includes(item)) {
      return
    }
    uniqueArray.push(item)
  })

  return uniqueArray
}
```

Сначала проверяем, что аргументом функции является массив, а затем перебираем коллекцию и накапливаем в новом массиве `uniqueArray` только уникальные элементы. Для проверки уникальности используем метод массивов `.includes()`.

Проверим работу нашей функции:

```js
const result = getUnique([1,2,2,1,3,0,2])
console.log(result)
// [ 1, 2, 3, 0 ]
```

Функция работает как ожидалось, но такое решение не самое оптимальное. Если оценить сложность алгоритма, то окажется что она равна O(n^2). Для каждого элемента исходного массива необходимо осуществлять поиск в создаваемом массиве уникальных элементов.

JavaScript имеет специальный тип для создания уникальных коллекций — [Set](/js/set/). С его помощью решение будет намного проще:

```js
function getUnique (array) {
  // Если это не массив, возвращаем пустой массив
  if (Array.isArray(array) === false) {
      return []
  }

  return [ ...new Set(array) ]
}
```

Это решение не требует перебора коллекции вручную (это произойдёт "под капотом"), так как при создании объекта `Set` в него попадут только уникальные элементы переданого массива. Затем, используя деструктуризацию, мы преобразуем `Set` обратно в массив.
По сравнению с предыдущим вариантом, это улучшает производительность, так как поиск в коллекции Set гарантировано выполняется быстрее чем при использовании `.includes()`.

А как быть с объектами в качестве элементов коллекции? С точки зрения JavaScript следующие элементы являются уникальными:

```js
console.log(new Set([{},{},{},{}]))
// Set(4) { {}, {}, {}, {} }
```

Если определяете «равенство» объектов, можно воспользоваться библиотекой [_Lodash_](https://lodash.com). В библиотеку входит метод `.isEqual()`, позволяющий сравнивать объекты:

```js
function getUnique (array) {
  // Если это не массив, возвращаем пустой массив
  if (Array.isArray(array) === false) {
    return []
  }

  const uniqueArray = []

  array.forEach(item => {
    if (uniqueArray.some(uniqueItem => _.isEqual(item, uniqueItem))) {
      return
    }
    uniqueArray.push(item)
  })

  return uniqueArray
}
```

Теперь перебираем элементы коллекции и накапливаем уникальные элементы в новом массиве `uniqueArray`, используя для поиска повторений метод массивов `.some()` и метод библиотеки _Lodash_ `.isEqual()`. Сложность этого алгоритма равна O(n^2), так как требуется внутренний цикл для тестирования уникальности каждого элемента.

Можно улучшить гибкость нашего решения:
- адаптировать для использования не только массивов, но и других коллекций;
- устранить зависимость от библиотеки _Lodash_ и дать возможность использовать собственную функцию для проверки уникальности элемента;
- снизить сложность алгоритма до O(n).

Для этого проверим что аргументом функции является итерируемый объект, а обход будем осуществлять с использованием [for..of](/js/for-of/). Коллекцию уникальных элементов будем накапливать используя [Map](/js/map/). Это позволит сохранять ключи значений для ускорения определения уникальности значений. Кроме этого, добавим возможность передавать в качестве второго аргумента функцию-компаратор. Функция должна вернуть пару ключ/значение, которые будут добавлены в коллекцию уникальных элементов.
Если функция не передана, вычисляем ключ, приводя значение к строке.

```js
function getUnique (collection, comparator) {
  // Если это не итерируемая коллекция, возвращаем пустой массив
  if (collection === null || typeof collection[Symbol.iterator] !== 'function') {
    return []
  }

  const unique = new Map()
  // Функция для получения пары ключ/значение
  const getKeyAndValue = typeof comparator === 'function'
    ? comparator
    : (item) => {
      const key = `${item}`
      return [key, item]
    }

  for (const item of collection) {
    const [key, value] = getKeyAndValue(item, unique)
    unique.set(key, value)
  }

  return Array.from(unique.values())
}
```

Протестируем это решение без передачи компаратора:

```js
console.log(
  getUnique([1, null, {}, [], {}, null])
)

// [ 1, null, {}, [] ]
```

Функция-компаратор пригодится для кастомизации логики, например если перед нами стоит задача объединить объекты на основе значения поля `id`:

```js
console.log(
  getUnique(
    [
      { id: 2, type: 'd' },
      { id: 3, category: null },
      { name: 'Q', value: 42, id: 2 },
      { width: 1024, size: 'big', id: 0 }
    ],
    (item, obj) => {
      const key = item.id
      const value = {
        ...obj.get(key),
        ...item
      }
      return [key, value]
    }
  )
)

// [
//   { id: 2, type: 'd', name: 'Q', value: 42 },
//   { id: 3, category: null },
//   { width: 1024, size: 'big', id: 0 }
// ]
```
