`null` обычно задаётся переменной явно и означает, что она ничего не содержит. `undefined` показывает, что значение переменной "не определено". `undefined` обычно присваивается переменной, когда она была объявлена, но не было определено её начальное значение. Также, `undefined` может возвращаться и из функции - это происходит, если функции явно не возвращает ничего другого. `null` же обычно возвращают из функции явно, чтобы показать, что результат функции равен "ничему".

Стоит сразу заметить, что без начального значения можно оставлять лишь переменную объявленную через `let` или `var`. Если объявить переменную через `const` и не задать ей начального значения, выйдет ошибка: **Uncaught SyntaxError: Missing initializer in const declaration**.

Ещё, стоит заметить то, что с `null` есть официально признанная ошибка в языке, сохраняемая для совместимости. Дело в том, что `typeof(null)` выдаст нам строку *'object'*. Ошибка тут в том, что `null` не является объектом, а отдельным типом данных. С `undefined` всё куда лучше и `typeof(undefined)` выдаст нам *'undefined'*, без никаких ошибок. Почитать ещё о `typeof` можно [здесь](/js/typecasting/#typeof).

Поговорим немного о [приведении типов](/js/typecasting/). Для начала, пример:

```js
console.log(null + null); // 0
console.log(undefined + undefined); // NaN
```

Почему так?

`null` во время сложения приводится к нулю. Это логично, так как числовым значением "ничего" является как раз 0.
С `undefined` другое поведении, т.к. JavaScript пытается привести его к числу, но у него не получается и в результате мы получаем `NaN`.

Немного упомяну и про оператор нулевого слияния (`??`). Он работает таким образом, что в выражении между двумя операндами, он будет возвращать первый операнд, если он не равен `null` или `undefined`. Можно сказать, что `??` приравнивает смысл `undefined` и `null` к "ничего не содержит" и в этом случае, кладёт в переменную значение второго операнда.
