---
excluded:
  - js/promise
---

### Теория

Для начала вспомним работу оригинального `Promise.allSettled`.

Он принимает коллекцию промисов, начинает одновременно их выполнять и возвращает массив результатов исполнения полученных промисов. Объект каждого результата содержит свойство `status`. Если `status` имеет значение `fulfilled` (выполнено), то объект будет содержать свойство `value`. Если `status` имеет значение `rejected` (отклонено), то объект будет содержать свойство `reason`. Свойства `value` или `reason` будут содержать значение, с которым был выполнен или отклонён промис.

### Подсказки

Сначала попробуйте решить самостоятельно. Если не получается, вот подсказки:

1. Можно воспользоваться методом `Promse.all`.
1. Возвращаться должен массив с объектами.
1. По завершению каждого промиса:
  - если промис был выполнен, то запипишем в поле `status` значение `fulfilled`, а в поле `value` — результат выполнения промиса.
  - если промис был отклонён, то запипишем в поле `status` значение `rejected`, а в поле `reason` — значение с текущей ошибкой, по которой он был отклонён.

### Решение

Напишем код:

```js
// На вход приходит массив промисов
Promise.allSettled = (promises) => {
  // Запустим все промисы с помощью .all
  return Promise.all(
    promises.map((promise) =>
      Promise.resolve(promise)
        // Если промис завершается успешно
        .then((value) => ({ status: "fulfilled", value }))
        // Если промис был отклонён
        .catch((e) => ({ status: "rejected", reason: e }))
    )
  )
}
```

### Тесты

Теперь протестируем наш полифил.

```js
// Создадим несколько промисов для тестирования
const a = new Promise((resolve) => setTimeout(() => { resolve(3) },200))
const b = new Promise((resolve,reject) => reject('error'))
const c = new Promise((resolve) => resolve(5))

// Выполним
Promise
  .allSettled([a, b, c])
  .then(console.log)

/*
[
{status: 'fulfilled', value: 3},
{status: 'rejected', reason: 'error'},
{status: 'fulfilled', value: 5}
]
*/
```
