---
title: "Дерево доступности"
description: ""
authors:
  - tatianafokina
keywords:
  - программа чтения с экрана
  - программа экранного доступа
  - screen reader
  - assistive technology
  - a11y tree
related:
  - a11y/chto-takoe-a11y
  - a11y/aria-intro
  - a11y/wcag
tags:
  - article
---

https://alistapart.com/article/semantics-to-screen-readers/#section5
https://adrianroselli.com/2020/12/be-careful-with-dynamic-accessible-names.html
https://developer.chrome.com/blog/full-accessibility-tree/
https://web.dev/articles/the-accessibility-tree
https://hidde.blog/how-accessibility-trees-inform-assistive-tech/#heading-3

_Дерево доступности_ или _доступное дерево (accessibility tree)_ — это представление элементов документа в виде дерева на основе [DOM](/js/dom/) (Document Object Model).

На самом деле это часть DOM, к которой имеют доступ вспомогательные технологии, например, [скринридеры](/a11y/screenreaders/). Благодаря дереву доступности они знают про содержимое и события на странице. Конечно, такие технологии взаимодействуют с деревьями не напрямую, а через посредника — Accessibility API.

Если на странице есть важная информация или функциональность, но она не переана на уровне кода, у пользователей вспомогательных технологий нет возможности взять её откуда-то ещё.

## Как выстраивается

Так как в дерево доступности попадает информация о том, как свёрстана страница, то больше всего на него влияет HTML и чуть меньше CSS и JavaScript.

Дерево доступности не полностью копирует DOM-дерево. Например, в него не попадают скрытые элементы с `display: none`, `visibility: hidden`, [атрибутом `hidden`](/html/hidden/) или декоративные [`<div>`](/html/div/).

За деревья ответственны браузеры. Именно они строят отдельные деревья для каждой страницы и передают их операционным системам для дальнейшего взаимодействия с ними вспомогательными технологиями. Так как вендоры разные, реализация деревьев тоже отличается. Названия ролей могут быть разными, по разному вычислять имена и определяться встроенные в теги роли и состояния и так далее.

Дерево доступности создаётся паралелльно с построением DOM. Браузеры запускают их, чтобы предоставить вспомогательным технологиям возможность получить доступ к страниые. Когда мы используем ARIA, мы даём браузеру дополнительные инструкции о том, как отображать дерево. В современных браузерах дерево доступности существует отдельно от DOM-дерева.

Нет необходимости запихивать в дерево доступности абсолютно всё содержимое DOM-дерева. Это сжирает много ресорсов браузеров, занимает много времени и засоряет объявления скринридеров. Так что браузеры анализируют, что и когда добавлять в такие деревья. Также деревья могут выстраиваться только в момент, когда к ним образается вспомогательная технология, или всегда.

Браузеры жлут пока вычисляться все стили и раскладка, а уже потом принимают решения об их включении или невключении в дерево доступности. К примеру, в деревья попадает содержимое псекдокласов `::before` и `::after`, которые приходится ждать. Да, CSS тоже влияет на достпуность.

Также разные браузеры используют разную структуру как основу для создания доступных объектов. Одни могут обходить DOM-дерево и стили и праралльельно создают дерево доступности. Другие могут использовать только те ноды, которые доступны в CSSOM.

## Как устроено

Похоже на [DOM-дерево](/js/dom/#iz-chego-sostoit-dom), только состоит не из HTML-элементов, а из _доступных объектов (accessible object)_. Каждый объект содержить самую важную информацию об элементе, которую нужно передать вспомогательным технологиям.

Каждый объект представляет один элемент из интерфейса. Они попадают в дерево в случае, если произошло одно из двух событий:

- сработало доступное событие (accessibility event);
- это свойство, отногения или фича, которые крайне важны для вспомогательных технологий.

Именно поэтому важна семантика. У семантических тегов вся основная информация доступна из коробки, её часто не нужно мучительно руками.

Какая информация об элементе важна для дерева доступности и, соответсвенно, есть у объектов в нём?

- Роль (role).
- Имя (name).
- Описание (description).
- Свойства и состояния.

Роли, имена и поведение элементов можно явно задавать и изменять с помощью _[ARIA-разметки](/a11y/aria-intro/) (Accessible Rich Internet Applications)_. Это вспомогательная техника для создания более доступного контента для скринридеров. Расширяет возможности HTML с помощью специальных атрибутов и ролей.

Одно из главных правил её использования — стараться не использовать ARIA. Так что она пригодится, когда не хватает возможностей HTML. К примеру, для сложных интерактивных элементов — вкладок, выпадающих списков, модальных окон или оповещений об ошибках. В этом случает [ARIA-атрибуты](/a11y/aria-attrs/) и JavaScript сделают поведение контрола понятным и предсказуемым.

Обычно в дереве доступности хранится самая важная информация для пользователей вспомогательных технологий. Что это за элемент, как он называется, как с ним взаимодействовать, какие у него есть свойства и состояния, а также есть ли дополнительное описание.

У большинства тего это всё доступно из коробки по умолчанию. Доступные имена и описания важная часть опыта для пользователей, которые могут только слышать интерфейс.

### Роль

Описывает то, что это за элемент и можно ли с ним взаимодействовать. Во многие [семантические теги](/html/#semantika) роли уже встроены. Например, у ссылки `<a>` с атрибутом `href` есть [роль `link`](/a11y/role-link/):

```html
<a href="/cozy-page/">Уютная страница</a>
```

С помощью ARIA можете задавать тегам явные роли. К примеру, лёгким движением руки `<span>` может стать ссылкой. Лучше так не делать и использовать по максимуму возможности HTML, но код под этим текстам с точки зрения браузеров и вспомогательных технологий — ссылка. Однако, если не сделать сверх этого, это будет элемент с ролью ссылки, который не обладает её другими характеристиками.

```html
<span role="link">Уютная страница</span>
```

Кстати, у `<span>` и `<div>` тоже есть роль — `generic`, но это не телает их семантическими.

Подробнее с этой концепцией познакомитесь в статье «[ARIA-роли](/a11y/aria-roles/)».

### Имя

Другое название — доступное имя (accessible name). Помогает лучше понять, что это за элемент и какая у него цель. Обычно озвучивается при фокусе. Оно берётся из текстового содержимого тегов или атрибутов.

Если просто, то это подпись к элементу. Мы привыкли к тому, что только у полей может быть подпись, но, на самом деле, она есть у всех элементов, просто не из-за тега `<label>`.

Давайте снова вернёмся к примеру со ссылкой. В её случае именем становится текст «Уютная страница» между открывающим и закрывающим тегами.

```html
<a href="/cozy-page/">Уютная страница</a>
```

А вот у этой кнопки нет имени, поэтому вспомогательные технологии могут рассказать о том, что это какая-то кнопка.

<button type="button"></button>

В полями всё ещё проще. Их имя берётся из атрибута `<label>`, когда он связан с полем.

```html
<label for="pokemon">Любимый покемон:</label>
<input type="text" id="pokemon">
```

Имена могут браться также и из ARIA-атрибутов `aria-label` и `aria-labelledby`. У этой кнопки с иконкой имя берётся из атрибута и это «Сделать комплимент».

```html
<button aria-label="Сделать комплимент">
  <!-- Иконка -->
</button>
```

У способов предоставления имени есть разные особенности и приоритетность. Тема вычисления имён — отдельный разговор. Подробнее узнаете их отдельной спецификации про это https://www.w3.org/TR/accname-1.1/, а в будуем и из Доки (если напишите статью).

aria-labelledby
aria-label
<label> с for
placeholder
alt
<caption>
<legend>
текст из тега
title
значение (тип input у button, submit, reset)

### Описание

Другие названия — доступное описание (accessible description) или вспомогательный текст (helper text). Это дополнение к имени, которое больше расскрывает элемент или содержит подсказку к нему. Озвучивается после имени и роли элемента, если выбрана такая настройка в скринридере.

Это необязательная, опциональная часть доступного объекта. Помогате пользователям всспомогательных технологий глубже понять интерфейс и чего от них хотят дизайнеры и разработчики, особо важно, если в интерфейсе есть какие-то нестандартные элементы.

Все описания к элементам добавляются с помощью специальных ARIA-атрибутов — `aria-describedby`, `aria-details`, `aria-description`.

```html
<button type="button" aria-describedby="hint">Выбрать тему</button>

<span id="hint">Выберите ваш любимый цвет, который будет на фоне страницы.</span>
```

### Свойства и состояния

Содержат детали о раскладке и возможных действиях с объектами. К примеру, выбран или нет сейчас элемент, связан ли с ним другой и так далее.

Во многие семантические теги, кроме роли, встроены и свойства и состояния. Например, у чекбоксов есть атрибут `checked`, который помогает пользователям скринридеров понять, какой сейчас выбран чекбокс.

```html
<label for="potato">Люблю пиццу с ананасом:</label>
<input id="potato" type="checkbox" checked>
```

ARIA в случае свойств и состояний также даёт ими управлять и задавать элементам. Какие-то полностью дублируют атрибуты из HTML.

```html
<span id="label">Люблю пиццу с ананасом:</span>
<span role="checkbox" aria-labelledby="label" aria-checked="true"></span>
```

Какие-то атрибуты уникальные и помогают делать уже существующие семантические теги чуть более доступными. Например, aria-expanded сообщает о состоянии свёрнутости и развёрнутости у связанного с основным элементом контента.

```html
<button aria-expanded="false">Все товары</button>
<ul>
  <!-- Список ссылок -->
</ul>
```

Подробнее про свойства и состояния в статье «[ARIA-атрибуты](/a11y/aria-attrs/)».

## Как взаимодействуют браузеры, скринридеры и Accessibility API

Представим, что пользователь скринридера добрался до кнопки «Отправить»:

1. Сначала скринридер запрашивает информацию о кнопке.
1. Accessibility API получает запрос и передаёт его браузеру.
1. Браузер проверяет DOM и находит нужный элемент и его стили.
1. Теперь браузер может преобразовать элемент из DOM в понятный формат для Accessibility API. Это и есть объект из дерева доступности с именем и ролью. После этого браузер отдаёт его API.
1. API возвращает эту информацию скринридеру.
1. Скринридер объявляет: «Отправить, кнопка». Ура!

![Схема чтения кнопки скринридером. Программа запрашивает элемент у Accessibility API, он передаёт его браузеру, браузер находит кнопку в документе, отдаёт API имя «Отправить» и роль «button», скринридер получает от API имя и роль элемента и зачитывает их.](images/3.png)

Теперь пользователь решил нажать на кнопку, чтобы что-то отправить:

1. Скринридер вызывает метод из Accessibility API.
1. Accessibility API идёт к браузеру и сообщает о вызове метода.
1. Браузер ищет и обрабатывает событие с учётом того, есть ли обработчик события.
1. Представим, что на сайте есть скрипт, который отслеживает события. В этом случае он выполняется, и происходит нужное действие при клике на кнопку.

![Схема нажатия на кнопку. Скринридер запрашивает метод у Accessibility API, он передаёт этот метод браузеру, браузер находит скрипт с обработчиком события, в итоге выполняется какая-то функция при клике на кнопку.](images/4.png)

### Всё вместе

Тут схема?

## Как заглянуть

Вы можете посмотреть на дерево доступности в браузерах до взаимодействия с ними вспомогательных технологий.

Chrome. Открыть инструмент разработчика Chrome, под вкладкой Элементы найти другую Доступность. Первый пункт в списке Accessibility Tree.

Firefox. Открыть интсрумент разработчика Firefox, выбрать вкладку Accessibility. Включить опцию accessibility features, после этого появится Accessibility Tree.

Посмотреть на дерево доступности можно в инспекторах браузеров во вкладке с доступностью. Например, так выглядит [`<img>`](/html/img/) в виде объекта дерева в Firefox. У него роль `graphic` (в Chrome будет [`img`](/a11y/role-img-image/)), а имя — это описание картинки из атрибута `alt`.

![Дерево доступности в инструментах разработчика в Firefox для элемента картинки. name: Пример клавиатуры для поля ввода номера телефона. role: graphic. DOMNode: img.](images/2.png)

## Будущее

Пока мы не можем получить к доступному дереву прямой доступ, управлять им или читать его содержимое.

Сейчас инициативная группа W3C (Web Incubator Community Group) разрабатывает документацию для специального API, которое позволит разработчикам получать доступ к дереву доступности в браузере напрямую, вычисляемым ролям, именам и прочему, а также манипулировать им. Оно нахывается Accessibility Object Model (AOM).

https://wicg.github.io/aom/explainer.html
