---
title: "Как реально работают `flex-shrink` и `flex-grow`"
description: "Механизм расчёта свободного места во флекс-контейнере при помощи свойств `flex-grow` и `flex-shrink`."
authors:
  - openysheva
related:
  - ""
tags:
  - article
---


[`flex-grow`](/css/flex-grow/) и [`flex-shrink`](/css/flex-shrink/) — это CSS-свойства, определяющие, какое количество свободного пространства флекс-контейнера может занимать текущий элемент.

Рассмотрим каждое свойство в отдельности.

## `flex-grow`

Создадим флекс-контейнер с двумя вложенными элемента с разными значениями `flex-grow`.

```html
<div class="container">
   <div class="container-item-grown">flex-grow - 2</div>
   <div class="container-item-common">flex-grow - 1</div>
</div>
```

```css
.container {
  display: flex;
  width: 1200px;
  height: 100px;
}

.container-item-grown {
  background-color: orange;
  flex-grow: 2;
}

.container-item-common {
  background-color: yellow;
  flex-grow: 1;
}
```

<iframe title="Пример select" src="demos/grow/" height="300"></iframe>

У нас есть контейнер шириной 1200 px, для первого элемента указан `flex-grow: 2`, а для второго — `flex-grow: 1`. 
Первый элемент занимает 800 px, а второй 400 px. 

Хочется думать, что здесь всё просто и работает по правилам математики:

 - сложить значения свойства для каждого контейнера и получить 3 (2 + 1);
 - поделить ширину контейнера на общее количество «частей» и получить 400px (1200px / 3);
 - для каждого блока использовать значение `flex-grow` как вес и умножить на ширину одной части;
 - для первого блока 400px * 2 = 800px;
 - для второго блока 400px * 1 = 400px.

Пока всё верно. Однако, часто на практике мы ожидаем, что сейчас мы укажем `flex-grow` и это нас спасёт и… не работает.

Вот пример, такого *“не работает”*.

```html
<div class="container">
  <div class="container-item-grown">
    <p>
      Равным образом сложившаяся структура организации требуют определения и уточнения модели развития. Повседневная практика показывает, что дальнейшее развитие различных форм деятельности обеспечивает широкому кругу (специалистов) участие в формировании систем массового участия.
    </p>
  </div>
  <div class="container-item-common">
    <p>
      Равным образом сложившаяся структура организации требуют определения и уточнения модели развития. Повседневная практика показывает, что дальнейшее развитие различных форм деятельности обеспечивает широкому кругу (специалистов) участие в формировании систем массового участия.
    </p>
  </div>
</div>
```

```css
.container {
  display: flex;
  width: 1200px;
  height: 100px;
}

.container-item-grown {
  background-color: orange;
  flex-grow: 2;
}

.container-item-common {
  background-color: yellow;
  flex-grow: 1;
}
```

<iframe title="Пример select" src="demos/grow-equal/" height="300"></iframe>

Пример отличается от предыдущего тем, что в блоках появился текст, обернутый в параграф. И результат таков, что блоки стали одинаковыми по ширине. 

Получается, что логика рассуждений, приведенная выше не работает?
Не совсем так, давайте разбираться.

Деталь кроется в том, что flex-grow определяет, какое количество **свободного** места занимает элемент. И если внимательно посмотреть, то каждый блок текста занял по 600px ширины, а свободного пространства не осталось. Поэтому и распределять нечего.

Почему же в первом примере всё работает ожидаемо? Там логика сработала, потому что для блоков не указана ширина и в них нет вложенных элементов, а значит ширина обоих 0 px, и **свободное** место — это и есть ширина контейнера, то есть 1200 px.

И что, если свободного места нет, то использовать flex-grow не получится? Не совсем, нужно просто добавить свойство flex-basis. Если использовать эти свойства в комплекте, то алгоритм расчета ширины изменится.

Flex-basis - это свойство, которое устанавливает начальный основной размер flex-элемента. Его можно задать в любых единицах, в которых можно задать [ширину элемента](/css/width/#kak-pishetsya).

В результате мы получим то, чего хотим.

```html
<div class="container">
  <div class="container-item-grown">
    <p>
      Равным образом сложившаяся структура организации требуют определения и уточнения модели развития. Повседневная практика показывает, что дальнейшее развитие различных форм деятельности обеспечивает широкому кругу (специалистов) участие в формировании систем массового участия.
    </p>
  </div>
  <div class="container-item-common">
    <p>
      Равным образом сложившаяся структура организации требуют определения и уточнения модели развития. Повседневная практика показывает, что дальнейшее развитие различных форм деятельности обеспечивает широкому кругу (специалистов) участие в формировании систем массового участия.
    </p>
  </div>
</div>
```

```css
.container {
  display: flex;
  width: 1200px;
}

.container-item-grown {
  background-color: orange;
  flex-grow: 2;
  flex-basis: 800px;
}

.container-item-common {
  background-color: yellow;
  flex-grow: 1;
  flex-basis: 400px;
}
```

<iframe title="Пример select" src="demos/grow-basis/" height="300"></iframe>

Еще один пример без flex-basis для закрепления. Попробуем задать ширину параграфов: для первого параграфа зададим 300px, а для второго 600px.

```html
<div class="container">
  <div class="container-item-grown">
    <p>
      Равным образом сложившаяся структура организации требуют определения и уточнения модели развития. Повседневная практика показывает, что дальнейшее развитие различных форм деятельности обеспечивает широкому кругу (специалистов) участие в формировании систем массового участия.
    </p>
  </div>
  <div class="container-item-common">
    <p>
      Равным образом сложившаяся структура организации требуют определения и уточнения модели развития. Повседневная практика показывает, что дальнейшее развитие различных форм деятельности обеспечивает широкому кругу (специалистов) участие в формировании систем массового участия.
    </p>
  </div>
</div>
```

```css
.container {
  display: flex;
  width: 1200px;
}

.container-item-grown {
  background-color: orange;
  flex-grow: 2;
}

.container-item-common {
  background-color: yellow;
  flex-grow: 1;
}

.container-item-grown p {
  width: 300px;
}

.container-item-common p {
  width: 600px;
}
```

<iframe title="Пример select" src="demos/grow-width/" height="300"></iframe>

Здесь получается не совсем ожидаемый от flex-grow результат, если не знать как работает свойство на самом деле. Но мы-то уже знаем, давайте посчитаем:

 - первый блок занимает 300px. Это свойство задано в теге p.
 - второй блок занимает 600px. Причина все та же - так задано в дочернем элементе.
 - итого, для распределения свойством flex-grow остается 300px. Далее применим логику, которая была описана чуть выше, и…
 - на первый элемент придется 200px, а на второй - всего 100px
 - в итоге первый элемент займет 500px (300px + 200px), а второй - 700px (600px + 100px).

### Что еще здесь важно помнить?
Как работает свойство [box-sizing](/css/box-sizing/). Так как свойство flex-basis - это изначальная ширина, оно и вычисляется как свойство width. А значит вычисление зависит и от box-sizing.

## `flex-shrink`

Теперь посмотрим на свойство [flex-shrink](/css/flex-shrink). Его мы используем в тех случаях, когда места не хватает и размеры элементов флекс-контейнера нужно уменьшить. Здесь математика чуть сложнее, вот пример:

```html
<div class="container">
  <div class="container-item-shrikned">
    <p>
      Равным образом сложившаяся структура организации требуют определения и уточнения модели развития. Повседневная практика показывает, что дальнейшее развитие различных форм деятельности обеспечивает широкому кругу (специалистов) участие в формировании систем массового участия.
    </p>
  </div>
  <div class="container-item-common">
    <p>
      Равным образом сложившаяся структура организации требуют определения и уточнения модели развития. Повседневная практика показывает, что дальнейшее развитие различных форм деятельности обеспечивает широкому кругу (специалистов) участие в формировании систем массового участия.
    </p>
  </div>
</div>
```

```css
.container {
  display: flex;
  width: 800px;
}

.container-item-shrikned {
  background-color: orange;
  flex-shrink: 2;
  flex-basis: 400px;
}

.container-item-common {
  background-color: yellow;
  flex-shrink: 1;
  flex-basis: 800px;
}
```

<iframe title="Пример select" src="demos/grow-width/" height="300"></iframe>

У нас в примере два элемента, у каждого есть изначальная ширина (`flex-basis` равен 400 px и 800 px соответственно). Итого 1200 px. Однако ширина флекс-контейнера всего 800 px;

Сначала посчитаем общий вес при том, что для первого элемента значение `flex-shrink` составляет 2, а для второго — 1: 2 * 400px + 1 * 800px = 1600px.
Для полноценного размещения нам не хватает 1200px - 800px = 400px.

Посчитаем на сколько пикселей сократится каждый элемент:

 - 400px (пространство, которого не хватает) * 2 (значение flex-shrink) * 400px (значение flex-basis) / 1600px (общий вес) = 200px
 
 - 400px (пространство, которого не хватает) * 1 (значение flex-shrink) * 800px (значение flex-basis) / 1600px (общий вес) =
   200px

А в результате ширина блоков будет следующая:
- 400px - 200px = 200px
- 800px - 200px = 600px

Вывод: с помощью свойств [`flex-basis`](/css/flex-basis/), [`flex-grow`](/css/flex-grow/), [`flex-shrink`](/css/flex-shrink/) можно предусмотреть как ситуации, когда контейнер окажется больше, чем элементы, в нём размещенные, так и наоборот - когда контейнер мал для элементов. А если знать как рассчитываются итоговые размеры, то можно избежать различных неожиданностей.


