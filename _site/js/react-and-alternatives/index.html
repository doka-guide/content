<p>В мире фронтенда много различных фреймворков для разработки <a href="/js/web-app-types/#single-page-applications-spa">одностраничных приложений</a>. Большинство из них различаются подходами к разработке и инструментами, которыми они обладают. Но в основе всех этих фреймворков часто лежат одни и те же концепции. Эти концепции и различия в подходах мы рассмотрим в этой статье.</p>
<h2>Кратко</h2>
<p>Чтобы облегчить поиск изменений в приложении и работу с DOM браузера, некоторые фреймворки используют Virtual DOM. Virtual DOM – объект, который хранит структуру дерева компонентов и их текущее состояние.</p>
<p>React использует Virtual DOM для отслеживания изменений. После каждого изменения состояния React создаёт новый Virtual DOM и сравнивает его с предыдущим, чтобы узнать, какие части приложения изменились.</p>
<p>Vue использует Virtual DOM и специальные объекты Proxy, чтобы узнавать, когда изменились данные.</p>
<p>Angular не использует Virtual DOM, но модифицирует браузерный DOM API, чтобы иметь возможность следить за изменением данных. Таким образом, если пользователь взаимодействует со страницей, то Angular проверяет, не изменились ли какие-то данные приложения.</p>
<p>Svelte не использует Virtual DOM, но во время компиляции приложения формирует функции, которые следят за изменением данных и обновляют соответствующие DOM-элементы.</p>
<h2>Реактивность</h2>
<p>Все фреймворки стараются следовать принципам <a href="/js/reactivity/">реактивности</a>, чтобы сделать интерфейс быстрым и отзывчивым. При этом каждый использует разные способы, чтобы её организовать. Основные различия кроются в том, как фреймворк отслеживает изменения и проводит синхронизацию модели в <a href="/js/dom/">DOM браузера</a>.</p>
<p>Однако следование принципам реактивности не значит, что фреймворки на самом деле работают реактивно. Для реактивности некоторые фреймворки используют вспомогательные сущности, например Virtual DOM.</p>
<h2>Virtual DOM</h2>
<p>Virtual DOM — это легковесный объект, который описывает структуру приложения. Объект Virtual DOM отображает своё дерево компонентов в браузерное <a href="/js/dom/">DOM-дерево</a>. Так фреймворк узнаёт, какой компонент соответствует какому DOM-элементу на странице. Это дерево хранится в памяти и обновляется каждый раз при изменении данных в приложении.</p>
<p>Например, если наш интерфейс состоит из кнопок, нажатие на которые открывает модальные окна, то стартовый Virtual DOM будет содержать только компоненты кнопок. При отображении в браузере мы увидим эти кнопки. Если нажать на одну из них, то Virtual DOM обновится и будет содержать кнопки и модальное окно. Так как модального окна нет в браузере, фреймворк понимает, что нужно его дорисовать.</p>
<aside>
<p>☝️ Факт обновления браузерного DOM не означает, что элементы будут удаляться и создаваться заново. Для экономии времени фреймворки будут стараться сохранить как можно больше элементов на странице и производить только точечные изменения.</p>
</aside>
<p>Virtual DOM существует и работает только в рантайме, то есть во время выполнения программы, и все своё состояние он хранит в памяти. Большие приложения могут создавать очень большие деревья, а многочисленные изменения будут приводить к многократным пересозданиям отдельных поддеревьев и их проверкам с предыдущей версией. Все эти факторы влияют на производительность — чем больше дерево, тем больше работы придётся сделать после его изменений.</p>
<h2>React</h2>
<p>Каждое приложение (или отдельные компоненты) в React имеет состояние. Состояние — это данные, за которыми React следит и перерисовывает интерфейс в браузере при их изменении. У React <a href="/js/architecture-data-flow/">однонаправленный поток данных</a>, и он предоставляет специальный API для обновления состояния.</p>
<p>Когда нужно обновить состояние, разработчик вызывает функцию для установки нового значения. Благодаря этому React узнаёт, когда начинать перерисовку. Такой подход является pull-реактивностью, так как мы явно даём знать React, что данные изменились, но фреймворк сам решит, в какой момент времени нужно обновить данные в браузере.</p>
<p>Главная особенность React – это Virtual DOM. Когда React только появился, это было его главным нововведением. Вся логика отображения, выявления изменений и обновление браузерного DOM строится вокруг Virtual DOM.</p>
<p>Функциональные компоненты и функция <code>render()</code> в классовых компонентах возвращают Virtual DOM. Все элементы в Vitual DOM  — это объекты с одинаковым набором свойств, они очень похожи на <a href="/js/element/">DOM-элементы</a>.</p>
<p><img src="images/virtual_dom.png" alt="Структура Vitual DOM"></p>
<p>Вложенность элементов Virtual DOM можно увидеть с помощью свойства <code>children</code> внутри свойства <code>props</code>. Так получается древовидная структура. На картинке выше можно увидеть, что внутри исходного компонента находится <code>div</code>, который содержит строку <code>&quot;Hello Doka&quot;</code>.</p>
<p>Когда происходит изменение в приложении (к примеру, поменялось состояние), React запускает алгоритм сравнения двух Virtual DOM: старого и нового. Он <a href="/js/recursion/">рекурсивно</a> проходит по всему дереву и пытается найти отличия в их структуре. Если различия найдены, то DOM в браузере обновится соответственно. Все это происходит в реальном времени, но работает очень быстро, поэтому пользователь не видит никаких задержек.</p>
<p>Алгоритм сравнения содержит множество нюансов, подробности лучше посмотреть в <a href="https://ru.reactjs.org/docs/reconciliation.html">официальной документации</a>.</p>
<h2>Angular</h2>
<p>Angular, чтобы связывать данные приложения и отображение, использует HTML-подобный синтаксис для своих шаблонов и компилирует эти шаблоны в набор инструкций, которые создают браузерные DOM-элементы. Angular не использует Virtual DOM, чтобы хранить дерево компонентов в памяти.</p>
<p>У Angular есть две стратегии для обнаружения изменений: <code>default</code> и <code>onPush</code>.</p>
<p>По умолчанию в приложении включена стратегия <code>default</code>.</p>
<p>Стратегия <code>default</code> работает просто: Angular рекурсивно проходит по дереву компонентов, и для каждого выражения, используемого в шаблоне, он сравнивает текущее значение с предыдущим. Если значения отличаются, то фреймворк помечает их и в итоге меняет отображение в DOM.</p>
<p>При этом Angular умеет самостоятельно запускать обнаружение изменений, например после клика или после вызова асинхронного <code>setTimeout</code>. Чтобы отлавливать изменения, которые происходят через браузерное API, Angular использует <code>zone.js</code>. Это библиотека, которая связывает асинхронный API браузера и Angular. При запуске приложения <code>zone.js</code> патчит браузерный API, например <a href="/js/element-addeventlistener/">addEventListener</a>, <code>setTimeout</code>, <code>setInterval</code> и API для AJAX-запросов. Тем самым Angular добавляет возможность отслеживать изменения автоматически после запуска функций из браузерного API.</p>
<pre><code class="language-js">// Пример, как это может выглядеть
function addEventListener(name, handler, options) {
    this.addEventListener(name, (...args) =&gt; {
      handler(...args);

      angular.runChangeDetection();
    })
}

EventTarget.prototype.addEventListener = addEventListener
</code></pre>
<p>Таким образом, фреймворк старается самостоятельно отслеживать изменения, снимая с разработчика эту рутину.</p>
<p>Стратегия <code>default</code> очень удобна, так как разработчику ничего не нужно проверять самостоятельно. Но в больших приложениях может вызывать проблему с производительностью из-за частых перезапусков проверок на любое событие. Чтобы решить эти проблемы и сделать обнаружение изменений более явным, используют стратегию <code>onPush</code>.</p>
<p>Стратегия <code>onPush</code> заменяет механизм обнаружения изменения. При ней компонент обновляется, только если меняются входные данные — примерно как работают <em>props</em> в React компонентах. Когда входные данные компонента изменяются, Angular проходится по всему поддереву и обновляет дочерние элементы.</p>
<p>Обе стратегии обновления могут использоваться одновременно. Стратегию <code>onPush</code> применяют для оптимизации высоконагруженных частей приложения.</p>
<h2>Vue</h2>
<p>Vue реализует реактивность с помощью Proxy. Proxy – это специальный объект в JavaScript, который позволяет следить за изменениями свойств другого объекта. Это даёт Vue возможность отслеживать, когда свойство объекта было изменено или считано, и реагировать на это. При этом объект, отслеживаемый с помощью Proxy, ничем не отличается от обычного.</p>
<p>Vue не только отслеживает свойства объектов, но и оборачивает функции в <em>эффекты</em>. Эффект – это обёртка вокруг функции, которая формирует порядок вызова и следит, какую функцию нужно вызвать.</p>
<p>Упрощённо, эффекты во Vue устроены так:</p>
<ul>
<li>есть место, где хранится список запущенных эффектов <code>effects</code></li>
</ul>
<pre><code class="language-js">const effects = []
</code></pre>
<ul>
<li>есть функция <code>addEffect</code>, которая создаёт эффекты. Перед вызовом эффект записывается в список запущенных, а после выполнения - удаляется:</li>
</ul>
<pre><code class="language-js">const addEffect = fn =&gt; {
  const runEffect = () =&gt; {
    effects.push(runEffect)

    fn()

    effects.pop()
  }

  runEffect()
}
</code></pre>
<p>При использовании функции <code>addEffect</code> можно увидеть, что функция <code>fn</code>  добавляется в список эффектов:</p>
<pre><code class="language-js">const makeChanges = () =&gt; {
  console.log(effects) // Выведет массив с одной функцией [ ƒ ]
}

const fn = () =&gt; {
  // ...
  makeChanges()
}

addEffect(fn)
</code></pre>
<p>Для обновления DOM в браузере Vue тоже использует Virtual DOM. Vue использует свой синтаксис шаблонов, похожий на Angular, но при компиляции приложения эти шаблоны преобразуются в вызовы render-функций, создающих Virtual DOM. Алгоритм обхода и свойства объекта в Virtual DOM во Vue отличаются от React, но основные подходы очень похожи.</p>
<h2>Svelte</h2>
<p>Svelte отличается от других фреймворков тем, что функции для отслеживания изменений формируются во время компиляции приложения.</p>
<p>Svelte имеет свой язык шаблонов, похожий на тот, что есть в Angular или Vue. Благодаря ему компилятор умеет просчитывать все зависимости заранее. В итоге Svelte формирует набор функций, которые следят только за определёнными значениями и обновляют DOM при их изменениях. Это быстрее подхода Virtual DOM, так как не нужно проверять всё дерево, чтобы узнать где произошли изменения, и не нужно хранить всё дерево компонентов в памяти.</p>
<p>Предположим, есть код, который увеличивает значение переменной.</p>
<pre><code class="language-js">let count = 0;

function increment() {
  count = count + 1;
}
</code></pre>
<p>Во время компиляции Svelte ищет все места, где меняются данные, и на выходе добавляет вызов специальной функции, которая помечает, что изменение произошло.</p>
<pre><code class="language-js">function instance($$self, $$props, $$invalidate) {
  let count = 0;

  function increment(event) {
    $$invalidate(0, count = count + 1);
  }

  return [count, increment];
}
</code></pre>
<p>Код выше - это небольшая часть того, что скомпилировал Svelte. Здесь видно, как в изначальную функцию добавилась специальная функция <code>$$invalidate</code>, которая пометила, что данные изменились, и тем самым запланировала обновление DOM-элемента, где используется это значение.</p>
<h2>Заключение</h2>
<p>Все рассмотренные фреймворки подойдут для написания любого типа приложения. Но каждый использует свои подходы для решения проблем с обнаружением изменений и работой с DOM.</p>
<p>Virtual DOM, используемый в React и Vue, помогает держать актуальное состояние приложения прямо в памяти. Он позволяет быстро находить изменения путём сравнения двух версий. Большие приложения будут занимать много места в памяти, а частые обновления будут занимать больше времени.</p>
<p>Angular помогает разработчику с помощью автоматических проверок изменений. Но имеет вторую стратегию, чтобы при необходимости помочь оптимизировать приложение.</p>
<p>Svelte уникален тем, что формирует код, который будет отслеживать изменения, во время сборки приложения. В итоге получается только необходимый для приложения код.</p>
<p>Любой фреймворк – это инструмент для решения конкретной задачи. Потому знание того, как фреймворк работает внутри, поможет принять взвешенное решение.</p>
