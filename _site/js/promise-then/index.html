<p>Эта статья связана с понятием <a href="/js/promise/">Promise</a></p>
<h2>Кратко</h2>
<p>Метод <code>then</code> используют, чтобы выполнить код после изменения состояния промиса.</p>
<p>Метод принимает два аргумента:</p>
<ul>
<li><code>onFulfill</code> — функция-колбэк, которая будет вызвана при переходе промиса в состояние «успех» <code>fulfilled</code>. Функция имеет один параметр, в который передаётся результат выполнения операции</li>
<li><code>onReject</code> — функция-колбэк, которая будет вызвана при переходе промиса в состояние «ошибка» <code>rejected</code>. Функция имеет один параметр, в который передаётся информация об ошибке</li>
</ul>
<p>Всегда возвращает новый промис.</p>
<h2>Как пишется</h2>
<pre><code class="language-js">// getPasswords() — асинхронная функция, которая возвращает промис
getPasswords().then(
  function (result) {
    // что-то делаем с результатом операции
    console.log(&quot;Все пароли:&quot; + result)
  },
  function (err) {
    // обрабатываем ошибку
    console.error(err.message)
  }
)
</code></pre>
<h2>Как понять</h2>
<p>Обработка асинхронных операций через промис и <code>then</code> очень похожа на работу с колбэками.</p>
<p>Так как <code>then</code> всегда возвращает новый промис, то его удобно использовать для построения последовательностей асинхронных операций:</p>
<pre><code class="language-js">// запросим через API список домов из Игры престолов. Метод `fetch` возвращает промис
fetch('https://www.anapioficeandfire.com/api/houses')
  .then(function (response) {
    // выполнится, когда от API придет ответ

    // запустим асинхронную операцию парсинга JSON из ответа сервера
    return response.json() // вернем из обработчика промис, к которому добавим then
  })
  .then(function (houses) {
    // выполнится, когда JSON распарсится

    return fetch(houses[0].overlord) // запросим данные о сюзерене этого дома
  })
  .then(function (response) {
    // выполнится, когда от API придет ответ
    return response.json()
  })
  .then(function (overlord) {
    console.log(overlord.name)
  })
</code></pre>
<p>В коде выше, каждый вызов <code>then</code> привязан к результату предыдущей операции. Такой код читается почти как синхронный.</p>
