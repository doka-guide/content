<h2>Кратко</h2>
<p>Программа может работать правильно, только если код написан корректно и не содержит ошибок. JavaScript умеет обрабатывать некорректный код и сообщать об ошибке в коде. Существует семь встроенных видов ошибок, также можно создать свои собственные. Встроенные ошибки генерируются самим движком JavaScript при выполнении программы, а пользовательские — создаются с помощью конструктора <code>Error</code>. Оба типа ошибок можно ловить в конструкции <a href="/js/try-catch/"><code>try...catch</code></a>.</p>
<h2>Как это понять</h2>
<h3>Error</h3>
<p>Общий конструктор ошибок.</p>
<pre><code class="language-js">new Error('Общая ошибка. Проверьте код')
</code></pre>
<p>Вызов конструктора возвращает объект ошибки со следующими свойствами:</p>
<ul>
<li><code>message</code> представляет человекопонятное описание ошибки для встроенных типов (<code>SyntaxError</code>, <code>TypeError</code> и так далее) и переданное в конструктор значение для общего типа <code>Error</code>.</li>
<li><code>name</code> — имя типа (класса) ошибки.</li>
</ul>
<pre><code class="language-js">const commonError = new Error('Общая ошибка. Проверьте код')

console.log(commonError.message)
// 'Общая ошибка. Проверьте код'

console.log(commonError.name)
// 'Error'
</code></pre>
<p>Нестандартное свойство <code>stack</code> показывает, на какой строке кода возникла ошибка. Первая строка отформатирована как <code>&lt;имя класса ошибок&gt;: &lt;сообщение об ошибке&gt;</code>, и за ней следует серия кадров стека (каждая строка начинается с «at»).</p>
<p>Пример из <a href="https://v8.dev/docs/stack-trace-api">документации к движку V8</a>:</p>
<pre><code>ReferenceError: FAIL is not defined
  at Constraint.execute (deltablue.js:525:2)
  at Constraint.recalculate (deltablue.js:424:21)
  at Planner.addPropagate (deltablue.js:701:6)
  at Constraint.satisfy (deltablue.js:184:15)
  at Planner.incrementalAdd (deltablue.js:591:21)
  at Constraint.addConstraint (deltablue.js:162:10)
  at Constraint.BinaryConstraint (deltablue.js:346:7)
  at Constraint.EqualityConstraint (deltablue.js:515:38)
  at chainTest (deltablue.js:807:6)
  at deltaBlue (deltablue.js:879:2)
</code></pre>
<h2>Встроенные ошибки</h2>
<h3>SyntaxError</h3>
<p>Чаще всего встречаются опечатки — неправильные названия методов, лишние или отсутствующие точки с запятой или скобочки и так далее. Такой тип ошибок называется «синтактическим», <code>SyntaxError</code>:</p>
<pre><code class="language-js">console.log(;)
// SyntaxError: Unexpected token ';'

console.log(()
// SyntaxError: missing ) after argument list
</code></pre>
<h3>ReferenceError</h3>
<p>Если попытаться обратиться к несуществующей переменной, произойдёт ошибка <code>ReferenceError</code>:</p>
<pre><code class="language-js">console.log(name)
// ReferenceError: name is not defined
</code></pre>
<h3>TypeError</h3>
<p>Если попытаться обратиться к несуществующему свойству, произойдёт ошибка <code>TypeError</code>:</p>
<pre><code class="language-js">console.log(null.length)
// TypeError: Cannot read property 'length' of null

undefined()
// TypeError: undefined is not a function
</code></pre>
<h3>RangeError</h3>
<p>Ошибка для значений, которые выходят за диапазон допустимого.</p>
<pre><code class="language-js">new Array(10000000000)
// RangeError: Недопустимая длина массива
</code></pre>
<h3>URIError</h3>
<p>Этот тип ошибок возникает при неправильном использовании обработки URI.</p>
<pre><code class="language-js">decodeURIComponent('%')
// URIError: URI malformed
</code></pre>
<p>Валидным считается URI, формат которого соответствует спецификации <a href="https://datatracker.ietf.org/doc/html/rfc3986">RFC 3986</a>:</p>
<pre><code>URI = scheme:[//authority]path[?query][#fragment]
</code></pre>
<h3>EvalError</h3>
<p>EvalError представляет ошибку, возникающую в глобальной функции <code>eval()</code>.</p>
<pre><code class="language-js">eval(
  'console.log(null.length)'
)
</code></pre>
<p>Эта ошибка в настоящее время не используется и остаётся для совместимости с предыдущими версиями JavaScript.</p>
<h3>InternalError (не стандарт)</h3>
<p>Ошибка внутри движка JavaScript. Не является стандартом и почти не используется. Например:</p>
<pre><code>&quot;InternalError: инициализатор массива слишком большой&quot;.
</code></pre>
<h2>Собственный класс ошибок</h2>
<p>Можно расширять базовый класс <code>Error</code> и создавать собственные типы ошибок.</p>
<pre><code class="language-js">class WrongDataTypeForSumError extends Error {
  constructor(message) {
    super(message)
    this.name = 'WrongDataTypeForSumError'
  }
}

const myCustomError = new WrongDataTypeForSumError('Невалидный тип данных для суммирования')
</code></pre>
<p>Сгенерируем ошибку <code>WrongDataTypeForSumError</code> в случае, если хотя бы один из аргументов функции <code>sum</code> — не число.</p>
<pre><code class="language-js">function sum(a, b) {
  if (typeof a !== 'number' || typeof b !== 'number') {
    throw new WrongDataTypeForSumError('Невалидный тип данных для суммирования')
  }

  return a + b
}

console.log(sum('1', 2))
// VM840:3 Uncaught WrongDataTypeForSumError: Невалидный тип данных для суммирования
// at sum (&lt;anonymous&gt;:3:11)
// at &lt;anonymous&gt;:9:13
// WrongDataTypeForSumError @ VM830:3
// sum @ VM840:3
// (anonymous) @ VM840:9
</code></pre>
<p>Функция будет выполняться только в том случае если оба аргумента будет числами, в противном случае функция будет возвращать ошибку <code>WrongDataTypeForSumError</code>.</p>
<p>Собственные типы ошибок делают отладку более наглядной — например из имени <code>WrongDataTypeForSumError</code> сразу понятно, что не так с кодом. Стандартная ошибка для таких случаев, <code>TypeError</code> — менее читаема.</p>
