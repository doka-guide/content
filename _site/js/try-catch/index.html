<h2>Кратко</h2>
<p>Конструкция <code>try...catch</code> позволяет выполнить произвольный код, но если в нем произошла ошибка, то программа не остановит своё выполнение, а перейдёт в блок <code>catch</code>, где ошибку можно обработать.</p>
<h2>Как понять</h2>
<p>Ошибки в программах это очень неприятно, но никто не застрахован от их появления. К тому же, ошибки могут появляться в тех ситуациях, которые не зависят от нас самих. Например, пользователь неправильно воспользовался программой. Поэтому в языке необходимы конструкции, которые позволяют выполнить произвольный код, но в случае ошибки дать возможность её обработать.</p>
<p>В JavaScript ситуация ещё сложнее. Если во время работы скрипта возникла ошибка и она не была обработана, то выполнение останавливается, и программа больше не работает.</p>
<p>Конструкция <code>try...catch</code> делает программы стабильнее — в случае ошибки мы можем продолжить выполнение. Мы можем написать любой синтаксически верный код и, если он выполнится без ошибок, то отлично. Если же что-то пойдёт не так, то выполнится код, написанный в <code>catch</code>.</p>
<p>Представьте, что вы тренируетесь отбивать мяч в бейсбол. У вас есть партнёр, который будет <strong>ловить</strong> мяч, в случае вашей <strong>ошибки</strong>, если отбить мяч не удастся. В большинстве <strong>попыток</strong> у вас все будет получаться хорошо, но если же случится промах, то второй игрок поймает мяч и вернёт его на место, чтобы можно было попробовать снова.</p>
<p>С пойманной в <code>catch</code> ошибкой можно поступить как угодно: отправить данные в специальный логгер, обработать данные из неё и даже выбросить новую ошибку, которая может быть поймана в другом месте и т.д.</p>
<h2>Как пишется</h2>
<h3>Базовый случай</h3>
<p>Чтобы использовать <code>try...catch</code>, необходимо в блоке <code>try</code> написать код, который нужно исполнить, а в блоке <code>catch</code> написать, что делать в случае ошибки.</p>
<pre><code class="language-js">try {
  someFunction()
  anotherFunction()
} catch (err) {
  console.log(&quot;Поймали ошибку! Вот она: &quot;, err.message)
}
</code></pre>
<p>Если в блоке <code>try</code> не произошло ошибок, то код в блоке <code>catch</code> <strong>не выполнится</strong>.</p>
<p>Важно помнить, что код в <code>try</code> должен быть <strong>синтаксически верным</strong>. Если написать невалидный код (например, не закрыть фигурные скобки), то скрипт не запустится, потому что JavaScript не поймёт код. Ошибки, которые обработает блок <code>catch</code>, будут ошибками во время выполнения программы.</p>
<p>В случае ошибки выполнение в блоке <code>try</code> прерывается и сразу же переходит в блок <code>catch</code> . После него скрипт продолжит своё выполнение как и прежде.</p>
<pre><code class="language-js">try {
  const six = 6 // 1. Создаём константу
  console.log(six) // 2. Выведет 6

  six = 7 // Ошибка! Присваиваем новое значение в const

  // с этого места управление переходит в catch

  const nine = 9 // не выполнится
  console.log(six + nine) // и это тоже не исполнится
} catch (err) {
  console.log(&quot;Поймали ошибку!&quot;) // 3. Обработали ошибку
}

console.log(&quot;Что ж, можно и продолжать&quot;) // 4. Будет выполняться дальше
</code></pre>
<p><img src="images/try-catch-scheme.png" alt="блок-схема работы try...catch"></p>
<h3>Finally</h3>
<p>Рассмотрим ситуацию, когда в случае успеха или неудачи выполнения какого-то участка кода нам необходимо проводить какие-то действия, чтобы корректно завершить работу скрипта.</p>
<pre><code class="language-js">try {
  // подключаемся к вебсокету, но в конце нужно обязательно отключиться
  webSocket.connect('ws://....')

  callMayThrowError()
} catch (err) {
  ...
}

// Пробуем отключаться после try...catch
webSocket.disconnect('ws://....')
</code></pre>
<p>Казалось бы никаких проблем с этим кодом быть не должно, ведь неважно выполнится код в блоке <code>try</code> правильно или попадёт в <code>catch</code>, следующая строчка должна выполниться. Однако возможна ситуация, что в блоке <code>catch</code> тоже возникнет ошибка, и тогда выполнение следующей строчки уже не случится.</p>
<pre><code class="language-js">function doSomeWithError(e) {
  throw new Error(&quot;new error&quot;)
}

try {
  // подключаемся к вебсокету, но в конце нужно обязательно отключиться
  webSocket.connect(&quot;ws://....&quot;)

  callMayThrowError()
} catch (err) {
  // Здесь тоже может возникнуть ошибка
  doSomeWithError(err)
}

// В случае ошибки эта строчка уже не выполнится
webSocket.disconnect(&quot;ws://....&quot;)
</code></pre>
<p>Как же тогда гарантированно освободить ресурсы при любом исходе выполнения?</p>
<p>В конструкцию <code>try...catch</code> можно добавить блок <code>finally</code>, который выполнится после блоков <code>try</code> и <code>catch</code>. Неважно какой код выполнился в предыдущих блоках, после их завершения (даже если из <code>catch</code> была выброшена новая ошибка) исполнится код в блоке <code>finally</code>.</p>
<pre><code class="language-js">try {
  webSocket.connect(&quot;ws://....&quot;)

  callMayThrowError()
} catch (err) {
  // Здесь тоже может возникнуть ошибка
  doSomeWithError(err)
} finally {
  // Выполнится всегда
  webSocket.disconnect(&quot;ws://....&quot;)
}
</code></pre>
<p><img src="images/try-catch-finally.png" alt="блок-схема try...catch с finally"></p>
<p>Наличие блока <code>finally</code> необязательно. <code>finally</code> можно использовать и без блока <code>catch</code>.</p>
<pre><code class="language-js">try {
  // Отправить данные на сервер, здесь нам неважна обработка ошибки
  sendData()
} finally {
  // Закрыть соединение при любом результате
  closeConnect()
}
</code></pre>
<h3>Ошибки в catch</h3>
<p>Может возникнуть ситуация, когда скрипт обработки ошибки тоже может сломаться. При этом могут возникнуть случаи, когда мы хотим намеренно выбросить новую ошибку из <code>catch</code>, или пробросить текущую, чтобы её обработать в другом месте.</p>
<p>Хорошей практикой считается обрабатывать в модуле только те ошибки, которые связаны непосредственно с ним, а все остальные пробрасывать дальше.</p>
<pre><code class="language-js">// parse-module.js

// Есть свой тип ошибки
class ParsingError extends Error {
  ...
}

function parse(data) {
  try {
    parseData(data)
  } catch (err) {
    if (err.name !== &quot;ParsingError&quot;) {
      // Другой тип ошибок пробрасываем дальше
      throw err
    }

    logError(err)
}
}
</code></pre>
<p>Таким образом, можно разделить ответственность, а обработкой проброшенной ошибки займётся внешний catch.</p>
<pre><code class="language-js">import parse from &quot;parse-module&quot;

try {
  parse(data)
} catch (e) {
  console.log(&quot;Неизвестная ошибка парсинга:&quot;, e)
}
</code></pre>
<h3>Ошибки в асинхронном коде</h3>
<p>Конструкция <code>try...catch</code> работает только синхронно. Таким образом, с помощью <code>try...catch</code> нельзя обработать ошибку, которая возникла в асинхронном коде.</p>
<pre><code class="language-js">try {
  // Код выполнится корректно, т.к. отсюда вернулся промис
  Promise.reject(&quot;err&quot;)
} catch (e) {
  // Ошибка не будет поймана
  console.log(&quot;Ошибка&quot;, e)
}

try {
  // Здесь также код выполнится корректно, потому что установил таймаут без ошибок
  setTimeout(() =&gt; {
    throw Error(&quot;ошибка&quot;)
  }, 1000)
} catch (e) {
  // Ошибка из таймаута также сюда не попадёт
  console.log(&quot;Ошибка&quot;, e)
}
</code></pre>
<p>Однако, если записать асинхронный код в синхронном стиле с помощью <a href="/js/async-await/">async/await</a>, то в этом случае обработку ошибок можно осуществлять с помощью <code>try...catch</code>.</p>
<pre><code class="language-js">async function handlePromise() {
  try {
    // Промис вернется с ошибкой
    await Promise.reject(&quot;err&quot;)
  } catch (e) {
    // Теперь ошибка будет поймана
    console.log(&quot;Ошибка&quot;, e) // err
  }
}

handlePromise()
</code></pre>
<p>Чтобы поймать ошибку из <code>setTimeout</code>, блоки <code>try...catch</code> должны находиться внутри функции.</p>
