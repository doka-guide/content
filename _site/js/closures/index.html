<h2>Кратко</h2>
<p>Мы используем переменные, чтобы хранить в них временные значения, а потом в нужный момент получать к ним доступ.</p>
<p>Но не все переменные в нашем коде одинаково доступны. Доступна ли переменная и как получить к ней доступ, определяют <em>области видимости</em>.</p>
<p><strong>Область видимости</strong> — это часть программы, в которой мы можем обратиться к переменной, функции или объекту. Этой частью может быть функция, блок или вся программа в целом — то есть мы всегда находимся как минимум в одной области видимости.</p>
<p>Области видимости можно представить как коробки, в которые мы кладём переменные. Переменные, которые лежат в одной коробке, могут общаться друг с другом.</p>
<p><img src="images/1.png" alt="Код с одной областью видимости."></p>
<p>Переменные также могут получить доступ к переменным из коробки, в которую вложена их коробка.</p>
<p><img src="images/2.png" alt="Код с вложенными областями видимости."></p>
<p>Области видимости помогают скрывать переменные от нежелательного доступа, управлять побочными эффектами и разбивать код на смысловые блоки.</p>
<p>Но прежде чем мы рассмотрим, как их использовать, разберёмся с тем, какие области видимости в JS вообще есть.</p>
<h2>Глобальная область видимости</h2>
<p><em>Глобальная область видимости</em> — это самая внешняя коробка из всех. Когда мы «просто объявляем переменную», вне функций, вне модулей, то эта переменная попадает в глобальную область видимости.</p>
<pre><code class="language-js">const a = 42
</code></pre>
<p>Переменная в примере сейчас находится в глобальной области видимости. Это значит, что она будет доступна откуда угодно внутри модуля:</p>
<pre><code class="language-js">const a = 42
console.log(a)
// 42

function wrap() {
  const b = a
  // Без проблем, переменная a доступна в этой функции.
}

const c = {
  d: a,
  // Хорошо, переменная a доступна и здесь.
}

function secondWrap() {
  const e = {
    f: a,
    // И тут ок, переменная a всё ещё доступна.
  }
}
</code></pre>
<p>Переменные в глобальной области видимости называются глобальными переменными и доступны всем.</p>
<p>Самый известный пример глобальной переменной — это <code>console</code>.</p>
<pre><code class="language-js">console.log(console)
// Console {debug: function, error: function,
// log: function, info: function, warn: function, …}
</code></pre>
<p>JS в браузерах так устроен, что глобальные переменные попадают в объект <code>window</code>. Если очень грубо, то можно сказать, что <code>window</code> в случае браузера — это и есть глобальная область видимости.</p>
<pre><code class="language-js">console.log(console)
// Console {debug: function, error: function,
// log: function, info: function, warn: function, …}

console.log(window.console)
// Console {debug: function, error: function,
// log: function, info: function, warn: function, …}
// То же самое, потому что это один и тот же объект.
</code></pre>
<p>Глобальный объект <code>window</code> — это объект, который даёт доступ к Web API браузера. <code>window</code> рекурсивно «содержит сам себя», потому что все глобальные объекты находятся в <code>window</code>:</p>
<pre><code class="language-js">console.log(window)
// Window {0: Window, ...}
</code></pre>
<p>Мы также можем определить глобальные переменные сами. Например, если в консоли браузера мы создадим какую-то переменную, а потом попробуем получить к ней доступ через <code>window</code>:</p>
<p><img src="images/3.png" alt="Чтение переменной через глобальный объект window."></p>
<p>Это сработает только с <code>var</code>, но не с <code>let</code> или <code>const</code>. Почему, мы узнаем чуть позже.</p>
<h2>Блочная область видимости</h2>
<p><em>Блочная область видимости</em> ограничена программным блоком, обозначенным при помощи <code>{</code> и <code>}</code>. Простейший пример такой области — это выражение внутри скобок:</p>
<pre><code class="language-js">const a = 42
console.log(a)
// 42

if (true) {
  const b = 43
  console.log(a)
  // 42
  console.log(b)
  // 43
}

console.log(b)
// ReferenceError: Can't find variable: b
</code></pre>
<p>Переменная <code>b</code> скрыта внутри области видимости блока внутри скобок и доступна только внутри этого блока, но не снаружи.</p>
<p>Скобки могут, однако, не только отделять тело условия. Ими можно обрамлять и другие части кода. Это, например, бывает очень полезно в сложных <code>switch</code>-конструкциях. Например:</p>
<pre><code class="language-js">switch (animalType) {
  case 'dog': {
    const legs = 4
    const species = 'mammal'
    break
  }

  case 'fish': {
    const legs = 0
    const swims = true
    break
  }
}
</code></pre>
<p>В примере выше в <code>case</code> нам надо выполнить несколько строчек. Удобно обернуть все операции в блок при помощи фигурных скобок — тогда все переменные и операции будут ограничены этим блоком, то есть блочной областью видимости.</p>
<h2>Функциональная область видимости</h2>
<p><em>Функциональная область видимости</em> — это область видимости в пределах тела функции. Можно сказать, что она ограничена <code>{</code> и <code>}</code> функции.</p>
<pre><code class="language-js">const a = 42

function scoped() {
  const b = 43
}

console.log(a)
// 42
console.log(b)
// Reference error.
</code></pre>
<p>К переменной <code>b</code> есть доступ только внутри функции <code>scoped</code>.</p>
<p>Функциональная область видимости — очень мощный инструмент для разделения кода. Во-первых, используя её, мы можем не опасаться за «пересечение имён» переменных.</p>
<p>В одной области видимости объявить дважды <code>let</code> или <code>const</code> нельзя:</p>
<pre><code class="language-js">const a = 42
const a = 43
// SyntaxError: Cannot declare a const variable twice: 'a'.
</code></pre>
<p>Но функции создают собственные области видимости, которые не пересекаются, поэтому в этом случае ошибки не будет:</p>
<pre><code class="language-js">function scope1() {
  const a = 42
}

function scope2() {
  const a = 43
}
</code></pre>
<p>Так как области видимости у функций не пересекаются и не связаны, первая функция не может обратиться к «внутренностям» соседней или вложенной функции, внутренности соседней функции скрыты в её области видимости и недоступны вне её:</p>
<pre><code class="language-js">function scope1() {
  const a = 42
}

function scope2() {
  console.log(a)
  // Reference error
}
</code></pre>
<p>То же и с дочерними областями:</p>
<pre><code class="language-js">function outer() {
  function inner() {
    const a = 42
  }

  console.log(a)
  // Reference error
}
</code></pre>
<p>Функциям доступны лишь переменные в её собственной области видимости (всё, что внутри её тела) и в родительских областях:</p>
<pre><code class="language-js">function outer() {
  const a = 42

  function inner() {
    console.log(a)
    // 42
  }
}
</code></pre>
<p>Здесь ошибки нет, потому что функции доступна своя область видимости, а также область видимости функции <code>outer</code>.</p>
<p>Такое поведение, когда переменные родительских областей становятся доступны в дочерних, называется наследованием областей видимости.</p>
<p>Заметим, что у функции <code>inner</code> никаких локальных переменных нет — она работает только с локальной переменной функции <code>outer</code>.</p>
<p>Такой особенный доступ к локальным переменным родительской функции часто называют <em>лексической областью видимости</em>.</p>
<p>Сокрытие «внутренностей» позволяет создавать независимые друг от друга блоки кода. Это, например, полезно, когда мы хотим запустить какой-то модуль в браузере с уверенностью, что он никак не повлияет на другой код.</p>
<h3>Изоляция модулей с помощью IIFE</h3>
<p>Immediately Invoked Function Expression, IIFE — это функция, которая выполняется сразу же после того, как была определена.</p>
<p>Записывается IIFE так:</p>
<pre><code class="language-js">;(function () {
  // ...Тело функции
})()
</code></pre>
<p>Разберём по частям.</p>
<ol>
<li>Сама функция внутри:</li>
</ol>
<p><code>function () { ... }</code></p>
<p>Это обычная функция, которая описывается и ведёт себя по всем правилам функций в JS.</p>
<ol start="2">
<li>Скобки вокруг функции:</li>
</ol>
<p><code>(function() { ... })</code></p>
<p>Скобки превращают функцию в выражение, которое можно вызвать. То есть если до этого шага мы функцию объявили, то на этом шаге мы приготовили её к мгновенному вызову.</p>
<ol start="3">
<li>Скобки вызова:</li>
</ol>
<p><code>(function() { ... })()</code></p>
<p>Последняя пара скобок вызывает выражение, то есть вызывает функцию, которую мы создали на 1-м шаге и подготовили на 2-м.</p>
<p>Так как функция внутри скобок — это обычная функция, она точно так же создаёт внутри себя область видимости, доступ к которой есть только у неё. То есть всё, что внутри функции, остаётся внутри.</p>
<p>При помощи IIFE мы можем использовать одинаковые названия переменных, не боясь, что они случайно перезапишут значения переменных из чужих модулей, если мы не контролируем кодовую базу полностью сами.</p>
<pre><code class="language-js">;(function module1() {
  const a = 42
  console.log(a)
})()
;(function module2() {
  const a = '43!'
  alert(a)
})()
</code></pre>
<p>Никаких конфликтов имён!</p>
<h3>Функции внутри функций и замыкания</h3>
<p>Как мы видели выше, у дочерней функции есть доступ к области видимости родительской функции:</p>
<pre><code class="language-js">function outer() {
  let a = 42

  function inner() {
    console.log(a)
  }

  inner()
}

outer()
// 42
</code></pre>
<p>Всё так же у функции <code>inner</code> локальных переменных нет, она лишь использует локальные переменные родительской функции <code>outer</code>. И всё так же у кода снаружи <code>outer</code> нет никакого доступа к её внутренностям.</p>
<p>Но что, если мы вернём из функции <code>outer</code> функцию <code>inner</code>?</p>
<pre><code class="language-js">function outer() {
  let a = 42

  function inner() {
    console.log(a)
  }

  return inner
}
</code></pre>
<p>Теперь мы можем не просто вызывать функцию <code>outer</code>, но и присвоить результат вызова какой-то переменной:</p>
<pre><code class="language-js">const accessToInner = outer()

accessToInner()
// 42
</code></pre>
<p>Теперь в переменной <code>accessToInner</code> находится функция <code>inner</code>, у которой всё ещё есть доступ к локальной переменной <code>a</code> функции <code>outer</code>!</p>
<p>То есть мы смогли «обойти» область видимости? Не совсем.</p>
<p>Мы действительно получили доступ к переменной <code>a</code> через функцию <code>inner</code>, но только в том виде и с такими ограничениями, которые описаны при создании функции <code>inner</code>.</p>
<p>У нас всё ещё нет прямого доступа к переменной <code>a</code>. Мы, например, не можем её поменять — только вывести в консоль.</p>
<p>Грубо говоря, мы создали функцию, которая даёт нам <em>читать</em> переменные, но <em>не изменять</em> их. Это полезно, если мы хотим дать ограниченный доступ к внутренностям модуля.</p>
<p>Допустим, мы хотим сделать счётчик, который можно увеличивать и уменьшать только на единицу:</p>
<pre><code class="language-js">function counter() {
  // Начальное значение счётчика будет 0.
  // Мы используем let, потому что будем менять значение,
  // const не подойдёт.
  let state = 0

  // Функция increase будет увеличивать счётчик на единицу.
  function increase() {
    state++
  }

  // Функция decrease будет уменьшать счётчик на единицу.
  function decrease() {
    state--
  }

  // Функция valueOf будет выводить значение.
  function valueOf() {
    console.log(state)
  }

  // А наружу мы дадим только лишь доступ к этим функциям.
  // Вернём объект, значениями полей которого будут функции
  // increase и decrease.
  //
  // Прямого доступа к переменной state всё ещё нет,
  // но внешний код может изменять её состояние опосредованно —
  // через функции increase и decrease.
  return {
    increase,
    decrease,
    valueOf,
  }
}

const ticktock = counter()
ticktock.increase()
ticktock.valueOf()
// 1
ticktock.increase()
ticktock.valueOf()
// 2
ticktock.decrease()
ticktock.valueOf()
// 1
</code></pre>
<p>Такое контролируемое сокрытие доступа с помощью области видимости называется <em>замыканием</em>.</p>
<p>Замыкания удобны тем, что <em>каждый новый вызов создаёт отдельную область</em>, в которой значения абсолютно независимы друг от друга:</p>
<pre><code class="language-js">const tick1 = counter()
const tick2 = counter()

tick1.valueOf()
// 0
tick2.valueOf()
// 0

tick1.increase()
tick1.valueOf()
// 1
tick2.valueOf()
// 0

tick1.increase()
tick1.valueOf()
// 2
tick2.valueOf()
// 0

tick2.increase()
tick1.valueOf()
// 2
tick2.valueOf()
// 1

tick2.decrease()
tick1.valueOf()
// 2
tick2.valueOf()
// 0
</code></pre>
<p>Состояния обоих счётчиков друг от друга не зависят, хотя они создаются одной и той же функцией.</p>
<h2>«Поднятие» переменных (hoisting)</h2>
<p>Выше, когда мы экспериментировали с <code>window</code> и глобальными переменными, мы обговорили, что запись:</p>
<pre><code class="language-js">var hi = 'Hello world!'
console.log(window.hi)
// Hello world!
</code></pre>
<p>...сработает только с <code>var</code>, но не с <code>let</code> или <code>const</code>. Дело здесь в «поднятии» переменных (<em>hoisting</em>).</p>
<p>Для начала посмотрим на такой код:</p>
<pre><code class="language-js">function scope() {
  a = 42
  var b = 43
}

scope()

console.log(a)
// 42
console.log(b)
// Reference error
</code></pre>
<p>Что произошло?</p>
<p>Чтобы понять, почему доступ к переменной <code>a</code> не вызывал ошибки, разберёмся, как работает <code>var</code> и объявление переменных.</p>
<p>Так как переменная <code>a</code> не была объявлена, то JavaScript сам решил, где объявлять переменную, и «поднял» объявление наверх. Получился вот такой код:</p>
<pre><code class="language-js">var a

function scope() {
  a = 42
  var b = 43
}

scope()
console.log(a)
// 42
</code></pre>
<p>Более того, переменные «поднимаются» и внутри блоков и функций:</p>
<pre><code class="language-js">console.log(hello)
// undefined

var hello = 'Hello'
console.log(hello)
// Hello
</code></pre>
<p>Потому что на самом деле код превращается вот в это:</p>
<pre><code class="language-js">var hello
console.log(hello)
// undefined

hello = 'Hello'
console.log(hello)
// Hello
</code></pre>
<p>В браузере глобальные переменные находятся в области <code>window</code>, поэтому трюк с <code>window.hi</code> сработал — JS «поднял» переменную до глобальной области, а мы потом установили ей значение.</p>
<h3>Проблема</h3>
<p>На самом деле это большая проблема, потому что о «поднятии» легко забыть и случайно перезаписать значение переменной в ненужный момент.</p>
<pre><code class="language-js">a = 42

function shouldNotAffectOuterScopeButDoes() {
  a = 43
  console.log(a)
  // 43
}

shouldNotAffectOuterScopeButDoes()

console.log(a)
// 43 (хотя должно было быть 42)
</code></pre>
<h3>Как бороться</h3>
<p>Первым оружием против этой проблемы стал <a href="/js/use-strict/">строгий режим</a>.</p>
<p>Он запрещает объявлять переменные без <code>var</code>, что не позволит случайно перезаписать необъявленную переменную или переменную из внешней области.</p>
<p>Но механизм «поднятия» даже внутри блока достаточно непредсказуемый. Идеально было бы, если бы переменные объявлялись и инициализировались там, где это указано в коде.</p>
<p>И именно это делают <code>let</code> и <code>const</code>. Они <em>никогда не выходят из области видимости</em>, где были определены и <em>всегда инициализируются там, где указано</em>.</p>
<p>С <code>var</code> сработает:</p>
<pre><code class="language-js">console.log(hello)
// undefined
var hello = 'Hello'
</code></pre>
<p>C <code>let</code> и <code>const</code> — нет:</p>
<pre><code class="language-js">console.log(hello)
// Reference error
let hello = 'Hello'

console.log(bye)
// Reference error
const bye = 'Bye'
</code></pre>
