<h2>Кратко</h2>
<p>Когда пользователь уходит со страницы, генерируется событие <code>unload</code>. Мы можем отреагировать на него, <a href="/js/events/">подписавшись на это событие</a> у объекта <code>window</code>.</p>
<h2>Как пишется</h2>
<pre><code class="language-js">window.addEventListener('unload', function () {
  // ...
})
</code></pre>
<h2>Как это понять</h2>
<p>В современном вебе всё увешано трекингом: клики, переходы, прокрутка до определённых секций и ещё куча всего. Почему бы не трекать уход пользователя со страницы?</p>
<pre><code class="language-js">window.addEventListener('unload', function () {
  const someUsefulData = getSomeUsefulData();

  navigator.sendBeacon('/some-endpoint', someUsefulData);
})
</code></pre>
<p>Что происходит в коде выше? Когда пользователь покинет страницу, функция <code>getSomeUsefulData</code> соберёт аналитическую информацию, а метод <code>sendBeacon</code> отправит её по адресу <code>/some-endpoint</code>. Метод <code>sendBeacon</code> — это неблокирующий метод отправки данных. Он находится в состоянии <a href="https://w3c.github.io/beacon/">черновика</a> и ещё не принят как стандарт W3C, но уже давно <a href="https://caniuse.com/?search=sendbeacon">поддерживается всеми браузерами</a>.</p>
<blockquote>
<p>Неблокирующая отправка означает, что она будет выполнена асинхронно и не будет мешать выгрузке текущей страницы и загрузке следующей.
Раньше разработчики использовали <s>костыльные</s> специальные техники, чтобы отправить что-либо в момент закрытия страницы, например:</p>
<ul>
<li>Синхронные вызовы <code>XMLHttpRequest</code>.</li>
<li>Картинки со специальными <code>src</code> (так называемые пиксели).</li>
<li>Иногда даже создавались пустые циклы на несколько секунд.</li>
</ul>
<p>Метод <code>sendBeacon</code> позволяет надёжно и асинхронно отправить данные, не мешая нормальному ходу вещей.</p>
</blockquote>
