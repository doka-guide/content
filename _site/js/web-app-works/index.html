<h2>Кратко</h2>
<p>Веб-приложения, которыми мы пользуемся каждый день, хоть и сильно отличаются под капотом, на высоком уровне по большей части похожи.</p>
<p>В этой статье мы рассмотрим, как работают веб-приложения, что такое клиент-серверная архитектура и какие технологии используются для общения клиента и сервера.</p>
<p>Любое веб-приложение, если оно работает в браузере, работает на 3 основных технологиях: HTML, CSS и JS. <em>Ещё есть WASM, но о нём в этой статье мы говорить не будем.</em></p>
<p>Все приложения, которыми вы пользуетесь в браузере: GoogleDocs, Notion, Яндекс.Карты, Spotify, YouTube — сделаны с помощью этих технологий.</p>
<p>Но любое сложное приложение — это не только картинка в браузере, это ещё и данные, которые пользователи используют или создают. Эти данные нужно уметь хранить, обрабатывать и выводить.</p>
<p>Хранением и обработкой данных обычно занимается сервер или бэкенд.</p>
<p><em>Бэкенд</em> — область веб-технологий, работающих на сервере, а также внутренняя часть серверной системы, занимается обработкой данных.</p>
<p>А архитектура, в которой участвуют сервер (бэкенд) и клиент (браузер, фронтенд) называется <em>клиент-серверной</em>.</p>
<h2>Клиент-серверная архитектура</h2>
<p>Начнём с самого понятия.</p>
<p><em>Архитектура</em> — это описание системы на самом высоком уровне.</p>
<p>То есть при описании архитектуры мы не вдаёмся в подробности каждого конкретного модуля, а скорее описываем их взаимодействие между собой, «фиксируем договорённости» поведения каждого из них.</p>
<p><em>Клиент-серверная архитектура</em> описывает, как взаимодействуют между собой клиент (в нашем случае фронтенд) и сервер (бэкенд).</p>
<p>Самый канонический вид такой архитектуры таков:</p>
<p><img src="images/client-server.png" alt="схема клиент-серверной архитектуры"></p>
<h3>Клиент</h3>
<p>Клиент обращается с запросами к серверу.</p>
<p>Запросы могут быть разные. Клиент может попросить сервер отдать какие-то данные или попросить их как-то подготовить перед отдачей. Или же может попросить сервер сохранить что-то, что передаст вместе с запросом сам.</p>
<p>Роль клиента <em>для сервера</em> в том, чтобы сообщить серверу, что нужно сделать с данными, которые хранятся в базе, или с данными, которые он передаёт.</p>
<p>Роль клиента <em>для пользователя</em> в том, чтобы представить данные в удобном виде и предоставить механизмы для их обновления.</p>
<p>Для веба клиент почти всегда браузер.</p>
<h3>Сервер</h3>
<p>Сервер принимает запросы от клиента.</p>
<p>Его роль в том, чтобы сохранять информацию от клиента в базе данных, обрабатывать её и предоставлять к ней доступ по некоторым правилам. <em>Такие правила обычно называются бизнес-логикой.</em></p>
<p>На сервере помимо общения с клиентом могут запускаться какие-то фоновые задачи, например, индексирование информации в базе данных для более быстрого поиска, или запуск автоматических email-рассылок.</p>
<h3>База данных</h3>
<p>База данных (БД) — это хранилище всей пользовательской и служебной информации.</p>
<p>Её роль в том, чтобы обеспечивать быстрый и бесперебойный доступ к этой информации и собственно хранение.</p>
<h3>Пример</h3>
<p>Возьмём Твиттер. В этом приложении клиентом будет выступать весь его фронтенд: HTML-страницы, CSS-стили, JS-скрипты для взаимодействия пользователя с UI.</p>
<p>Сервером будет его бэкенд. Все технологии, которые используются, чтобы предоставлять информацию из баз данных клиенту через API.</p>
<p>Базами данных (в множественном числе, потому что их много) будут все технологии, которые занимаются хранением, дупликацией, резервированием данных и обеспечением бесперебойной работы.</p>
<h2>Развитие веб-приложений</h2>
<p>На клиент-серверной архитектуре построена большая часть приложений. Однако первые приложения всё же немного отличались от нынешних в деталях реализации. Главным отличием была полная перезагрузка страницы в ответ на любое действие.</p>
<h3>Первые приложения</h3>
<p>Самые первые веб-приложения не сильно отличались от обычных сайтов.</p>
<p>По сути это и были сайты, потому что вся бизнес-логика реализовывалась на сервере. Клиент лишь показывал результат в виде HTML-страниц пользователю и посылал запросы на другие страницы.</p>
<p>Банальный выбор сортировки списка или таблицы требовал перезагрузки страницы. Сейчас это кажется анахронизмом, но первые приложения работали исключительно таким образом просто потому, что в браузерах не было инструмента для альтернативного общения.</p>
<p>В начале нулевых появился так называемый «Веб 2.0», с которым пришёл AJAX.</p>
<h3>AJAX</h3>
<p><em>AJAX (Asynchronous JavaScript and XML)</em> — общение между клиентом и сервером без перезагрузки страницы.</p>
<p>Когда мы говорим, что какое-то приложение использует AJAX, мы имеем в виду, что при нажатии, например, на кнопку сортировки списка или таблицы, страница не перезагрузится, а сортировка произойдёт как бы «в фоне».</p>
<p>При нажатии браузер пошлёт запрос на сервер, в котором сообщит, что ему необходимо отсортировать такой-то список по такому-то критерию.</p>
<p>Сервер обработает запрос, достанет нужные данные, отсортирует их и отправит клиенту <em>готовый кусок интерфейса</em>, который клиент уже вставит в документ.</p>
<p>Заметьте, что мы всё ещё не передаём данные в чистом виде. Сейчас на клиенте мы принимаем <em>кусок HTML-разметки</em>, который потом встраиваем в нужное место в документе.</p>
<p>Это, безусловно, удобнее для пользователя, чем перезагружать страницу в целом, но всё ещё не идеальный вариант для разработчиков.</p>
<h3>Современные приложения</h3>
<p>В современных приложениях между клиентом и сервером общение строится именно на данных, а не на отрендеренных кусках разметки. Чаще всего для такого общения выбирают <a href="/tools/json/">JSON</a>.</p>
<p>Сейчас большая часть приложений работает так:</p>
<!-- prettier-ignore -->
<ol>
<li>Клиент делает первичный запрос на сервер.</li>
<li>Сервер отвечает HTML-страницей, иногда с набором каких-то данных внедрённых в виде JS-объекта в конце страницы.
<ol>
<li>Страница может быть либо отрисована на сервере и тогда клиенту придёт готовый HTML.</li>
<li>Либо отрисовкой будет заниматься сам клиент с помощью какой-нибудь библиотеки, например, React. В этом случае от сервера приходит просто набор необходимых данных.</li>
</ol>
</li>
<li>Пользователь совершает какое-то действие, например, просит отсортировать таблицу.</li>
<li>Клиент в ответ на это действие решает, какой запрос отправить на сервер, строит этот запрос и отправляет его.</li>
<li>Сервер принимает этот запрос, обрабатывает его и отправляет на клиент порцию новых данных.</li>
<li>Клиент принимает данные и перерисовывает часть страницы по ним сам. То есть он уже не заменяет один кусок разметки другим готовым, а рисует разметку сам.</li>
</ol>
<p>Плюсов такого общения (когда передаются только данные) несколько:</p>
<ul>
<li><em>Сервер и клиент становятся независимыми друг от друга</em>. Сервер может ничего не знать об устройстве страниц, ему достаточно лишь уметь работать с БД и обрабатывать данные (первичная отрисовка может быть сделана самим сервером с помощью SSR).</li>
<li><em>Количество информации, которое приходится передавать и принимать, меньше</em> — а это уменьшает объём трафика.</li>
<li><em>Логика приложения на сервере может быть проще</em>, потому он и клиент становятся менее зависимы друг от друга в плане формата данных.</li>
</ul>
<h2>Разделение ответственности</h2>
<p>Такое общение между сервером и клиентом очень напоминает паттерн MVC.</p>
<p><em>MVC (Model-View-Controller)</em> — структура приложения, в которой за данные, их обработку и их вывод отвечают три разных сущности.</p>
<ul>
<li>Модель (model) отвечает за данные и их структуру.</li>
<li>Представление (view) — за их отображение.</li>
<li>Контроллер (controller) — за их обработку.</li>
</ul>
<p><img src="images/mvc.png" alt="схема паттерна Model View Controller"></p>
<p>Если попробовать сравнить классическую клиент-серверную архитектуру с MVC, то можно сравнить БД с моделью, сервер с контроллером, а клиент с представлением.</p>
<p>В самых первых приложениях, в принципе, так и было. Сейчас, однако, клиент стал сложнее, поэтому MVC может быть и часть архитектуры клиентского приложения.</p>
<h2>MVC на клиенте</h2>
<p>Возьмём для примера Notion. Его веб-версия работает прямо в браузере, однако это полноценный текстовый редактор.</p>
<p>Большая часть работы при вводе текста происходит на клиенте. Чтобы такие сложные приложения работали, а в их коде можно было разобраться, клиентский код разработчики тоже стараются писать по правилам и следуя лучшим архитектурным практикам.</p>
<p>Одной из таких практик как раз является разделение данных и представления.</p>
<h3>Как бы текстовый редактор сделали 20 лет назад</h3>
<p>Если забыть про невозможность сохранить написанное на сервере, то попробовать написать текстовый редактор можно было и тогда. Но, скорее всего, результатом был бы кусок разметки с инлайновыми стилями и текстом внутри.</p>
<p>Работать такими данными, которые перемешаны с особенностями представления, не удобно, а иногда и невозможно.</p>
<h3>Текстовые редакторы сейчас</h3>
<p>...чаще всего делают, разделяя данные от их представления.</p>
<p>Так нам больше не нужно находить текст и чистить его от стилей, потому что в нём содержится только текст и некоторые его атрибуты.</p>
<ol>
<li>Это делает работу с данными сильно проще — можно выгрузить документ в разных форматах: <code>.md</code>, <code>.html</code>, <code>.txt</code>.</li>
<li>С таким представлением проще работать в самом коде — отчего и сам код становится проще для понимания.</li>
<li>Его удобнее хранить в памяти, как состояние приложения.</li>
</ol>
<h2>Состояние приложения</h2>
<p>Текстовый редактор из нашего примера выше — это приложение с состоянием.</p>
<p><em>Состояние приложения</em> — это все данные этого приложения на текущий момент.</p>
<p>В случае с текстовым редактором — это весь текст, который пользователь ввёл, а также результаты преобразований над этим текстом.</p>
<p>Разумеется, текстовые редакторы не единственный вид таких приложений. Любое приложение, <em>которое хранит что-то перед отправкой (или даже без отправки) на сервер</em> — это приложение с состоянием.</p>
<p>Плюсы в выделении состояния те же:</p>
<ul>
<li>данные перестают зависеть от того, как мы хотим их представлять;</li>
<li>их проще обрабатывать и хранить;</li>
<li>представление проще менять.</li>
</ul>
<p>Как правило, состояние в приложениях на JS — это какой-то объект или массив объектов в памяти.</p>
<pre><code class="language-js">// Например, так могло бы выглядеть
// состояние текстового редактора:
const State = {
  lastModified: &quot;2020-08-24T18:15:00&quot;,
  blocks: [
    {
      type: &quot;heading&quot;,
      data: {
        text: &quot;Какой-то заголовок&quot;,
      },
    },
    {
      type: &quot;paragraph&quot;,
      data: {
        text: &quot;Какой-то параграф текста под заголовком&quot;,
      },
    },
  ],
}
</code></pre>
<p>Такой вид состояния не только удобен в использовании внутри приложения, но ещё и прост в сохранении с помощью <a href="/tools/json/">JSON</a>.</p>
<p>Кроме этого приложения, в которых за состояние отвечает отдельный модуль, проще развивать и изменять.</p>
<p>Сейчас есть много подходов и инструментов для управления состоянием. Из самых популярных можно назвать: Redux (и основанные на его подходе Vuex, NgRx), MobX, Overmind.</p>
<h2>JSON</h2>
<p>JSON — один из самых популярных форматов данных. Он немногословен, понятен и человеку, и компьютеру, много языков с ним уже умеют работать.</p>
<p>В вебе JSON, можно сказать, стандарт, потому что используется как формат по умолчанию во многих фреймворках.</p>
<p>Состояние из примера выше в формате JSON выглядело бы так:</p>
<pre><code class="language-json">{
  &quot;lastModified&quot;: &quot;2020-08-24T18:15:00&quot;,
  &quot;blocks&quot;: [
    {
      &quot;type&quot;: &quot;heading&quot;,
      &quot;data&quot;: {
        &quot;text&quot;: &quot;Какой-то заголовок&quot;
      }
    },
    {
      &quot;type&quot;: &quot;paragraph&quot;,
      &quot;data&quot;: {
        &quot;text&quot;: &quot;Какой-то параграф текста под заголовком&quot;
      }
    }
  ]
}
</code></pre>
<p>...и мы могли бы прямо в таком виде отправить его на сервер, чтобы сохранить в БД.</p>
<h2>Запросы и ответы</h2>
<p>Как мы помним, клиент-серверная архитектура строится на запросах и ответах. Разберёмся, что использует браузер, чтобы послать на сервер какой-то запрос.</p>
<h3><code>fetch</code></h3>
<p>На уровне приложения мы используем встроенное браузерное API, а именно — <a href="/js/fetch/"><code>fetch</code></a>. Это глобальный метод для отправки запросов.</p>
<p>В примере выше, чтобы сохранить состояние на сервере, мы бы использовали его примерно так:</p>
<pre><code class="language-js">const response = await fetch(&quot;/api/save-text&quot;, {
  method: &quot;POST&quot;,
  body: JSON.stringify(State),
})
</code></pre>
<p>Здесь мы отправляем запрос по адресу <code>/api/save-text</code> с телом <code>JSON.stringify(State)</code>. Адрес и тело (данные) — понятно, а что такое <code>method: &quot;POST&quot;</code>?</p>
<h3>HTTP-глаголы</h3>
<p>Поле <code>method</code> — это так называемый HTTP-глагол.</p>
<p>HTTP-<em>глагол</em>, потому что его значениями могут быть лишь <code>GET</code>, <code>POST</code>, <code>PATCH</code>, <code>PUT</code>, <code>DELETE</code> и ещё несколько не так часто и явно используемых глаголов.</p>
<p>Они указывают, какое действие мы хотим выполнить. В примере <code>method: &quot;POST&quot;</code> сообщит серверу, что мы хотим создать новый ресурс и сохранить в него содержимое <code>body</code>.</p>
<p>Если бы мы хотели получить какой-то ресурс, мы бы использовали <code>GET</code>. Для редактирования — <code>PATCH</code>, для замены — <code>PUT</code>, а для удаления — <code>DELETE</code>.</p>
<p><em>HTTP</em>-глагол, потому что используется в протоколе HTTP — протоколе передачи данных, которым по умолчанию пользуются браузеры при общении с сервером.</p>
<p><em>Описывать <a href="https://tools.ietf.org/html/rfc7231">сам протокол</a> мы не будем, это большая спецификация, для которой бы понадобилась отдельная статья.</em></p>
<h3>REST</h3>
<p>Внимательные читатели могли заметить, что список HTTP-глаголов выше похож на список методов из <code>RESTful API</code>.</p>
<p><em>REST (Representational State Transfer)</em> — стиль общения компонентов, при котором все необходимые данные указываются в параметрах запроса.</p>
<p>Отличительная особенность этого стиля — это стиль построения адресов и выбор метода.</p>
<pre><code class="language-js">// Например, метод и адрес для создания пользователя
// могли бы выглядеть так:
// POST /api/users

// Для получения конкретного пользователя:
// GET /api/users/1
// (Где 1 — это ID пользователя.)

// Для редактирования данных о пользователе:
// PATCH /api/users/1

// Для удаления данных:
// DELETE /api/users/1
</code></pre>
<p>Как мы можем видеть, основа адреса не меняется, а желаемое действие выражается методом.</p>
<p>Списки HTTP-глаголов и REST-методов действительно похожи, потому что REST основывается на HTTP 1.0. Метод — это один из параметров запроса в REST.</p>
<p>Сейчас именно на основе REST работает множество сервисов и приложений.</p>
<h2>Развитие веба и объёмы данных</h2>
<p>С развитием веба и интернета в целом пришло время больших объёмов данных. Картинки по 10 МБ уже никого не удивляют.</p>
<p>Вместе с большими объёмами пришли и проблемы с их передачей, потому что трафик поначалу был очень дорогим. <em>Он и сейчас в некоторых случаях не дешёвый.</em></p>
<h3>Кэширование</h3>
<p>Отчасти решением стало кэширование ресурсов. С картинками это помогло — картинки из кэша не съедают трафик, потому что не гонятся по сети.</p>
<p>Со скриптами и стилями — помогло отчасти, потому что объём лишь одна часть проблемы. Вторая часть — это парсинг и исполнение. Особенно остро эта проблема стоит со скриптами, потому что скрипты весом в 10 МБ уже тоже не редкость.</p>
<p>Сейчас разработчики всеми силами стараются уменьшать количество кода, которое браузеру необходимо скачать и исполнить, чтобы сделать приложения быстрее и легче.</p>
<h3>Код-сплиттинг</h3>
<p>Одним из решений стал код-сплиттинг. Это техника, при которой в скрипте оказывается только необходимый на конкретной странице код, а остальной код догружается по мере необходимости.</p>
<h3>Middle-end</h3>
<p>Кэширование и код-сплиттинг решают большую часть проблем, однако остаётся ещё одно место, где мы можем передавать слишком много лишней информации — сами запросы.</p>
<p>REST известен не только своим удобством, но и (иногда) чрезмерной избыточностью.</p>
<p>Проблема в том, что REST система проектируется так, чтобы как можно реже меняться при изменении клиента. Из-за этого данные, отдаваемые в ответ, могут содержать детали, которые клиентом использоваться не будут.</p>
<p>Просто так их убрать зачастую бывает нельзя, потому что это противоречит обратной совместимости. Плодить много однотипных эндпоинтов, которые будут отличаться небольшой деталью — дорого и нецелесообразно.</p>
<p>Поэтому сейчас сообщество смотрит в сторону некого мидл-энда — такого слоя между клиентом и сервером (или сразу БД), который бы удалял всё лишнее, что клиенту не требуется, и отдавал бы лишь необходимые данные, таким образом сократив объём. Как, например, GraphQL.</p>
<h2>Заключение</h2>
<p>В этой статье мы рассмотрели лишь самые основы работы веб-приложений, не затрагивая деталей.</p>
<p>Мы узнали о клиент-серверной архитектуре, разделении данных от представления и том, как они используются в современных приложениях. Также мы рассмотрели, что такое состояние приложения и поговорили о REST, как одном из распространённых способов построения API.</p>
<p>Эти понятия помогут вам понять работу большей части приложений, с которыми вы можете столкнуться.</p>
