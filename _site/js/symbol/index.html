<h2>Кратко</h2>
<p>Символ (Symbol) — примитивный тип, значения которого создаются с помощью вызова функции <code>Symbol</code>. Каждый созданный символ уникален.</p>
<p>Символы могут использоваться в качестве имён свойств в объектах. Символьные свойства могут быть прочитаны только при прямом обращении и не видны при обычных операциях.</p>
<h2>Как пишется</h2>
<h3>Создание</h3>
<p>Для создания символа нужно вызвать функцию <code>Symbol</code>:</p>
<pre><code class="language-js">const sym = Symbol()
const symTwo = Symbol()

console.log(sym === symTwo)
// false
</code></pre>
<aside>
<p>⚠️ Создание символа через конструктор <code>new Symbol()</code> не поддерживается.</p>
</aside>
<p>При создании символа первым аргументом можно передать его описание. Оно ни на что не влияет и необходимо только для отладки. <em>Даже если описания символов совпадают, JavaScript всё равно создаёт уникальные символы</em>:</p>
<pre><code class="language-js">const sym = Symbol('name')
const symTwo = Symbol('name')

console.log(sym === symTwo)
// false
</code></pre>
<h3>Использование</h3>
<p>Символы используются для создания скрытых свойств объектов. В отличие от свойств, ключом которых является строка, символьные свойства может читать только владелец символа. Скрытые свойства не видны при его обходе с помощью <a href="/js/for-in/"><code>for...in</code></a>:</p>
<pre><code class="language-js">const secondaryId = Symbol()

const user = {
  'id': 193,
  'name': 'Ольга',
  [secondaryId]: 'olga-1'
}

for (const prop in user) {
  console.log(prop, user[prop])
}
// id 193
// name Ольга

console.log(user[secondaryId])
// olga-1
</code></pre>
<p>Это может пригодиться, когда необходимо добавить свойства объекту, который могут модифицировать другие части программы. Таким образом только вы сможете читать созданное свойство, а гарантия уникальности символов гарантирует и отсутствие конфликтов имён.</p>
<h3>Системные символы</h3>
<p>Символы активно используются внутри самого JavaScript чтобы определять поведение объектов. Такие символы называются «хорошо известными» (well-known symbols).</p>
<p>Самый известный символ <code>Symbol.iterator</code>, который позволяет реализовать обход конструкции с помощью синтаксических конструкций <code>for..of</code> и <a href="/js/spread/">спред-синтаксиса</a>.</p>
<p>Полный список таких символов доступен в <a href="https://tc39.es/ecma262/#sec-well-known-symbols">спецификации</a>, но на практике он нужен нечасто.</p>
<h3>Глобальный реестр символов</h3>
<p>Созданный символ уникален, но как быть, если он нужен в нескольких местах программы? Для решения этой проблемы существует глобальный реестр символов, он хранит символы по строковым ключам. При обращении по ключу всегда будет возвращаться один и тот же символ.</p>
<p>Работа с реестром символов организована с помощью двух методов:</p>
<ul>
<li><code>Symbol.for(ключ)</code> — возвращает символ, хранящийся по ключу. Если символа ещё не существует, он создаётся автоматически.</li>
<li><code>Symbol.keyFor(символ)</code> — возвращает строковый ключ, который хранит переданный символ или <code>undefined</code>, если символ не хранится в реестре.</li>
</ul>
<pre><code class="language-js">const secondaryId = Symbol()

const user = {
  'id': 193,
  'name': 'Ольга',
  [secondaryId]: 'olga-1'
}

console.log(Symbol.keyFor(secondaryId))
// undefined

const newSym = Symbol.for('registryKey')
const newestSym = Symbol.for('registryKey')
console.log(newSym === newestSym)
// true

user[newSym] = 'hello'
console.log(Symbol.keyFor(newSym))
// registryKey
</code></pre>
