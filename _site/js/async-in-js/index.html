<h2>Кратко</h2>
<p>Чтобы понять, что такое асинхронность, сперва поговорим о синхронном коде и том, как в принципе JavaScript выполняет код.</p>
<p>Чтобы выполнить код, нам нужен <em>JavaScript Engine (движок)</em> — программа, которая «читает и выполняет» то, что мы написали. Самый распространённый движок среди всех — это V8, он используется в Google Chrome и Node.js.</p>
<p>Выполнение JS-кода — однопоточное. Это значит, что в конкретный момент времени движок может выполнять <em>не более одной</em> строки кода. То есть, вторая строка не будет выполнена, пока не выполнится первая.</p>
<p>Такое выполнение кода (строка за строкой) называется синхронным.</p>
<h2>Синхронный код и его проблемы</h2>
<p>Синхронный код понятный, его удобно читать, потому что он выполняется ровно так, как написан:</p>
<pre><code class="language-js">console.log(&quot;A&quot;)
console.log(&quot;B&quot;)
console.log(&quot;C&quot;)
</code></pre>
<p>Выведется:</p>
<pre><code>A
B
C
</code></pre>
<p>Никаких сюрпризов: в каком порядке команды указаны — в таком они и выполнились.</p>
<p>Однако с ним могут возникать некоторые проблемы. Представим, что нам нужно выполнить какую-то операцию, требующую некоторого времени — например, напечатать в консоли приветствие, но не сразу, а через 5 секунд. Ниже псевдокод — синхронная функция задержки <code>delay()</code> вымышленная:</p>
<pre><code class="language-js">function greet() {
  console.log(&quot;Hello!&quot;)
}

delay(5000)
greet()
</code></pre>
<p>Через 5 секунд бездействия вывелось бы:</p>
<pre><code>Hello!
</code></pre>
<p>И всё вроде хорошо, приветствие бы действительно напечаталось спустя 5 секунд, однако проблема здесь в другом.</p>
<p>Если бы мы запустили <em>синхронную функцию задержки</em> <code>delay()</code>, то движок бы ничем другим заниматься в это время не мог.</p>
<p>Мы помним, что выполнение <em>синхронного</em> кода — строка за строкой. То есть, пока <code>delay()</code> не выполнится до конца, к следующей строке интерпретатор не перейдёт.</p>
<p>А это значит, что пока не пройдёт 5 секунд, и <code>delay()</code> не выполнится, мы вообще ничего сделать не сможем: ни вывести что-то в консоль ещё, ни выполнить другие функции, в особо тяжёлых случаях — даже передвинуть курсор.</p>
<p>Такие операции, которые не дают выполнять ничего кроме них самих, пока они не завершатся, называются <em>блокирующими выполнение</em>.</p>
<h2>Асинхронный код</h2>
<p>Теперь попробуем решить эту же задачу, но так, чтобы наш код не блокировал выполнение. Для этого мы воспользуемся функцией <a href="/js/settimeout/"><code>setTimeout()</code></a>:</p>
<pre><code class="language-js">setTimeout(function greet() {
  console.log(&quot;Hello!&quot;)
}, 5000)
</code></pre>
<p>5 секунд молчания, и выведется <em>«Hello!»</em></p>
<p>Задача решена. В этот раз, однако, в эти «5 секунд молчания» мы можем выполнять другие действия.</p>
<pre><code class="language-js">setTimeout(function greet() {
  console.log(&quot;Hello!&quot;)
}, 5000)

console.log(`I'm being called before greet function.`)
</code></pre>
<p>Сначала выведется: «I'm being called before greet function», а через 5 секунд — «Hello!»</p>
<p>Возникает несколько вопросов:</p>
<ol>
<li>Почему вторая строка кода выполнилась до первой, если JS однопоточный?</li>
<li>Куда девается <code>setTimeout()</code> на время, пока выполняется другой код?</li>
<li>Как движок понимает, что пора выводить <code>Hello!</code>?</li>
</ol>
<p>Чтобы с этим разобраться, нам надо понять, как функции вызываются «под капотом».</p>
<h2>Стек вызовов</h2>
<p>При вызове какой-то функции она попадает в так называемый стек вызовов.</p>
<p><strong><a href="https://ru.wikipedia.org/wiki/%D0%A1%D1%82%D0%B5%D0%BA">Стек</a></strong> — это структура данных, в которой элементы упорядочены так, что последний элемент, который попадает в стек, выходит из него первым <em>(LIFO: last in, first out).</em> Стек похож на стопку книг: та книга, которую мы кладём последней, находится сверху.</p>
<p>В стеке вызовов хранятся функции, до которых дошёл интерпретатор, и которые надо выполнить.</p>
<pre><code class="language-js">function outer() {
  function inner() {
    // Функция 3
    console.log(&quot;Hello!&quot;)
  }

  // Функция 2
  inner()
}

// Функция 1
outer()
</code></pre>
<p>Вызываем функцию 1 — <code>outer()</code>, она попадает в стек:</p>
<pre><code class="language-js">outer;
</code></pre>
<p>Вызываем функцию 2 — <code>inner()</code>, теперь в стеке 2 функции, потому что первая ещё не выполнилась до конца:</p>
<pre><code class="language-js">inner;
outer;
</code></pre>
<p>Вызываем <code>console.log()</code>, теперь в стеке 3 функции:</p>
<pre><code class="language-js">console.log;
inner;
outer;
</code></pre>
<p>Как только <code>console.log()</code> выполнится, она уйдёт из стека, там останется 2 функции:</p>
<pre><code class="language-js">inner;
outer;
</code></pre>
<p>Выполнившись, функция <code>inner</code> тоже уйдёт из стека, в нём останется лишь одна:</p>
<pre><code class="language-js">outer;
</code></pre>
<p>После выполнения всего блока стек станет пустым.</p>
<p>В синхронном коде в стеке хранится вся цепочка вызовов. Поэтому, например, <a href="/js/recursion/">рекурсия</a> без базового случая может приводить к переполнению стека — в нём скапливается слишком большое количество вызовов.</p>
<p>Теперь посмотрим, как ведёт себя стек вызовов при работе с асинхронным кодом:</p>
<pre><code class="language-js">function main() {
  setTimeout(function greet() {
    console.log(&quot;Hello!&quot;)
  }, 2000)

  console.log(&quot;Bye!&quot;)
}

main()
</code></pre>
<p>Вызываем функцию <code>main()</code>. Стек:</p>
<pre><code class="language-js">main;
</code></pre>
<p>Вызываем <code>setTimeout()</code>. Стек:</p>
<pre><code class="language-js">setTimeout;
main;
</code></pre>
<p><code>setTimeout</code> завершился, он выходит из стека:</p>
<pre><code class="language-js">main;
</code></pre>
<p>Вызываем <code>console.log('Bye!')</code>:</p>
<pre><code class="language-js">console.log('Bye!');
main;
</code></pre>
<p>Его вызов завершён, он выходит из стека:</p>
<pre><code class="language-js">main;
</code></pre>
<p>Вызов <code>main</code> тоже завершён, стек становится пуст.</p>
<p>Проходит около 2 секунд, вызывается функция <code>greet</code>, она попадает в стек:</p>
<pre><code class="language-js">greet;
</code></pre>
<p>Она вызывает <code>console.log('Hello!')</code>:</p>
<pre><code class="language-js">console.log('Hello!');
greet;
</code></pre>
<p>Отработав, она уходит из стека:</p>
<pre><code class="language-js">greet;
</code></pre>
<p>После выполнения всего блока стек снова становится пустым.</p>
<p>Первое, что бросается в глаза — <code>setTimeout()</code> завершается сразу, хотя колбэк внутри него ещё не отработал, более того, он даже ещё не был вызван! Здесь нам понадобится ещё одно понятие — цикл событий.</p>
<h2>Цикл событий</h2>
<p>Сперва откроем страшную правду, <code>setTimeout()</code> — это не JavaScript! 😱</p>
<p>Ну... не совсем так, конечно. Функция <code>setTimeout()</code> не является частью JavaScript-движка, это по сути <em>Web API,</em> включённое в среду браузера как дополнительная функциональность.</p>
<p>Эта дополнительная функциональность (Web API) берёт на себя работу с таймерами, интервалами, обработчиками событий. То есть, когда мы регистрируем обработчик клика на кнопку — он попадает в окружение Web API. Именно оно знает, когда обработчик нужно вызвать.</p>
<p>Управление тем, как должны вызываться функции Web API, берёт на себя <em>цикл событий</em> (Event loop).</p>
<p><strong><a href="https://developer.mozilla.org/ru/docs/Web/JavaScript/EventLoop#%D0%A6%D0%B8%D0%BA%D0%BB*%D1%81%D0%BE%D0%B1%D1%8B%D1%82%D0%B8%D0%B9">Цикл событий</a></strong> отвечает за выполнение кода, сбор и обработку событий и выполнение подзадач из очереди.</p>
<p>Именно цикл событий ответственен за то, что <code>setTimeout()</code> пропал из стека в прошлом примере. Чтобы увидеть картину целиком, давайте включим в нашу схему все недостающие части. Возьмём тот же самый пример:</p>
<pre><code class="language-js">function main() {
  setTimeout(function greet() {
    console.log(&quot;Hello!&quot;)
  }, 2000)

  console.log(&quot;Bye!&quot;)
}

main()
</code></pre>
<p>Но теперь у нас будет не только стек вызовов — также мы включим Web API и очередь задач, которую Web API использует для хранения того, что нужно выполнить.</p>
<p>Вызов <code>main</code>:</p>
<table>
<thead>
<tr>
<th>Стек</th>
<th>Web API</th>
<th>Очередь задач</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>main</code></td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<p>В Web API и очереди задач пока пусто.</p>
<p>Вызов <code>setTimeout</code>:</p>
<table>
<thead>
<tr>
<th>Стек</th>
<th>Web API</th>
<th>Очередь задач</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>setTimeout</code></td>
<td></td>
<td></td>
</tr>
<tr>
<td><code>main</code></td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<p>Когда <code>setTimeout</code> исчезает из стека, он попадает в видимость Web API, где интерпретатор понимает, что внутри него есть функция <code>greet</code>, которую надо выполнить через 2 секунды:</p>
<table>
<thead>
<tr>
<th>Стек</th>
<th>Web API</th>
<th>Очередь задач</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>main</code></td>
<td><code>setTimeout(greet)</code></td>
<td></td>
</tr>
</tbody>
</table>
<p>После этого выполняется вызов консоли <code>console.log(&quot;Bye!&quot;)</code>. В Web API находится функция <code>setTimeout(greet)</code>. Она будет там до тех пор, пока не пройдёт 2 секунды:</p>
<table>
<thead>
<tr>
<th>Стек</th>
<th>Web API</th>
<th>Очередь задач</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>console.log</code></td>
<td><code>setTimeout(greet)</code></td>
<td></td>
</tr>
<tr>
<td><code>main</code></td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<p>Отработал <code>console.log</code>, заканчивается работа <code>main</code>:</p>
<table>
<thead>
<tr>
<th>Стек</th>
<th>Web API</th>
<th>Очередь задач</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>main</code></td>
<td><code>setTimeout(greet)</code></td>
<td></td>
</tr>
</tbody>
</table>
<p><code>main</code> отработал, стек пуст. 2 секунды ещё не прошло, поэтому <code>setTimeout(greet)</code> все ещё в Web API:</p>
<table>
<thead>
<tr>
<th>Стек</th>
<th>Web API</th>
<th>Очередь задач</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
<td><code>setTimeout(greet)</code></td>
<td></td>
</tr>
</tbody>
</table>
<p>Наконец, 2 секунды прошли - функция <code>greet</code> перемещается в очередь задач:</p>
<table>
<thead>
<tr>
<th>Стек</th>
<th>Web API</th>
<th>Очередь задач</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
<td></td>
<td><code>greet</code></td>
</tr>
</tbody>
</table>
<p>Теперь цикл событий перемещает функцию <code>greet</code> из списка задач в вызов:</p>
<table>
<thead>
<tr>
<th>Стек</th>
<th>Web API</th>
<th>Очередь задач</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>greet</code></td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<p>Затем вызов <code>console.log(&quot;Hello!&quot;)</code>:</p>
<table>
<thead>
<tr>
<th>Стек</th>
<th>Web API</th>
<th>Очередь задач</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>console.log</code></td>
<td></td>
<td></td>
</tr>
<tr>
<td><code>greet</code></td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<p>И наконец стек пуст.</p>
<p>Заметьте, что стек вызовов и очередь задач называются именно стеком и очередью. Потому что вызовы из стека работают по принципу <em>«последний зашёл, первый вышел»</em> (LIFO: last in, first out), а в очереди — по принципу <em>«первый зашёл, первый вышел»</em> (FIFO: first in, first out).</p>
<p><strong><a href="https://ru.wikipedia.org/wiki/%D0%9E%D1%87%D0%B5%D1%80%D0%B5%D0%B4%D1%8C_(%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5)">Очередь</a></strong> — структура данных, в которой элементы упорядочены так, что первый попавший в очередь элемент покидает её первым.</p>
<p>Таким образом цикл событий работает с асинхронным кодом — то есть таким, который выполняется не построчно.</p>
<p>Очень хорошо работу цикла событий иллюстрирует <a href="http://latentflip.com/loupe/">инструмент Loupe</a> Филипа Робертса, а также его доклад «<a href="https://www.youtube.com/watch?v=8aGhZQkoFbQ">What the heck is the event loop anyway?</a>».</p>
<p><a href="http://latentflip.com/loupe/">Loupe</a> интерактивный, попробуйте ввести какой-нибудь код в поле слева, и справа будет показываться, что и в какой момент попадает в стек вызовов и очередь событий:</p>
<p><img src="images/1.png" alt="Веб-интерфейс инструмента Loupe"></p>
<h2>Колбэки</h2>
<p>Пример с <code>setTimeout</code>, который мы рассмотрели, показывает, как работают функции обратного вызова — колбэки.</p>
<p><strong><a href="https://ru.wikipedia.org/wiki/Callback_(%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5)">Callback</a></strong> (колбэк, функция обратного вызова) — функция, которая вызывается в ответ на совершение некоторого события.</p>
<p>В нашем случае таким событием было срабатывание таймера через 2 секунды, а колбэком — функция <code>greet()</code>. В целом, событием может быть что угодно:</p>
<ul>
<li>ответ от сервера;</li>
<li>завершение какой-то длительной вычислительной задачи;</li>
<li>получение доступа к каким-то API устройства, на котором выполняется код.</li>
</ul>
<p>Таким образом <em>колбэк</em> — это первый способ обработать какое-либо асинхронное действие.</p>
<p>Изначально колбэки были единственным способом работать с асинхронным кодом в JavaScript. Большая часть асинхронного API Node.js была написана именно на колбэках и создана для использования с колбэками.</p>
<p>Это, в принципе, логично — ментальная модель достаточно простая: <em>«выполни эту функцию, когда случится это событие»</em>.</p>
<p>Однако у колбэков есть неприятный минус, так называемый <em>ад колбэков</em> (callback hell).</p>
<h3>Ад колбэков (Callback-hell)</h3>
<p>Нагляднее всего его можно показать на примере.</p>
<p>Допустим, у нас есть ряд асинхронных задач, которые зависят друг от друга: то есть первая задача запускает по завершении вторую, вторая — третью и т. д.</p>
<pre><code class="language-js">setTimeout(() =&gt; {
  setTimeout(() =&gt; {
    setTimeout(() =&gt; {
      setTimeout(() =&gt; {
        console.log(&quot;Hello!&quot;)
      }, 5000)
    }, 5000)
  }, 5000)
}, 5000)
</code></pre>
<p>Если одна задача запускает другую, та — третью, и так далее, мы можем получить вот такую «башню» из обратных вызовов.</p>
<p>И такая башня может получиться где угодно. Если мы делаем несколько последовательных запросов к серверу, зависящих друг от друга, то это может выглядеть вот так:</p>
<pre><code class="language-js">function request(url, onSuccess) {
  /*...*/
}

request(&quot;/api/users/1&quot;, function (user) {
  request(`/api/photos/${user.id}/`, function (photo) {
    request(`/api/crop/${photo.id}/`, function (response) {
      console.log(response)
    })
  })
})
</code></pre>
<p>Читать такое сложно, не говоря уже о тестировании, которое здесь становится очень накладным.</p>
<p>Решить эту проблему были призваны Промисы (Promise).</p>
<h2>Промисы (Promise)</h2>
<p><strong><a href="/js/promise/">Промис</a></strong> — это объект-обёртка для асинхронного кода. Он содержит в себе состояние: вначале <code>pending</code> («ожидание»), затем — одно из: <code>fulfilled</code> («выполнено успешно») или <code>rejected</code> («выполнено с ошибкой»).</p>
<p>В понятиях цикла событий промис работает так же, как колбэк: функция, которая должна выполниться (<code>resolve</code> или <code>reject</code>), находится в окружении Web API, а при наступлении события — попадает в очередь задач, откуда потом — в стек вызова.</p>
<p>В асинхронных задачах есть <a href="https://medium.com/javascript-in-plain-english/javascript-event-loop-y-promises-951ba6845899">разделение между макрозадачами и микрозадачами</a>. Колбэки в промисах попадают в очередь микрозадач, тогда как колбэк в <code>setTimeout</code> — в очередь макрозадач. Но здесь и сейчас мы в такие детали уходить не будем.</p>
<p>Промисы придумали, чтобы организовывать асинхронный код последовательно.</p>
<p>Та же последовательность запросов из прошлого примера, но переписанная с использованием промисов.</p>
<pre><code class="language-js">function request(url) {
  return new Promise(function (resolve, reject) {
    let responseFromServer
    /*...*/
    resolve(responseFromServer)
  })
}

request(&quot;/api/users/1&quot;)
  .then((user) =&gt; request(`/api/photos/${user.id}/`))
  .then((photo) =&gt; request(`/api/crop/${photo.id}/`))
  .then((response) =&gt; console.log(response))
</code></pre>
<p>Код избавился от лишней вложенности, стал плоским и более тестируемым.</p>
<p>Дополнительным плюсом стала возможность обрабатывать ошибки от цепочки промисов в одном месте — последним <code>catch</code>:</p>
<pre><code class="language-js">request(&quot;/api/users/1&quot;)
  .then((user) =&gt; request(`/api/photos/${user.id}/`))
  .then((photo) =&gt; request(`/api/crop/${photo.id}/`))
  .then((response) =&gt; console.log(response))
  .catch((error) =&gt; console.error(error))
</code></pre>
<p>Если что-то пошло не так, то программа не упадёт, а управление перейдёт к последней строчке с <code>catch</code>, причём независимо от того, в каком из запросов ошибка появится.</p>
<p>Также из <code>then</code> можно вернуть не промис, а обычное значение. Оно обернётся в промис самостоятельно и прокинется в следующий <code>then</code>:</p>
<pre><code class="language-js">request(&quot;/api/users/1&quot;)
  .then((user) =&gt; user.id)
  .then((userId) =&gt; request(`/api/photos/${userId}/`))
  .then((photo) =&gt; request(`/api/crop/${photo.id}/`))
  .then((response) =&gt; console.log(response))
  .catch((error) =&gt; console.error(error))
</code></pre>
<p>Промисы оказались удобными, и появился даже такой термин как «<a href="https://nodejs.org/dist/latest-v8.x/docs/api/util.html#util_util_promisify_original">промисификация</a>» — когда асинхронную функциональность на колбэках превращали в промисы.</p>
<p>Однако промисы — это тоже не серебряная пуля. У них есть несколько недостатков:</p>
<ul>
<li>Код не такой лаконичный, как мог быть.</li>
<li>В цепочке промисов, как на примере (со стрелочными функциями), невозможно выставить брейкпоинт, потому что нет тела функции. Приходится раскрывать функцию.</li>
<li>Стек ошибок может содержать в себе <code>then.then.then.then...</code>.</li>
<li>Вложенные условия сильно увеличивают количество кода и ухудшают читаемость.</li>
</ul>
<p>Для решения этих проблем придумали асинхронные функции.</p>
<h2>Асинхронные функции</h2>
<p>Если коротко, <strong><a href="/js/async-await/">асинхронные функции</a></strong> — функции, которые возвращают промисы.</p>
<p>Асинхронная функция помечается специальным ключевым словом <code>async</code>:</p>
<pre><code class="language-js">async function request() {}
const req = async () =&gt; {}

class SomeClass {
  async request() {}
}
</code></pre>
<p>Они <em>всегда</em> возвращают Промис. Даже если мы явно этого не указывали, как в примерах выше, при вызове они всё равно вернут промис.</p>
<pre><code class="language-js">async function request() {}

// Сработает:
request().then(() =&gt; {})
</code></pre>
<p>Однако с асинхронными функциями можно не обращаться с <code>then</code> — есть более изящное решение.</p>
<h3>Связка <code>async/await</code></h3>
<p>Внутри асинхронных функций можно вызывать другие асинхронные функции, без каких-либо <code>then</code> или колбэков, с помощью ключевого слова <code>await</code>.</p>
<pre><code class="language-js">async function loadPosts() {
  const response = await fetch(`/api/posts/`)
  const data = await response.json()
  return data
}
</code></pre>
<p>В примере выше мы используем <a href="/js/fetch/"><code>fetch</code></a> внутри функции <code>loadPosts</code>.</p>
<p>Все асинхронные функции внутри мы вызываем с <code>await</code> — таким образом промис, который функция возвращает, автоматически разворачивается, и мы получаем значение, которое внутри промиса было.</p>
<h3>Плюсы <code>async/await</code></h3>
<p><strong>Код чище и короче.</strong> У нас больше нет цепочек из <code>then</code>, вместо этого мы получаем плоскую структуру, которая по виду похожа на синхронный код.</p>
<p>Условия и вложенные конструкции становятся чище и проще читаются.</p>
<p><strong>Мы можем обрабатывать ошибки с <code>try-catch</code>.</strong> Как и с синхронным кодом, обработка ошибок сводится к оборачиванию опасных операций в <code>try-catch</code>:</p>
<pre><code class="language-js">async function loadPosts() {
  try {
    const response = await fetch(`/api/posts/`)
    const data = await response.json()
    return data
  } catch (e) {
    console.log(e)
  }
}
</code></pre>
<p>При этом в отличие от <code>.catch()</code> промисов, try-catch поймает не только ошибки, которые были внутри асинхронных функций, но также и ошибки, которые возникли во время обычных синхронных операций.</p>
<p><strong>Можно ставить брейкпоинты (точки останова).</strong> Для отладки мы можем поставить брейкпоинт куда угодно, он сработает.</p>
