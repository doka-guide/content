<h2>Кратко</h2>
<p>Для хранения различных значений в переменных мы используем разные типы данных. Однако хранятся эти значения по-разному. Примитивные значения (например, числа или строки) хранятся в переменной как есть, а объекты, массивы и функции — по ссылке на место в памяти.</p>
<p>Представим ситуацию, когда у вас в руках есть ложка из набора, и вы кладёте её в какой-то ящик. Такой простой метафорой можно описать присвоение значения в переменную, если представить ящик как переменную, а ложку как значение. Таким образом можно определить и <strong>хранение по значению</strong>. В следующий раз, когда вы захотите взять ложку, вы можете открыть тот же самый ящик и получить это значение-ложку.</p>
<p>Теперь представим, что у нас есть другая ложка — это специальная ложка, удобная, но при этом никто не знает, какого она размера и как её правильно хранить. Но для удобства вам хотелось так же использовать ящик. Поэтому, когда вы открыли этот же ящик, то там уже не лежит эта ложка, зато находится записка о том, где эту ложку можно найти.</p>
<p>В итоге, чтобы получить ложку, нужно обратиться по этому «адресу». Предположим, что теперь все такие ложки лежат в специальной «ложечной», которая может их вместить, и только оттуда их можно достать. А потому, чтобы получить ложку вам нужно обратиться по данному адресу. Аналогичным образом мы можем положить записки с тем же адресом и в другие ящики, чтобы каждый, кто обращался к ящику знал где найти ложку. Теперь ваша ложка <strong>хранится по ссылке</strong>.</p>
<p><strong>В чем же фундаментальное отличие?</strong></p>
<p>Отличий несколько, некоторые могут приводить к неприятным последствиями в нашем коде.</p>
<p>То, как будут храниться данные, жёстко связано с типом данных. Нельзя заставить значение примитивного типа храниться по ссылке, и наоборот.</p>
<p>Для того чтобы понять, как хранятся разные типы данных, заглянем в память компьютера.</p>
<h2>Примитивные типы данных</h2>
<p>Когда мы объявляем переменную и сохраняем в неё примитивное значение, то в память записывается какое-то количество байт, которое описывает это значение. Таким образом можно сказать, что наша переменная уже сразу содержит эти байты.</p>
<pre><code class="language-js">const seven = 7 // 0b0111
const eight = 8 // 0b1000
</code></pre>
<p>Если присвоить какое-то значение переменной в другую, то мы просто скопируем это же количество байт в новое место.</p>
<pre><code class="language-js">const sevenAgain = seven // 0b0111
</code></pre>
<p>В итоге все наши переменные можно схематически отобразить таким образом:</p>
<p><img src="images/1.png" alt="Схематическое отображение переменных"></p>
<p>Когда мы сравниваем два значения, то у нас по сути произойдёт побайтовое сравнение этих величин.</p>
<pre><code class="language-js">seven === sevenAgain // true
</code></pre>
<p><img src="images/2.png" alt="Побайтовое сравнение величин с результатом true"></p>
<pre><code class="language-js">seven === eight // false
</code></pre>
<p><img src="images/3.png" alt="Побайтовое сравнение величин с результатом false"></p>
<p>Из-за того, что все примитивные значения хранятся в небольшом и фиксированном количестве байт, операции над ними выполнять несложно. Такие типы данных называют <em>примитивными</em>. В них входят числа (<code>number</code>), строки (<code>string</code>), булевы (<code>boolean</code>), а так же специальные значения <code>null</code> и <code>undefined</code>.</p>
<h2>Ссылочные типы данных</h2>
<p>С объектами и другими сложными данными дела обстоят сложнее из-за того, что мы не знаем, какое количество памяти для них понадобится. Во время работы с такой структурой компьютеру необходимо следить за тем, сколько памяти уже есть, сколько понадобится, и выделять новую. Работать с такими данными сложнее. Для этого компьютер отдаёт нам ссылку на место, где данные хранятся, и самостоятельно будет работать с ними по инструкциям, которые мы ему даём. Таким образом в переменную мы получаем лишь ссылку на данные.</p>
<pre><code class="language-js">const myData = {}
</code></pre>
<p><img src="images/4.png" alt="Схематичное изображение переменной myData со ссылкой на участок памяти"></p>
<p>Обратите внимание, что направление стрелки поменялось. Так мы обозначим, что наша переменная ссылается на участок памяти.</p>
<p>☝️ Если сейчас присвоить значение из <code>myData</code> в другую переменную, то мы скопируем ссылку, а не само значение.</p>
<pre><code class="language-js">const yourData = myData
</code></pre>
<p><img src="images/5.png" alt="Схематичное изображение переменных myData и yourData со ссылкой на общий участок памяти"></p>
<p>Такой тип данных называется <strong>ссылочным</strong> и в него входят <strong>объекты</strong>, <strong>массивы</strong> и <strong>функции</strong>. На самом деле и массивы и функции все они так же являются объектами, но это другая история.</p>
<p>Можно ли в таком случае рассчитывать, что значения будут равными? Конечно, можно! В этом случае сравниваться будут ссылки на объект, а не их содержимое. Потому, если обе переменных указываются на одно и то же, смело можно сказать, что значения равны.</p>
<pre><code class="language-js">const data = {}
const anotherData = data

console.log(data === anotherData) // true
</code></pre>
<p>И не стоит забывать, что никакого сравнения по значениям не будет, даже если мы создадим абсолютно одинаковые объекты.</p>
<pre><code class="language-js">const cat = { name: &quot;Felix&quot; }
const dog = { name: &quot;Felix&quot; }

// Странно ожидать равность кошки и собаки ¯\_(ツ)_/¯ но теперь мы знаем причину
console.log(cat === dog) // false
</code></pre>
<p>Однако факт того, что несколько переменных могут ссылаться на один и тот же объект означает в себе и некоторые другие особенности. Если кто-то из двух владельцев ссылки будет изменять объект, то изменения отразятся на всех.</p>
<pre><code class="language-js">yourData.name = &quot;Alex&quot;

console.log(myData) // { name: 'Alex' }

myData.name = &quot;Michel&quot;

console.log(yourData) // { name: 'Michel' }
</code></pre>
<p>Эта особенность часто становится причиной ошибок при работе с ссылочными типами данных, т.к можно легко забыть или даже не знать, что же ещё ссылается на тот же объект.</p>
<p>Если переменная потеряет ссылку на объект, то изменения уже не будут на него влиять</p>
<pre><code class="language-js">let user = { name: &quot;Anna&quot;, age: 21 }
const admin = user

// Переопределение никак не повлияет на admin, потому что мы создали новый объект
user = { name: &quot;John&quot; }

console.log(admin) // { name: 'Anna', age: 21 }

admin.isAdmin = true

console.log(user) // { name: 'John' }
console.log(admin) // { name: 'Anna', age: 21, isAdmin: true }
</code></pre>
<h3>Мутации и неизменяемость</h3>
<p>Изменение значений у полей объекта, добавление или удаление их отразится на всех, кто владеет ссылкой на этот объект. Такие операции называют <strong>мутациями</strong>. В современных веб-разработке мутаций стараются избегать, потому что мутирование объектов может приводить к ошибкам, которые очень трудно отследить. Однако если мы твердо уверены, что объект нигде более не используется или чётко контролируем ситуацию, то изменение объекта напрямую гораздо проще.</p>
<p>Если нужно безопасно модифицировать объект, то для начала придётся его скопировать. Скопировать объект можно двумя способами: через <code>Object.assign</code> или используя оператор троеточия <code>...</code></p>
<pre><code class="language-js">const admin = {
  name: &quot;Anna&quot;,
  age: 21,
  isAdmin: true,
}

// Чтобы скопировать через Object.assign нужно передать пустой объект
const adminCopy = Object.assign({}, admin)

const anotherCopy = {
  ...admin,
}
</code></pre>
<p>Таким образом будет создана совсем новая сущность, которая будет содержать ровно те же значения. Любые изменения в новом объекте уже не затронут предыдущий.</p>
<pre><code class="language-js">anotherCopy.age = 30
anotherCopy.isAdmin = false

console.log(anotherCopy)
// {name: 'Anna', age: 30, isAdmin: false }

console.log(admin)
// {name: 'Anna', age: 25, isAdmin: true }
</code></pre>
<p>Здесь стоит внести важную оговорку о вложенных объектах. При копировании объекта указанным способом скопируются только поля верхней вложенности (сработает <a href="/js/shallow-or-deep-clone/">поверхностное копирование</a>). Любые вложенные объекты <strong>скопируются по ссылке</strong>. Их изменение затронет и первоисточник:</p>
<pre><code class="language-js">const original = {
  b: {
    c: 1,
  },
}

const copy = { ...original }
copy.b.c = 2

// Тоже изменился!
console.log(original)
// { b: { c: 2 }}
</code></pre>
<p>Изменения можно так же внести при копировании.</p>
<pre><code class="language-js">const cat = {
  name: &quot;Felix&quot;,
  color: &quot;black&quot;,
  isHomeless: false,
}

const catInBoots = {
  ...cat,
  name: &quot;Johny&quot;,
  hasBoots: true,
}

// {name: 'Johny', color: 'black', isHomeless: false, hasBoots: true }
console.log(catInBoots)

const redCat = Object.assign(cat, { color: &quot;red&quot;, name: &quot;Boris&quot; })

// {name: 'Boris', color: 'red', isHomeless: false }
console.log(redCat)
</code></pre>
<p>Если каждый раз создавать объект, когда мы вносим изменения, то такие объекты называют <strong>иммутабельными (immutable)</strong> или <strong>неизменяемыми</strong>. Результатом любой модификации такого объекта всегда должен быть новый объект, при этом старый никак не изменится.</p>
<p>С массивами, кстати, ситуация точно такая же — если изменять содержимое, то изменения отразятся на всех владельцев ссылки. Для копирования массивов, кроме оператора троеточия, можно использовать метод <code>Array.slice</code>. Методы <a href="/js/array-map/">Array.map</a> и <a href="/js/array-filter/">Array.filter</a> — они тоже создают новый массив. Причём некоторые другие методы (например <code>Array.sort</code>, <code>Array.splice</code>) при использовании мутируют исходный массив, потому использовать их стоит с осторожностью. Подробнее о том, какой метод мутирует массив можно найти на <a href="https://doesitmutate.xyz/">Does It Mutate</a>.</p>
<p>Очевидным минусом использования иммутабельности может быть большее использование памяти, но в реалиях современной разработки это часто не бывает проблемой, учитывая те плюсы, которые мы получаем.</p>
<h4>Аргументы функций</h4>
<p>Про тип данных стоит помнить особенно внимательно при использовании функций. Когда мы используем значение как аргумент функции, то все особенности его типа данных сохраняются:</p>
<ul>
<li>При передаче примитивного типа данных, его значение копируется в аргумент.</li>
<li>При использовании ссылочного типа данных копируется ссылка. Все изменения в объекте, который был передан в качестве аргумента, будут видны всем, кто владеет ссылкой:</li>
</ul>
<pre><code class="language-js">const member = { id: &quot;123&quot;, name: &quot;John&quot; }

function makeAdmin(user) {
  user.isAdmin = true

  return user
}

const admin = makeAdmin(member)

console.log(admin) // { id: '123', name: 'John', isAdmin: true }
console.log(member) // { id: '123', name: 'John', isAdmin: true }
// Это один и тот же объект
console.log(admin === member) // true
</code></pre>
<h2>Заключение</h2>
<p>Итак, что мы узнали?</p>
<ul>
<li><strong>Примитивные</strong> типы данных (числа, булевы и строки) хранятся и сравниваются по значению. Можно безопасно менять значение переменной и не бояться, что изменится что-то ещё</li>
<li><strong>Ссылочные</strong> типы данных (объекты, массивы) хранятся и сравниваются по ссылке. При этом при сравнении будет учитываться именно факт того, что две переменные ссылаются на один и тот же объект. Даже если два объекта содержат идентичные значения это ни на что не повлияет</li>
<li>Изменения внутри объекта будут видны всем у кого есть ссылка на этот объект. Прямое изменение данных объекта называется <strong>мутирование</strong>. Лучше стараться избегать мутации объекта, т.к это может приводить к неочевидным ошибкам</li>
<li>Чтобы безопасно менять ссылочный тип данных его необходимо предварительно скопировать. Таким образом будет создана другая ссылка и любые изменения на затронут старый объект</li>
</ul>
