<h2>Кратко</h2>
<p>Элементы на странице можно позиционировать не только с помощью стилей, но и с помощью JavaScript. В этой статье мы рассмотрим ситуации, когда это оправдано и как таким позиционированием пользоваться.</p>
<p>Прежде чем мы приступим к непосредственно позиционированию, давайте определимся, зачем нам ещё один способ расставлять элементы, когда у нас уже есть CSS.</p>
<h2>Когда использовать стили</h2>
<p>Используйте стили для позиционирования всегда, когда это возможно.</p>
<p>CSS — это инструмент, который специально был придуман для стилизации документов.</p>
<ul>
<li>Это работает в среднем быстрее.</li>
<li>Это не собьёт с толку других разработчиков, которые будут читать ваш код.</li>
<li>Это разделяет зоны ответственности между скриптами и стилями.</li>
</ul>
<h2>Когда использовать скрипты</h2>
<p>Используйте скрипты для позиционирования тогда, когда стилей не хватает.</p>
<p>CSS ограничен в обратной связи на действия пользователей на экране. В нём есть такие штуки как <code>@keyframes</code>, <a href="/css/transition/"><code>transition</code></a>, <a href="/css/hover/"><code>:hover</code></a>, <a href="/css/active/"><code>:active</code></a>, <a href="/css/focus/"><code>:focus</code></a> и т. д., но этого не всегда достаточно.</p>
<p>Иногда нужно, чтобы в ответ на действия пользователя на странице происходили сложные преобразования или чтобы пользователи сами могли управлять анимациями на странице.</p>
<p>Такие случаи — это не просто стилизация документа, а скорее смесь из стилизации и программной логики. Чтобы решить такую задачу, нам нужны как инструменты стилизации (CSS), так и инструменты для программирования логики (JS).</p>
<h2>Как менять позиционирование на скриптах</h2>
<p>Изменять положение элементов (как и любые стили элементов) на странице можно с помощью нескольких способов.</p>
<h3>Изменять классы</h3>
<p>Допустим, мы хотим переместить элемент при клике на него в другое место. Для решения такой задачи нам вполне подойдёт способ с изменением класса у элемента.</p>
<p>Определим CSS-классы:</p>
<pre><code class="language-css">.element {
  /* Стили самого элемента. */
}

.element-initial {
  /* Стили, определяющие начальное положение
    элемента на странице, например: */
  transform: translateX(0px);
}

.element-final {
  /* Стили, определяющие конечное положение, например: */
  transform: translateX(50px);
}
</code></pre>
<p>Элементу изначально заданы классы <code>element element-initial</code>, которые задают его стили, а также его начальное положение.</p>
<p>Теперь в ответ на действие пользователя (например, в ответ на клик), поменяем класс элемента, отвечающий за положение. Воспользуемся методом <a href="/js/element-classlist/#element.classlist.toggle"><code>classList.toggle</code></a> у элемента, чтобы добавить класс, если его нет на элементе, и убрать, если класс есть:</p>
<pre><code class="language-js">// Обрабатываем событие клика на элементе:
element.addEventListener(&quot;click&quot;, () =&gt; {
  element.classList.toggle(&quot;element-final&quot;)
  element.classList.toggle(&quot;element-initial&quot;)
})
</code></pre>
<p>Тогда получим элемент, который меняет своё положение при клике на него:</p>
<iframe title="Смена положения при клике — Позиционирование элементов с помощью JS — Дока" src="demos/class/" height="275"></iframe>
<p>Этот способ изменять стили элемента с помощью скриптов самый простой и чистый — все стили остаются описанными внутри CSS. Однако он не всегда подходит.</p>
<p>Использовать такой способ можно, когда мы <em>заранее знаем, куда и откуда</em> мы хотим переместить элемент, но <em>не знаем момент</em>, когда нам это понадобится.</p>
<h3>Изменять <code>style</code></h3>
<p>Второй способ изменять положение элемента — менять атрибут <code>style</code> с помощью JS.</p>
<p>При работе со <code>style</code> следует помнить, что у этого атрибута высокая специфичность, из-за чего он будет перебивать основные стили элемента. Его следует использовать с осторожностью.</p>
<p>Он подойдёт в случае, когда мы мгновенно хотим отражать изменения на элементе, даже если не знаем, что и когда поменяется. Например, если мы хотим перемещать элемент мышкой на экране, нам может понадобиться менять его <code>style</code>.</p>
<p>Для изменения положения через <code>style</code> можно использовать разные свойства.</p>
<h4>Изменение <code>margin</code> или <code>top / left / right / bottom</code></h4>
<p>Первое, что приходит на ум — изменение соответствующих свойств типа <code>margin</code> или <code>left / top / right / bottom</code>.</p>
<p>Создадим элемент с классом <code>element</code>:</p>
<pre><code class="language-css">.element {
  width: 50px;
  height: 50px;
  background: black;
  position: absolute;
}
</code></pre>
<p>Теперь попробуем написать драг-н-дроп для мыши.</p>
<pre><code class="language-js">// Сперва создадим ссылку на этот элемент,
// чтобы обрабатывать события на нём:
const element = document.querySelector(&quot;.element&quot;)

// Переменная dragging будет отвечать за состояние элемента.
// Если его тащат, то переменная будет со значением true.
// По умолчанию она false.
let dragging = false

// В переменных startX и startY мы будем держать координаты точки,
// в которой находился элемент, когда мы начали его тащить мышью.
let startX = 0
let startY = 0

// При событии mousedown (когда на элемент нажимают мышью)
// мы отмечаем dragging как true — значит, элемента начали тащить.
element.addEventListener(&quot;mousedown&quot;, (e) =&gt; {
  dragging = true

  // В значения для startX и startY мы помещаем положение курсора
  // через свойства события e.pageX и e.pageY.
  startX = e.pageX - Number.parseInt(element.style.left || 0)
  startY = e.pageY - Number.parseInt(element.style.top || 0)

  // Из положения курсора мы вычитаем отступы элемента, если они есть.
  // Вычитание отступов нам нужно, чтобы элемент «запоминал»
  // своё последнее положение, иначе мы всегда будем начинать тащить его
  // от начала экрана.
})

// Далее мы обрабатываем событие перемещения мыши по body.
// Мы наблюдаем именно за body, потому что хотим,
// чтобы изменения работали на всей странице,
// а не только внутри элемента element.
document.body.addEventListener(&quot;mousemove&quot;, (e) =&gt; {
  // Если элемент не тащат, то ничего не делаем.
  if (!dragging) return

  // Если тащат, то высчитываем новое положение,
  // вычитая начальное положение элемента из положения курсора.
  element.style.top = `${e.pageY - startY}px`
  element.style.left = `${e.pageX - startX}px`
})

// Когда мы отпускаем мышь, мы отмечаем dragging как false.
document.body.addEventListener(&quot;mouseup&quot;, () =&gt; {
  dragging = false
})
</code></pre>
<p>Тогда получится вот такой драг-н-дроп:</p>
<iframe title="Драг-н-дроп — Позиционирование элементов с помощью JS — Дока" src="demos/drag-n-drop/" height="275"></iframe>
<p>Это работает, но не очень эффективно, потому что изменения в этих свойствах заставляют браузер делать много лишней работы.</p>
<p><a href="/js/how-the-browser-creates-pages/">Как браузер рисует страницы</a></p>
<p>Мы можем сделать лучше.</p>
<h4>Изменение <code>transform</code></h4>
<p>Перепишем наш драг-н-дроп, меняя теперь значение свойства <code>transform</code>.</p>
<p>Основа кода останется той же, стили и разметка не поменяются вовсе. В скриптах мы слегка изменим определение положения элемента.</p>
<pre><code class="language-js">// ...

element.addEventListener(&quot;mousedown&quot;, (e) =&gt; {
  dragging = true

  // В этот раз мы не сможем считать нужные нам значения напрямую.
  // Вместо этого нам потребуется вначале вычислить стиль элемента
  // через window.getComputedStyle(), а затем узнать значение
  // свойства transform.
  const style = window.getComputedStyle(element)

  // Мы могли бы просто считать значение style.transform,
  // но это бы нам не сильно помогло.
  // При обычном считывании мы бы получили нечто вроде:
  //     matrix(1, 0, 0, 1, 27, 15);
  //
  // Это матрица афинных преобразований.
  // Её можно представить в виде:
  //     matrix(scaleX, skewY, skewX, scaleY, translateX, translateY);
  // где:
  //     - scaleX — масштабирование по горизонтали,
  //     - scaleY — масштабирование по вертикали,
  //     - skewX — перекос по горизонтали,
  //     - skewY — перекос по вертикали,
  //     - translateX — смещение по горизонтали,
  //     - translateY — смещение по вертикали.
  //
  // Но даже учитывая, что у нас есть все необходимые числа,
  // работать с этим неудобно — это же просто строка.
  //
  // К счастью мы можем воспользоваться DOMMatrixReadOnly,
  // который преобразует эту матрицу в удобную для использования:
  const transform = new DOMMatrixReadOnly(style.transform)

  // Теперь мы можем воспользоваться свойствами,
  // которые содержат в себе значения translateX и translateY.
  const translateX = transform.m41
  const translateY = transform.m42

  // Дальше — как раньше, только вычитаем не top и left,
  // а translateX и translateY.
  startX = e.pageX - translateX
  startY = e.pageY - translateY
})
</code></pre>
<p>А также немного обновим изменение положения:</p>
<pre><code class="language-js">// ...

document.body.addEventListener(&quot;mousemove&quot;, (e) =&gt; {
  if (!dragging) return

  const x = e.pageX - startX
  const y = e.pageY - startY

  // В этот раз мы можем объединить обновлённые координаты
  // в одну запись translate, которую потом
  // присвоим в качестве значения свойству transform.
  element.style.transform = `translate(${x}px, ${y}px)`
})
</code></pre>
<p>В итоге получим такой же драг-н-дроп, но работающий на <code>transform</code>.</p>
<iframe title="Драг-н-дроп, работающий на transform — Позиционирование элементов с помощью JS — Дока" src="demos/drag-n-drop-transform/" height="275"></iframe>
<p>Но мы можем ещё лучше 😎</p>
<h4>Изменение кастомных свойств CSS</h4>
<p>Сейчас код рабочий, но его трудно читать. Как минимум потому, что надо знать, как работает матрица преобразований и <code>DOMMatrixReadOnly</code>.</p>
<p>Мы же можем не менять значение <code>transform</code> вовсе, а вместо этого менять значение CSS-переменных, чтобы обновлять положение элемента!</p>
<p>Первым делом определяем кастомные свойства CSS в стилях элемента:</p>
<pre><code class="language-css">.element {
  width: 50px;
  height: 50px;
  background: black;
  position: absolute;

  /* В переменной --x мы будем держать
    значение координаты по горизонтали;
    в переменной --y — по вертикали. */
  --x: 0px;
  --y: 0px;

  /* Укажем transform, значением которого
    передадим translate с указанными переменными.
    В итоге нам не придётся менять сам transform,
    мы сможем ограничиться лишь изменением значений
    переменных --x и --y. */
  transform: translate(var(--x), var(--y));
}
</code></pre>
<p>Теперь подправим скрипт, чтобы сперва считать значение этих переменных:</p>
<pre><code class="language-js">// ...

element.addEventListener(&quot;mousedown&quot;, (e) =&gt; {
  dragging = true

  // Получаем стиль элемента:
  const style = window.getComputedStyle(element)

  // Считываем значение каждой переменной через getPropertyValue:
  const translateX = parseInt(style.getPropertyValue(&quot;--x&quot;))
  const translateY = parseInt(style.getPropertyValue(&quot;--y&quot;))

  // Дальше всё остаётся по-старому :–)
  startX = e.pageX - translateX
  startY = e.pageY - translateY
})
</code></pre>
<p>А теперь изменим обновление стилей:</p>
<pre><code class="language-js">// ...

document.body.addEventListener(&quot;mousemove&quot;, (e) =&gt; {
  if (!dragging) return

  // Обратите внимание, насколько лаконичной стала запись.
  // Мы всего лишь указываем, какое значение должна
  // принять каждая из переменных:
  element.style.setProperty(&quot;--x&quot;, `${e.pageX - startX}px`)
  element.style.setProperty(&quot;--y&quot;, `${e.pageY - startY}px`)
})
</code></pre>
<p>В результате получаем такой же драг-н-дроп!</p>
<iframe title="Драг-н-дроп на кастомных свойствах — Позиционирование элементов с помощью JS — Дока" src="demos/drag-n-drop-custom-props/" height="275"></iframe>
