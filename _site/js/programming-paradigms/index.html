<h2>Кратко</h2>
<p>Программировать можно по-разному. Набор приёмов и понятий, которые определяют «как писать» называют парадигмой.</p>
<p>В этой статье мы рассмотрим, какие парадигмы в программировании бывают и чем они отличаются друг от друга.</p>
<p>Программа — это инструкция. Когда вы объясняете другу, как к вам доехать, вы, в принципе, программируете.</p>
<p>Объяснение, как к вам добраться, можно построить по-разному. Можно просто назвать адрес, а можно рассказать в деталях, где свернуть, на какую сторону улицы перейти, в какой дом зайти.</p>
<p>Например:</p>
<blockquote>
<p>«Выходи на Александра Невского, сверни налево и иди до перекрёстка, там перейдёшь дорогу, свернёшь налево и пройдёшь до 38 дома, обойди дом, так как вход со двора, дойди до 2 подъезда слева и набери 2468, поднимись на четвёртый этаж, тридцать восьмая квартира.</p>
</blockquote>
<p>Или:</p>
<blockquote>
<p>«Адрес: ул. Свободы, д. 38, кв. 33, домофон 2468.»</p>
</blockquote>
<p>Обе инструкции — об одном и том же, но в них есть одно значительное отличие.</p>
<h2>Стили объяснения</h2>
<p>Первая инструкция объясняет, <em>как</em> добраться до нужного места. Она описывает в деталях, какие действия и в какой момент надо предпринять. По сути — это набор команд, которые нужно выполнить, чтобы достичь результата.</p>
<p>Такой стиль объяснения (или программирования) называется <em>императивным</em>.</p>
<p>Вторая же инструкция объясняет, <em>что</em> мы должны получить в результате — где друг должен оказаться. Нам не особо важно, как он или она туда доберётся, важно — <em>куда</em>.</p>
<p>Такой стиль программирования называется <em>декларативным</em>.</p>
<h3>Императивный стиль</h3>
<p>Чтобы лучше понять разницу между императивным и декларативным стилями, давайте напишем небольшую функцию для нахождения всех нечётных элементов в массиве. Сперва сделаем это императивно:</p>
<pre><code class="language-js">function onlyOdd(array) {
  let result = []

  for (const element of array) {
    if (element % 2 !== 0) {
      result.push(element)
    }
  }

  return result
}
</code></pre>
<p>Заметьте, как мы строим эту функцию. Мы как бы говорим:</p>
<ul>
<li>сперва присвой переменной <code>result</code> значение <code>[]</code>;</li>
<li>затем пройдись по каждому элементу в массиве <code>array</code>;
<ul>
<li>проверь, что значение этого элемента нечётное;</li>
<li>если это так, добавь этот элемент в <code>result</code>;</li>
</ul>
</li>
<li>после — верни <code>result</code>.</li>
</ul>
<p>То есть наша императивная функция — это набор конкретных команд, которые выполняются последовательно одна за другой.</p>
<h3>Декларативный стиль</h3>
<p>Теперь попробуем ту же функцию написать декларативно, то есть не вдаваясь в детали:</p>
<pre><code class="language-js">function onlyOdd(array) {
  return array.filter((element) =&gt; element % 2 !== 0)
}
</code></pre>
<p>Мы говорим, что нам надо отфильтровать массив по указанному критерию. При этом нам не важно, как будет осуществлена эта фильтрация. Нам даже не важно, кто этим будет заниматься — нам лишь важно, какой массив на выходе мы хотим получить.</p>
<h3>Разница между подходами</h3>
<p>Разница между этими подходами — в деталях реализации. В первом случае детали описываем мы сами, во втором они от нас скрыты.</p>
<p>Декларативный подход читается в среднем легче, хотя на написание в обоих стилях времени может уходить одинаковое количество. (Но это тоже зависит от конкретных разработчиков, потому что кто-то мог привыкнуть к конкретному стилю.)</p>
<p>Человеческий мозг может держать одновременно в памяти ограниченное количество объектов. Если мы работаем с какой-то сложной системой, нам будет трудно одновременно помнить и о том, что она делает, и о том, как она устроена.</p>
<p>Императивный стиль смешивает <em>назначение</em> программы и <em>детали её реализации</em>, в то время как декларативный старается описывать только назначение.</p>
<p>Плюсы и минусы зависят от контекста:</p>
<ul>
<li>Если вам нужно детально описать какое-то действие — например при разработке конкретного алгоритма — то больше подходит императивный подход.</li>
<li>Если вы работаете на уровне бизнес-логики, то лучше писать декларативно, а детали реализации скрыть в более низком уровне абстракций.</li>
</ul>
<h2>Парадигмы императивного стиля</h2>
<p>Стили программирования развивались много лет, и за это время в каждом появились практики и приёмы, которые со временем стали парадигмами.</p>
<h3>Процедурное программирование</h3>
<p>Функция <code>onlyOdd</code>, которую мы написали ранее в императивном стиле как раз похожа на одну из парадигм — <em>процедурное программирование</em>.</p>
<p>Это парадигма, в которой последовательные команды собираются в подпрограммы.</p>
<p>Между собой эти подпрограммы общаются через общую память. Если проводить аналогию с функциями, то они бы общались через глобальные переменные. Как это работает, можно узнать подробнее из <a href="/js/closures/">статьи «Области видимости»</a>.</p>
<pre><code class="language-js">/* Как пример мы можем рассмотреть программу,
  которая использует «подпрограммы» (в нашем случае функции),
  меняя состояние памяти (в нашем случае простой массив битов).

  Состояние памяти потом может быть использовано,
  например, для работы с каким-то устройством. */

let memory = [0, 0, 0, 0, 0, 0, 0, 0]

function invertSmallestBit() {
  memory[7] = Number(!memory[7])
}

function invertBiggestBit() {
  memory[0] = Number(!memory[0])
}

invertSmallestBit()
// [0,0,0,0,0,0,0,1]

invertBiggestBit()
// [1,0,0,0,0,0,0,1]

invertSmallestBit()
// [1,0,0,0,0,0,0,0]
</code></pre>
<p>Из подпрограмм появилось понятие модулей, но само по себе процедурное программирование не очень удобно в плане переиспользования кода.</p>
<h3>Объектно-ориентированное программирование</h3>
<p>Самая популярная парадигма императивного стиля — ООП. Это настолько большая тема, что мы собрали о ней <a href="/js/oop/">отдельный лонгрид</a>.</p>
<p>ООП (объектно-ориентированное программирование) — парадигма, в которой сущности в программе представляются в виде объектов.</p>
<p>Каждый объект — экземпляр какого-то класса, некой абстрактной сущности, в которой описано поведение.</p>
<pre><code class="language-js">/*  Основные понятия ООП: классы и экземпляры классов.
    Класс можно воспринимать как чертёж,
    по которому создаются объекты.
    Экземпляр класса — это созданный по чертежу объект. */

/*  Класс User описывает, какие поля (name, admin)
    и методы (isAdmin, nameOf) будет содержать созданный
    по этому классу объект. */

class User {
  constructor(name) {
    this.name = name;
    this.admin = false;
  }

  isAdmin: () =&gt; this.admin;
  nameOf: () =&gt; this.name;
}

/*  Объекты создаются с помощью new.
    Свежесозданный объект содержит всё,
    что было описано в классе User. */

const user = new User('Alex');
user.isAdmin(); // false
user.nameOf();  // 'Alex'

/*  Плюс классов в том, что они позволяют
    единожды описать все одинаковые поля и методы,
    которые должны быть у однотипных объектов. */

const anotherUser = new User('Alice');
anotherUser.isAdmin(); // false
anotherUser.nameOf();  // 'Alice'
</code></pre>
<p>ООП характеризуется 4 основными аспектами:</p>
<ul>
<li>Абстракцией — выделением таких характеристик объекта, которые достаточно точно описывают его поведение, но не вдаются в детали.</li>
<li>Инкапсуляцией — размещением данных внутри того объекта, который их использует.</li>
<li>Полиморфизмом — умением работать с разными типами объектов или данных.</li>
<li>Наследованием — умением объекта «забирать по наследству» свойства или характеристики от объектов-родителей.</li>
</ul>
<p>Стоит отметить, что у наследования есть несколько нерешаемых проблем, из-за чего разработчики больше предпочитают наследованию композицию.</p>
<p><strong>Плюсы ООП</strong></p>
<p>Самый важный плюс — это <em>удобство моделирования систем</em>. Когда каждый компонент системы представлен в виде объекта, отношения между этими объектами проще регламентировать и зафиксировать.</p>
<p>Большая часть энтерпрайз-инструментов для моделирования и документации (UML, DFD, IDEF, Entity-relations) основана именно на объектно-ориентированном представлении систем.</p>
<p>Ещё один плюс — это <em>изученность подхода</em>. ООП достаточно старо, и о нём написано очень много книг и рекомендаций, а минусы хорошо изучены. Поэтому и велосипедов писать по ходу написания приложения не надо.</p>
<p><strong>Минусы ООП</strong></p>
<p>Один из принципов ООП — это инкапсуляция, из-за которой доступ к данным может быть ограничен. Если мы хотим этими данными поделиться, то может случиться, что доступ к ним хотят получить сразу несколько объектов.</p>
<p>С чтением проблем обычно нет, но если какие-то объекты хотят данные изменить, то мы наткнёмся на проблему <em>конкурентных вычислений</em>.</p>
<p>Представим, чтобы Google Docs спроектированы без учёта этой проблемы. Если два пользователя одновременно правят один и тот же документ, то правки одного могли бы затирать правки другого. Не круто.</p>
<p>Но это минус не только ООП, а вообще любой парадигмы, в которой есть общая память или общие данные.</p>
<p>Ещё одна проблема — это <em>наследование</em>. Простое наследование не всегда полностью отражает отношения компонентов.</p>
<p>Например, чайник с таймером должен наследоваться от чайника или от таймера? Хороший ответ — от того и от другого (a.k.a множественное наследование). Правильный ответ — наследованию стоит предпочесть композицию.</p>
<h2>Парадигмы декларативного стиля</h2>
<p>На контрасте с императивным стилем развивался и декларативный. В нём люди тоже собирали лучшие практики, которые со временем стали парадигмами.</p>
<h3>Логическое программирование</h3>
<p>В целом это скорее математика, чем программирование. Его суть заключается в том, чтобы, используя математические доказательства и законы логики, решать бизнес-задачи.</p>
<p>Чтобы использовать логическое программирование, необходимо уметь переводить любую задачу на язык математики.</p>
<p>Логическое программирование часто используется для моделирования процессов.</p>
<p>Для примера нам бы понадобилось тащить сюда математическую модель для него, а это надолго. Поэтому приводить примеры мы, пожалуй, не станем :–)</p>
<p>(Но дадим ссылку на <a href="http://ioctl.org/logic/prolog-latest">jsprolog</a>, который часто используется для подобного рода задач.)</p>
<h3>Функциональное программирование</h3>
<p>Самая известная парадигма декларативного стиля — <a href="/js/fp/">функциональное программирование</a>.</p>
<p>В этой парадигме понятие функции близко к математическому понятию функции. То есть это штука, которая как-то преобразует <em>входные</em> данные.</p>
<p>Особенность функции в этой парадигме в том, что она должна быть <em>чистой</em>, то есть должна зависеть только от аргументов и не может иметь никаких побочных эффектов.</p>
<p><em>Побочный эффект</em> — это какое-либо изменение внешней среды.</p>
<p>Если функция меняет глобальную переменную или, например, вызывает метод внешнего объекта, она меняет внешнюю среду. Это и есть побочный эффект.</p>
<pre><code class="language-js">// Эта функция чистая:
function double(x) {
  return x * 2
}

// ...Потому что при одинаковых вызовах
// всегда возвращает одинаковый ответ.
//
// double(2);
// double(2);
// Всегда возвращает 4.

// Следующая функция — не чистая.
let x = 1

function double() {
  x * 2
}

// ...Потому что она меняет переменную x,
// которая находится снаружи области видимости функции.
// Это называется побочный эффект.
//
// Если при одинаковом вызове ответ может быть другим:
// double(2); // x === 2;
// double(2); // x === 4;
// ...то функция не чистая.

// Эта функция — тоже не чистая.
function double() {
  return x * 2
}

// ...Потому что она зависит от переменной
// из области видимости снаружи функции.
//
// Тут тоже при одинаковом вызове ответ может быть другим:
// x = 1;
// double(); // x === 2;
// x = 2;
// double(); // x === 4;
</code></pre>
<p><strong>Плюсы ФП</strong></p>
<p>Мощь функционального программирования проявляется в <em>параллельных вычислениях</em>. Так как нет никакого общего состояния или общей памяти, параллелить вычисления можно сколько угодно, никаких негативных последствий это не вызовет.</p>
<p>Кроме этого чистые функции отлично <em>тестируются</em>, потому что не требуют сложной настройки теста. Мы прекрасно видим, что функции потребуется для проверки, потому что всё находится в списке аргументов.</p>
<p><strong>Минусы ФП</strong></p>
<p>Первый минус — <em>потребление памяти</em>. ФП требует, чтобы не было побочных эффектов. Значит, если мы хотим изменить какой-то объект, нам надо создать свежую копию этого объекта и менять её. Иногда это может приводить к большому количеству данных, которые надо держать в памяти.</p>
<p>Вселенная — это <em>побочный эффект</em>. Концепция чистых функций — это замечательно, но ФП в чистейшем его виде просто невозможно, потому что общение с пользователем, сетью, обработка ошибок — либо сами по себе побочные эффекты, либо включают их в себя.</p>
