<h2>Кратко</h2>
<p>Метод <code>add</code> добавляет значение в коллекцию <a href="/js/set/"><code>Set</code></a>. Если значение уже есть в коллекции, то вызов игнорируется.</p>
<h2>Как пишется</h2>
<p>Метод <code>add</code> вызывается со значением, которое нужно добавить в <code>Set</code>:</p>
<pre><code class="language-js">const watched = new Set()
watched.add('Отель Гранд Будапешт')
console.log(watched.size)
// 1
</code></pre>
<p>Если значение уже находится в коллекции, то вызов <code>add</code> не произведёт никакого эффекта:</p>
<pre><code class="language-js">const watched = new Set()
watched.add('Брат')
console.log(watched.size)
// 1

watched.add('Брат')
watched.add('Брат')
console.log(watched.size)
// 1
</code></pre>
<p>Метод возвращает коллекцию, у которой был вызван. Это удобно для создания цепочек:</p>
<pre><code class="language-js">const watched = new Set()
watched.add('Дюна').add('1917').add('Вверх')
</code></pre>
<h2>Как понять</h2>
<p>Коллекция <a href="/js/set/"><code>Set</code></a> хранит только уникальные значения. Добавление значений в коллекцию происходит с помощью вызова метода <code>add</code>.</p>
<p>При добавлении в коллекцию происходит проверка на наличие значения. Если значение уже есть в коллекции, то операция добавления игнорируется.</p>
<p>При проверке используется строгое равенство, значения разных типов не будут приводиться к одному. <code>5</code> и <code>'5'</code> будут добавлены в <code>Set</code> как разные элементы. Непримитивные структуры данных тоже могут быть добавлены в <code>Set</code>.</p>
<aside>
<p>☝️ Будьте осторожны при добавлении в <code>Set</code> непримитивных типов — объектов, массивов и так далее. Они могут выглядеть одинаково, но по факту быть разными объектами. Пример и рекомендации по работе с ними описаны в <a href="/js/set/">обзорной статье по <code>Set</code></a>.</p>
</aside>
