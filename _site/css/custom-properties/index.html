<p>Давайте предположим, что у нас есть веб-страница, на которой много элементов с текстом одного и того же цвета. Дизайнер создал фирменный стиль, руководство утвердило, мы начали верстать. Наш CSS мог бы выглядеть примерно так:</p>
<pre><code class="language-css">.header-primary {
  font-size: 2em;
  color: #18191C;
  margin-bottom: .5em;
}

.header-secondary {
  font-size: 1.6em;
  color: #18191C;
}

.text {
  font-family: &quot;Open Sans&quot;, sans-serif;
  color: #18191C;
  margin-top: 0;
}

.form-input {
  font-size: 1em;
  color: #18191C;
  padding-top: 4px;
  padding-bottom: 4px;
}
</code></pre>
<p>Конкретный оттенок чёрного <code>#18191C</code> используется по всей странице в совершенно разных элементах: заголовках, тексте, кнопках, полях ввода. Кажется, что это не должно создавать никаких проблем, но на самом деле есть ряд неудобств, которых хотелось бы избежать.</p>
<p>Во-первых, если завтра по какой-то причине нужно будет немного изменить оттенок чёрного, придётся это делать во многих местах.</p>
<p>Во-вторых, приходится копировать и вставлять <a href="/css/web-colors/">HEX-значение</a> цвета, ну или запоминать первые несколько символов, чтобы текстовый редактор сумел нам подсказать.</p>
<p>Все эти неудобства уходят, если использовать <strong>CSS-переменные</strong>. Чаще их называют <strong>кастомные свойства</strong>.</p>
<h2>Что это и как пишется?</h2>
<p>Кастомное свойство — это произвольное свойство с определённым значением. Оно отличается от стандартного CSS-свойства способом записи. Чтобы применить кастомное свойство, нужно передать его в CSS-функцию <code>var()</code>.</p>
<p>Стандартное свойство:</p>
<pre><code class="language-css">.list-item {
  margin-left: 10px;
}

.list-item .link {
  margin-left: 10px;
}
</code></pre>
<p>Кастомное свойство:</p>
<pre><code class="language-css">.list {
  --element-gap: 10px;
}

.list-item {
  margin-left: var(--element-gap);
}

.list-item .link {
  margin-left: var(--element-gap);
}
</code></pre>
<p>Кастомных свойств не существует в спецификации CSS. По способам применения они больше всего похожи на переменные в языках программирования. Если мы определили кастомное свойство, то в дальнейшем можно его переиспользовать сколько угодно раз.</p>
<h2>Наследование кастомных свойств</h2>
<p>Как и обычные наследуемые свойства (например, <code>font-size</code>), кастомные свойства наследуются вниз по дереву. Определив переменную в родительском элементе, мы сможем переиспользовать её в любом дочернем элементе:</p>
<pre><code class="language-html">&lt;div class=&quot;cards&quot;&gt;
  &lt;div class=&quot;card&quot;&gt;
    &lt;h2 class=&quot;card-header&quot;&gt;Тариф «Бесплатный»&lt;/h2&gt;
    &lt;ul class=&quot;benefits&quot;&gt;
      &lt;li class=&quot;benefits-item&quot;&gt;1 пользователь&lt;/li&gt;
      &lt;li class=&quot;benefits-item&quot;&gt;2 ГБ трафика&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/div&gt;
  &lt;div class=&quot;card card--primary&quot;&gt;
    &lt;h2 class=&quot;card-header&quot;&gt;Тариф «Популярный»&lt;/h2&gt;
    &lt;ul class=&quot;benefits&quot;&gt;
      &lt;li class=&quot;benefits-item&quot;&gt;До 5 пользователей&lt;/li&gt;
      &lt;li class=&quot;benefits-item&quot;&gt;20 ГБ трафика&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/div&gt;
&lt;/div&gt;
</code></pre>
<pre><code class="language-css">.cards {
  --main-color: #E6E6E6;
}

.card-header, .benefits-item {
  color: var(--main-color);
}

.card--primary {
  --main-color: black;
}
</code></pre>
<p>В примере мы переопределяем значение переменной для карточки с классом <code>.card--primary</code>, и все дочерние элементы меняют цвет. В этом и кроется основная мощь CSS-переменных. Изменяем значение в одном месте, а затрагиваем все места, где используется переменная.</p>
<iframe title="Наследование кастомных свойств" src="demos/index/" height="340"></iframe>
<p>Но что, если мы заранее не знаем, какой будет вложенность элементов? Можно задать кастомное свойство корневому элементу страницы <code>&lt;html&gt;</code>, и тогда оно гарантированно будет доступно в каждом элементе страницы. Но обычно для этих целей используют псевдокласс <a href="/css/root/"><code>:root</code></a>, который является псевдонимом для <code>&lt;html&gt;</code>:</p>
<pre><code class="language-css">:root {
  --gap-small: 10px;
  --gap-medium: 20px;
}
</code></pre>
<p>В первом примере цвет <code>#18191C</code> используется в самых разных элементах страницы. Мы можем назначить этот цвет кастомному свойству с осмысленным названием и дальше везде использовать именно это свойство. Очень удобно, ведь запомнить название свойства проще, чем HEX-код цвета:</p>
<pre><code class="language-css">:root {
  --text-color: #18191C;
}

.header-primary {
  font-size: 2em;
  color: var(--text-color);
  margin-bottom: .5em;
}

.header-secondary {
  font-size: 1.6em;
  color: var(--text-color);
}

.text {
  font-family: &quot;Open Sans&quot;, sans-serif;
  color: var(--text-color);
  margin-top: 0;
}

.form-input {
  font-size: 1em;
  color: var(--text-color);
  padding-top: 4px;
  padding-bottom: 4px;
}
</code></pre>
<p>Обратите внимание: кастомные свойства, объявленные в <code>:root</code>, тоже при необходимости могут быть переопределены:</p>
<pre><code class="language-css">:root {
  --main-color: #18191C;
}

.article-promo {
  --main-color: #272822;
}
</code></pre>
<h2>Запасные значения</h2>
<p>Если по какой-то причине значение переменной не определено, мы можем передавать в функцию <code>var()</code> второй параметр, который станет «запасным» значением. По аналогии со свойством <a href="/css/font-family/"><code>font-family</code></a>. Если не найдено первое значение, браузер будет подставлять следующее:</p>
<pre><code class="language-css">.section-title {
  color: var(--primary-color, #222);
}
</code></pre>
<p>В качестве запасного значения может быть передана функция <code>var()</code>, которая в свою очередь также может иметь запасное значение:</p>
<pre><code class="language-css">.section-title {
  color: var(--primary-color, var(--black, #222));
}
</code></pre>
<h2>Корректность использования</h2>
<p>У стандартных CSS-свойств типы значений предопределены, поэтому браузер понимает, правильно ли мы употребляем значение.</p>
<p>Используем HEX-запись цвета для свойства <code>color</code>. Это правильно.</p>
<pre><code class="language-css">.valid-value {
  color: #272822;
}
</code></pre>
<p>Используем размерную величину для свойства <code>color</code>. Это неправильно.</p>
<pre><code class="language-css">.invalid-value {
  color: 10px;
}
</code></pre>
<p>У кастомных свойств всё иначе. Значения вычисляются в браузере непосредственно перед отрисовкой страницы. Браузер заранее не знает, в каком месте будет применено кастомное свойство, поэтому по умолчанию считает любую переменную корректной. И только после подстановки значения свойству браузер узнаёт, правильно ли мы его применили. Для такого поведения есть причины, рассмотрим пример:</p>
<pre><code class="language-css">:root {
  --big-header: 20px;
}

.promo-header {
  color: var(--big-header);
}
</code></pre>
<p>В этом примере браузер подставляет значение переменной <code>--big-header</code> (<code>20px</code>) в качестве значения свойства <code>color</code>, но это не имеет смысла. В такой ситуации браузер делает две вещи:</p>
<ul>
<li>Проверяет, является ли свойство наследуемым. Если да, то значение для него ищется выше по дереву.</li>
<li>Если свойство не наследуемое или значение не найдено выше по дереву, то берётся начальное значение по умолчанию (<code>initial</code>). Для свойства <code>color</code> у заголовка это будет <code>black</code>.</li>
</ul>
<h2>Использование в JavaScript</h2>
<p>В JavaScript значения кастомных свойств используются точно так же, как и значения стандартных CSS-свойств.</p>
<p>Чтобы получить значение:</p>
<pre><code class="language-js">element.style.getPropertyValue(&quot;--main-color&quot;)
</code></pre>
<p>Чтобы задать значение:</p>
<pre><code class="language-js">element.style.setProperty(&quot;--translate&quot;, `${currentScroll}px`)
</code></pre>
<h2>Подсказки</h2>
<p>Кастомные свойства можно использовать в любых других функциях. Например, в функции <a href="/css/calc/"><code>calc()</code></a>.</p>
<pre><code class="language-css">.logo {
  display: inline-block;
  width: calc(var(--size, 1) * 15px);
  height: calc(var(--size, 1) * 15px);
}

.logo--small {
  --size: 2;
}

.logo--medium {
  --size: 3;
}

.logo--big {
  --size: 4;
}
</code></pre>
<p>В этом примере мы задали значение по умолчанию, равное <code>1</code>. Если будет использоваться только класс <code>.logo</code>, браузер установит <code>--size: 1</code>. Если будет применён один из классов-модификаторов, значение <code>--size</code> будет переопределено, и ширина и высота элемента будут пересчитаны благодаря использованию <a href="/css/calc/"><code>calc()</code></a>.</p>
<p>А вот так можно применить CSS-переменную в функции <a href="/css/linear-gradient/"><code>linear-gradient</code></a>.</p>
<pre><code class="language-css">.element {
  --angle: 45deg;
  background-image: linear-gradient(var(--angle), #235ad1, #23d1a8);
}

.element--inverted {
  --angle: -45deg;
}
</code></pre>
