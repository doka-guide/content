<h2>Кратко</h2>
<p>CSS-функция <code>var()</code> позволяет подставлять <a href="/css/custom-properties/">кастомные свойства</a> в качестве значения свойств.</p>
<h2>Пример</h2>
<p>Объявляем кастомное свойство:</p>
<pre><code class="language-css">:root {
  --color-cyan: #00ffff;
}
</code></pre>
<p>Используя функцию <code>var()</code> подставляем значение кастомного свойства:</p>
<pre><code class="language-css">.button {
  background-color: var(--color-cyan);
}
</code></pre>
<h2>Как это понять</h2>
<p>Функция <code>var()</code> возвращает <strong>текущее</strong> значение кастомного свойства. Если оно поменяется, то функция <code>var()</code> сразу вернёт актуальное значение.</p>
<details>
  <summary>Механизм работы <code>var()</code></summary>
<p>Передав в функцию <code>var()</code> кастомное свойство, браузер двигается вверх по иерархии элементов в поисках значения кастомного свойства.</p>
<p>Он проверит, установлено ли кастомное свойство на текущем элементе:</p>
<ul>
<li>Если да, подставит вместо <code>var()</code> и остановит поиск.</li>
<li>Если нет, переходит на родительский элемент и повторяет проверку.</li>
</ul>
<p>Браузер будет подниматься вверх по родительским элементам до тех пор пока не найдёт значение. Последней точкой будет проверка наличия значения в <code>:root</code>. Если его нет и там, то функция <code>var()</code> установит значение в <code>initial</code> или резервное значение если он передано.</p>
</details>
<p>Определим кастомное свойство:</p>
<pre><code class="language-css">:root {
  --card-color: lightblue;
}
</code></pre>
<p>Зададим цвет фона карточке, используя функцию <code>var()</code>. Цвет будет <em>синий</em>:</p>
<pre><code class="language-css">.card {
  background-color: var(--card-color);
}
</code></pre>
<p>Изменим кастомное свойство с помощью JavaScript:</p>
<pre><code class="language-js">document.documentElement.style.setProperty('--card-color', 'orange')
</code></pre>
<p>Теперь там, где установлен цвет фона, функция <code>var()</code> вернёт <em>оранжевый</em> цвет.</p>
<iframe title="Подмена значения кастомного свойства" src="demos/substitution/" height="300"></iframe>
<h2>Как пишется</h2>
<h3>Базовый синтаксис</h3>
<p>Функция <code>var()</code> принимает 2 аргумента:</p>
<ol>
<li>Имя кастомного свойства.</li>
<li>Резервное значение (необязательный).</li>
</ol>
<p>Если кастомное свойство, на которое ссылается первый аргумент, недопустимо, функция использует второе значение:</p>
<pre><code class="language-css">.card {
  padding: var(--card-padding, 10px);
}
</code></pre>
<p>Значение <code>padding</code> будет <code>10px</code>, если <code>--card-padding</code> не определено.</p>
<p>Можно указать несколько резервных значений. Для этого вторым аргументом нужно передать функцию <code>var()</code> с возможными значениями:</p>
<pre><code class="language-css">.title {
  font-size: var(--font-size, var(--title-font-size, 20px));
}
</code></pre>
<p>Значение <code>font-size</code> будет <code>20px</code>, если <code>--font-size</code> и <code>--title-font-size</code> не определены.</p>
<h3>Резервное значение</h3>
<p>Ещё один пример, но немного неочевидный. Если переменная <code>--font-size</code> не определена, то резервное значение будет: <code>--title-font-size, 20px</code>. К сожалению, оно не валидно:</p>
<pre><code class="language-css">.title {
  font-size: var(--font-size, --title-font-size, 20px);
}
</code></pre>
<p>Дело в том, что всё, что находится после первой запятой, воспринимается как <em>единое значение</em>. То есть в качестве резервного значения функция вернёт <strong>значение от первой запятой до закрывающей скобки</strong>.</p>
<p>А такой пример валидный. Резервное значение будет: <code>10px, 10px</code>:</p>
<pre><code class="language-css">.navigation {
  --translate: var(--my-translate, 10px, 10px);
  transform: translate(var(--translate));
}
</code></pre>
<details>
  <summary>О валидности значений</summary>
<pre><code class="language-css">:root {
  --text-color: 16px;
}

.element {
  color: var(--text-color);
}
</code></pre>
<p>В этом примере кастомное свойство <code>--text-color</code> имеет значение <code>16px</code>, что технически является валидным. Но, когда браузер подставляет значение <code>--text-color</code> вместо <code>var(--text-color)</code>, он пытается использовать значение <code>16px</code>, которое не является допустимым значением для свойства <code>color</code>.</p>
<p>Браузер рассматривает его как недопустимое значение и проверяет, наследуется ли свойство <code>color</code> от родительского элемента. Если да, он его использует. В противном случае устанавливает значение <code>initial</code>.</p>
</details>
<h3>Возможности</h3>
<p>Функцию <code>var()</code> можно подставить как часть значения свойства:</p>
<pre><code class="language-css">.card {
  --border-color: black;
  border: 1px solid var(--border-color);
}
</code></pre>
<p>Функция <code>var()</code> также работает с сокращёнными свойствами: <code>margin</code>, <code>padding</code>, <code>border</code>, <code>background</code>, <code>transform</code>, <code>transition</code> и т. д.</p>
<p>Можно использовать для подставки как одного значения:</p>
<pre><code class="language-css">.element {
  --margin-top: 10px;
  margin: var(--margin-top) 10px 20px 30px;
}
</code></pre>
<p>Так и для нескольких:</p>
<pre><code class="language-css">.element {
  --margin-top-right: 10px 10px;
  margin: var(--margin-top-right) 10px 50px;
}
</code></pre>
<h3>Ограничения</h3>
<p>Функция <code>var()</code> <strong>не может</strong> использоваться в качестве имён свойств, селекторов или чего-либо ещё, кроме <em>значений свойств</em>.</p>
<p>Например, следующий код неправильно использует кастомное свойство в качестве имени свойства:</p>
<pre><code class="language-css">.element {
  --side: margin-top;
  var(--side): 20px;
}
</code></pre>
<p>Вы <strong>не можете</strong> объединять кастомное свойство и любое другое значение таким образом:</p>
<pre><code class="language-css">.element {
  --gap: 20;
  margin-top: var(--gap)px;
}
</code></pre>
<p>Вместо этого вы можете использовать такой приём:</p>
<pre><code class="language-css">.element {
  --gap: 20;
  margin-top: calc(var(--gap) * 1px);
}
</code></pre>
<p>Либо записать полное значение в кастомное свойство:</p>
<pre><code class="language-css">.element {
  --gap: 20px;
  margin-top: var(--gap);
}
</code></pre>
<h3>Внутри других функций</h3>
<p>Также работает с такими функциями:</p>
<p><code>calc()</code></p>
<pre><code class="language-css">.element-1 {
  --offset: 50px;
  height: calc(100vh - var(--offset));
}

.element-2 {
  --height: 100vh - 50px;
  height: calc(var(--height));
}
</code></pre>
<p><code>rgb()</code> и <code>rgba()</code></p>
<pre><code class="language-css">.element-1 {
  --rgb: 0, 0, 0;
  color: rgba(var(--rgb), 1);
}

.element-2 {
  --rgb: 0, 0, 0;
  color: rgb(var(--rgb));
}

.element-3 {
  --red: 0;
  --green: 0;
  --blue: 0;
  color: rgb(var(--red), var(--green), var(--blue));
}
</code></pre>
<p><code>linear-gradient()</code> и <code>radial-gradient()</code></p>
<pre><code class="language-css">:root {
  --c1: red;
  --c2: blue;
  --grad: linear-gradient(var(--c1),var(--c2));
}

.element {
  --c1: green;
  background:var(--grad);
}
</code></pre>
<p><code>url()</code></p>
<pre><code class="language-css">:root {
  --url: url(&quot;https://example.com/example.jpg&quot;);
}

.element {
  background: var(--url);
}
</code></pre>
<p>Но такой пример работать не будет, так как функция <code>url()</code> воспринимает конструкцию <code>var(--url)</code> как URL:</p>
<pre><code class="language-css">:root {
  --url: &quot;https://example.com/example.jpg&quot;;
}

.element {
  background: url(var(--url));
}
</code></pre>
