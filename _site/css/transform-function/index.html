<h2>Кратко</h2>
<p>Трансформации к элементу применяются при помощи свойства <a href="/css/transform/"><code>transform</code></a>. А значением для этого свойства являются функции трансформации.</p>
<h2>Пример</h2>
<pre><code class="language-css">.element {
  transform: translateX(120px);
}
</code></pre>
<h2>Как это понять</h2>
<p>Часто бывает необходимо каким-то образом трансформировать визуальное представление элемента (масштабировать, повернуть, переместить) и при этом никак не затронуть соседние элементы в документе. Для подобных преобразований используется свойство <a href="/css/transform/"><code>transform</code></a>. В качестве значения выступают различные функции трансформации: <code>rotate</code>, <code>translate</code>, <code>scale</code>, <code>skew</code> и другие.</p>
<iframe title="Песочница свойства transform" src="demos/sandbox/" height="500"></iframe>
<p>Функции трансформации можно условно разбить на несколько групп.</p>
<h3>Функции перемещения</h3>
<h4><code>translate(X, Y)</code></h4>
<p>Функция используется для смещения элемента вверх-вниз или влево-вправо. В целом, ту же работу выполняют CSS-свойства <code>top</code>, <code>right</code>, <code>bottom</code>, <code>left</code> — например, для абсолютно (<code>position: absolute</code>) или относительно (<code>position: relative</code>) спозиционированных элементов. Но есть ряд важных отличий: элемент позиционируется относительно соответствующих сторон родителя. То есть, <code>left: 20px</code> сместит элемент на 20 пикселей относительно левой границы родителя, а <code>translate(20px)</code> смещает элемент вправо относительно того места, где элемент находился до трансформации. В целом, позиционирование и <code>translate</code> прекрасно сочетаются друг с другом. Позиционирование лучше использовать для изначального расположения элемента на странице, а <code>translate</code> применять, если нужно добавить анимации движения.</p>
<p>Функция принимает два параметра: первый параметр отвечает за смещение вправо-влево, а второй параметр — вверх-вниз. Если передать только один параметр, тогда смещение будет только вправо-влево. Мы можем использовать любые единицы измерения расстояния из CSS, например, абсолютные <code>10px</code> или относительные <code>50%</code>. Абсолютное значение используется «как есть»: элемент сместится на 10 пикселей. Относительное значение считается относительно размеров самого элемента. При указании <code>50%</code> элемент сместится на половину собственной ширины или высоты.</p>
<h4><code>translateX(X)</code>, <code>translateY(Y)</code>, <code>translateZ(Z)</code></h4>
<p>Когда нужно сместить элемент вдоль конкретной оси, можно применить соответствующие функции трансформации.</p>
<h4><code>translate3d(X, Y, Z)</code></h4>
<p>Если нужно сместить элемент по всем трём осям, можно всё собрать в кучку и использовать эту функцию.</p>
<h3>Функции масштабирования</h3>
<h4><code>scale(X, Y)</code></h4>
<p>Функция для масштабирования элемента. Значения <code>X</code> и <code>Y</code> — это положительные числа, либо 0. Если в функцию передать 0, то элемент не будет виден. Единица соответствует нормальному масштабу. Числа от 0 до 1 — это уменьшенный масштаб. Числа больше единицы — увеличенный масштаб. Например, чтобы визуально увеличить элемент в 2 раза, нужно написать <code>transform: scale(2)</code>.</p>
<p>В отличие от <code>translate</code>, один параметр в функции <code>scale</code> работает несколько иначе. <code>scale(2)</code> — это то же самое, что <code>scale(2, 2)</code>, то есть одно число указывает на пропорциональное масштабирование по обеим осям одновременно.</p>
<h4><code>scaleX(X)</code>, <code>scaleY(Y)</code>, <code>scaleZ(Z)</code></h4>
<p>Используем, когда необходимо растягивать или сжимать элемент только по горизонтали, вертикали или третьей оси <code>Z</code>.</p>
<h4><code>scale3d(X, Y, Z)</code></h4>
<p>Если нужно масштабировать элемент по всем трём осям, можно всё собрать в кучку и использовать эту функцию.</p>
<h3>Функции наклона</h3>
<h4><code>skewX(X)</code>, <code>skewY(Y)</code></h4>
<p>Функции выполняют сдвиг одной стороны элемента относительно противолежащей. В результате элемент как бы наклоняется. Величина наклона зависит от положения <em>точки применения трансформаций</em> (<a href="/css/transform-origin/"><code>transform-origin</code></a>) и числа градусов, заданных в параметрах. <code>skewX</code> сдвигает верхнюю сторону элемента относительно нижней. <code>skewY</code> — правую сторону относительно левой.</p>
<h3>Функции поворота</h3>
<h4><code>rotateX(X)</code>, <code>rotateY(Y)</code>, <code>rotateZ(Z)</code></h4>
<p>Кроме сдвига или наклона, элемент можно вращать. В функцию передаём единицы измерения углов (<code>deg</code>, <code>rad</code>, <code>turn</code>), например <code>45deg</code> или <code>0.5turn</code>. Обратите внимание, что обычное вращение элемента на странице — это вращение относительно оси <code>Z</code>. Если мы хотим вращать элемент относительно других осей, то нужно не забывать про перспективу. С ней повороты относительно <code>X</code> или <code>Y</code> будут выглядеть максимально естественно.</p>
<h4><code>rotate(Z)</code></h4>
<p>Функция аналогична <code>rotateZ(Z)</code>. Чтобы не запоминать ось для типового вращения элемента, мы можем использовать просто слово <code>rotate</code>.</p>
<h4><code>rotate3d(X, Y, Z)</code></h4>
<p>Если нужно повернуть элемент по всем трём осям, можно всё собрать в кучку и использовать эту функцию.</p>
<h3>Прочие функции</h3>
<h4><code>matrix(a, b, c, d, tx, ty)</code></h4>
<p>Выше мы упомянули несколько функций трансформации. Каждая выполняет какое-то одно небольшое действие. <code>matrix()</code> — это функция, которой можно описать любую трансформацию в плоскости экрана. Она использует матричные преобразования и может заменить собой все вышеописанные функции. Но при этом она очень сложно читается. Например, глядя на функцию <code>matrix(0.707107, 0.707107, -0.707107, 0.707107, -0.707107, 34.6482)</code> невозможно сразу точно определить, что она аналогична записи <code>rotate(45deg) translate(24px, 25px)</code>. Зачем же она нужна, такая сложная, если проще описать трансформации соответствующими функциями? Ну например, с её помощью можно писать сложные динамические анимации. Популярные JS-библиотеки для анимации «под капотом» используют как раз матричные преобразования, а не конкретные функции трансформации.</p>
<h4><code>matrix3d(a1, b1, c1, d1, a2, b2, c2, d2, a3, b3, c3, d3, a4, b4, c4, d4)</code></h4>
<p>Если нам нужно произвести трансформации в трёхмерном пространстве, а не в плоскости экрана, то нужно использовать эту функцию. Она ещё более сложна в понимании, и навряд ли кто-то вообще пишет её руками.</p>
<h4><code>perspective(Z)</code></h4>
<p>Несмотря на то, что экран плоский, у нас всё равно есть возможность перемещать элемент вдоль оси <code>Z</code>. Она направлена перпендикулярно плоскости экрана в сторону пользователя. Если мы используем <code>translateZ</code> просто так, то никакого перемещения ближе или дальше мы не увидим. Чтобы было ощущение движения к нам или от нас, элемент должен становиться крупнее или мельче. Стул, который стоит рядом с нами, будет визуально крупнее, чем стул, стоящий в конце комнаты. Эта разница в размерах — следствие <em>перспективы</em>. Элемент на экране может вести себя подобно объектам в реальном мире и менять размер при перемещении к нам или от нас. Чтобы это заработало, нужно элементу задать свойство <a href="/css/perspective/"><code>perspective</code></a>. Это свойство необходимо применять при любых трансформациях, выходящих из плоскости экрана.</p>
<p>Функция <code>perspective()</code> принимает один параметр — расстояние до точки схождения перспективы. Плоскость экрана принимается за начало координат. Например, запись <code>perspective(500px)</code> означает, что точка схождения перспективы находится как бы на расстоянии 500 пикселей вглубь от плоскости экрана.</p>
<h2>Подсказки</h2>
<p>💡 Можно применять сразу несколько функций трансформаций:</p>
<pre><code class="language-css">.element {
  transform: translate(20px, 20px) skew(20deg);
}
</code></pre>
<p>💡 Если среди значений есть функция <code>perspective()</code>, то она должна быть первой среди всех значений:</p>
<p>Неправильно:</p>
<pre><code class="language-css">.element {
  transform: translate3d(10px, 0, 20px) rotateY(3deg) perspective(500px);
}
</code></pre>
<p>Правильно:</p>
<pre><code class="language-css">.element {
  transform: perspective(500px) translate3d(10px, 0, 20px) rotateY(3deg);
}
</code></pre>
<p>💡 В последних версиях спецификации появились отдельные CSS-свойства для трансформаций. Это <code>rotate</code>, <code>translate</code> и <code>scale</code>. Если раньше мы писали комплексные трансформации, применяя несколько функций, то теперь каждую трансформацию можем описать отдельным свойством:</p>
<pre><code class="language-css">.transform-function {
  transform: translate(100px, 100px) rotate(180deg) scale(2);
}

.individual-transforms {
  translate: 100px 100px;
  rotate: 180deg;
  scale: 2;
}
</code></pre>
<p>Оба этих способа записи выполнят одни и те же трансформации, но у них есть ряд принципиальных отличий. Самое главное — используя индивидуальные свойства мы можем создавать классы-модификаторы без опасения перекрыть всё свойство <code>transform</code>:</p>
<pre><code class="language-css">.element {
  transform: translateX(20px) rotate(90deg);
}

.mid-scale {
  scale: 1.5;
}
</code></pre>
<p>В этом случае мы просто добавим масштабирование к элементу, какие бы свойства ни были ему заданы до этого. Подобный трюк <em>не удастся</em> провернуть со свойством <code>transform</code>:</p>
<pre><code class="language-css">.element {
  transform: translateX(20px) rotate(90deg);
}

.mid-scale {
  transform: scale(1.5);
}
</code></pre>
<p>Добавив этот класс к элементу, мы просто рискуем перекрыть любое свойство <code>transform</code>, заданное до этого.</p>
<p>💡 При использовании свойства <code>transform</code> результирующая трансформация вычисляется с учётом порядка функций. Например, <code>transform: rotate(15deg) translateX(100px) translateY(30px)</code> и <code>transform: translateX(100px) translateY(30px) rotate(15deg);</code> дадут разный конечный результат:</p>
<iframe title="Порядок функций" src="demos/funcs-order/" height="380"></iframe>
<p>Если же мы используем индивидуальные свойства, результат будет одинаковым вне зависимости от порядка свойств:</p>
<iframe title="Правильный порядок функций" src="demos/funcs-right-order/" height="380"></iframe>
<p>Второй пример нужно смотреть либо в Firefox, либо в Chrome Canary.</p>
