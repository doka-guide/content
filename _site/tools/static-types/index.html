<h2>Кратко</h2>
<p>В JavaScript <strong>слабая динамическая</strong> типизация. Это означает две вещи:</p>
<ol>
<li>Любая переменная может произвольно менять свой тип во время выполнения программы.</li>
<li>При операциях с переменными разных типов они будут автоматически приведены к одному типу.</li>
</ol>
<p>Эти свойства языка часто мешают создавать большие надёжные приложения. Поэтому появились решения, которые расширяют язык, добавляя в него строгую статическую типизацию. «Строгая» означает запрет автоматического приведения типов, «статическая» значит, что переменные не меняют свой тип. Самое популярное решение в этой области — <a href="https://www.typescriptlang.org/"><strong>TypeScript</strong></a>. Другие, менее популярные — <a href="https://flow.org/">Flow</a>, <a href="https://hegel.js.org/">Hegel</a>.</p>
<h2>Как пользоваться</h2>
<h3>Настройка</h3>
<p>TypeScript — это язык, очень похожий на JavaScript. Браузеры и Node.js не умеют исполнять его, поэтому без этапа сборки пользоваться им нельзя.</p>
<p>Все современные системы сборки умеют работать с TypeScript: Parcel поддерживает его без дополнительных манипуляций, для Webpack и Rollup есть плагины. Их объединяет одно — необходимо создать файл <em>tsconfig.json</em>, который опишет, как превратить TypeScript-код в JavaScript-код. Правила создания конфигурационного файла описаны на <a href="https://www.typescriptlang.org/docs/handbook/tsconfig-json.html">сайте TypeScript</a>.</p>
<pre><code class="language-js">{
  &quot;compilerOptions&quot;: {
    // Указываем папку, куда попадёт результат
    &quot;outDir&quot;: &quot;./dist&quot;,
  },
  // Указываем, какие файлы следует компилировать
  &quot;include&quot;: [&quot;src/**/*&quot;],
  // Внешние зависимости обычно исключают из списка компилируемых файлов
  &quot;exclude&quot;: [&quot;node_modules&quot;]
}
</code></pre>
<p>После этого достаточно писать код в файлах с расширением <em>.ts</em> вместо <em>.js</em>.</p>
<h3>Язык</h3>
<p>Главное отличие TypeScript от JavaScript — возможность добавлять аннотации типов к переменным, аргументам функций и их возвращаемым значениям.</p>
<pre><code class="language-tsx">// Теперь переменной age можно присвоить только число
let age: number

// Будет работать
age = 43

// Выдаст ошибку
age = &quot;34&quot;
</code></pre>
<p>Важно заметить, что ошибки несовпадения типов будут заметны уже на стадии написания кода. То есть не нужно запускать программу, чтобы узнать, что в коде допущены ошибки с типизацией.</p>
<p><img src="images/compare.png" alt="Сравнение процесса доставки в JS и TS"></p>
<p>Проверка корректности типов — это разновидность <a href="/tools/static-analysis/">статического анализа</a>. Его можно провести, не запуская код.</p>
<p>Примерно таким же образом можно типизировать параметры функции:</p>
<pre><code class="language-tsx">function sayMyName(name: string) {
  console.log(`Привет, ${name}`)
}

// Будет работать
sayMyName(&quot;Igor&quot;)

// Выдаст ошибку
sayMyName(42)
</code></pre>
<p>Ошибка несовпадения типов будет заметна на этапе написания кода, и до запуска программы не дойдёт.</p>
<p>В TypeScript можно типизировать не только параметры функции, но и возвращаемое значение.</p>
<pre><code class="language-tsx">function getCurrentDate(): Date {
  // Будет работать
  return new Date()
}

function getCurrentDate(): Date {
  // Выдаст ошибку
  return &quot;now&quot;
}
</code></pre>
<p>Другая особенность TypeScript — строгость типизации. Он запрещает операции с переменными разных типов, чтобы не допустить неоднозначности результата.</p>
<pre><code class="language-tsx">const age = 43
const name = &quot;Mary&quot;

// Выдаст ошибку, складывать числа и строки нельзя
const result = age + name
</code></pre>
<h2>Как понять</h2>
<p>TypeScript — надмножество JavaScript. На практике это означает, что любой JavaScript-код является корректным TypeScript-кодом. А вот обратное неверно.</p>
<p>Главное преимущество строгой статической типизации — возможность найти ряд ошибок ещё на этапе написания кода. Например, классическая ошибка, когда в переменной не оказывается значения, приводит в JavaScript к ошибке во время выполнения, когда код уже работает в браузере. Такая ошибка может затронуть пользователей.</p>
<pre><code class="language-tsx">function generateEmail(user) {
  return `${user.name}@mycompany.com`
}

// При вызове функции программист передает другой объект,
// и происходит ошибка во время выполнения, пользователь её замечает
generateEmail({ fullName: &quot;Пётр Сергеевич Никольский&quot; })
</code></pre>
<p>Если переписать этот пример на TypeScript, потенциальная проблема исчезнет:</p>
<pre><code class="language-tsx">// Аргумент функции всегда должен быть объектом,
// у которого есть строковое поле name
function generateEmail(user: { name: string }) {
  return `${user.name}@mycompany.com`
}

// При вызове функции программист передает другой объект,
// происходит ошибка во время сборки, программист её замечает и исправляет
generateEmail({ fullName: &quot;Петр Сергеевич Никольский&quot; })
</code></pre>
<p>Чем раньше обнаруживается ошибка, тем легче её исправить. Поэтому статическая типизация, <a href="/tools/static-analysis/">статический анализ</a> и <a href="/js/how-to-test-and-why/">написание автоматизированных тестов</a> — это правила хорошего тона в современной разработке приложений. По сути, статическая типизация (как и статический анализ) добавляет в процесс разработки программы ещё один шаг — проверку типов, который выполняется перед сборкой проекта и может помочь найти ошибки на раннем этапе.</p>
<p><img src="images/extra-step.png" alt="Сравнение этапов доставки приложения без TypeScript и с ним"></p>
<p>На первый взгляд кажется, что явное объявление типов заставляет писать много лишнего кода. На самом деле это иллюзия. Аннотации типов — способ обеспечить большую надёжность написанного кода.</p>
<p>TypeScript — это язык с опциональной типизацией. Он не заставляет программиста указывать типы, можно просто писать код как раньше. TypeScript постарается сам определить типы из контекста, и дать подсказки. Если контекст непонятен языку, он пометит тип переменной как <code>any</code>. Это означает, что в ней может лежать значение любого типа.</p>
<pre><code class="language-tsx">// Видимо, переменная должна иметь тип number
const age = 12

// Язык не знает, какой тип имеет аргумент name,
// он пометит его как any
function sayMyName(name) {
  console.log(`Привет, ${name}`)
}
</code></pre>
<p>Эта особенность языка называется выводом типов и присутствует во многих современных языках программирования. К сожалению, она не слишком развита в TypeScript, и чаще всего приходится всё-таки «подсказывать» компилятору типы. В других языках, например, в Scala, она развита сильнее, там типы приходится указывать значительно реже.</p>
