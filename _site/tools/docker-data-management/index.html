<p>В этой статье мы поговорим про управление данными приложений в Docker. Узнать, что такое Docker, вы сможете из статьи «<a href="/tools/docker/">Что такое Docker</a>». Также вы можете почитать о <a href="/tools/docker-compose/">мультиконтейнерных приложениях и Docker Compose</a> и о том, <a href="/tools/dockerfile/">как устроен Dockerfile</a>.</p>
<p>Итак, по умолчанию все данные приложения хранятся в контейнере Docker и после остановки контейнера теряются. Но это не единственный способ работать с данными. Можно использовать оперативную память и файловую систему компьютера, на котором установлен Docker Engine. Существует несколько типов хранилищ данных:</p>
<ul>
<li>связанные папки, примонтированные к контейнеру как внешние диски (bind mounts);</li>
<li>тома (volumes);</li>
<li>часть оперативной памяти для работы с данными (tmpfs mounts или npipe mounts).</li>
</ul>
<p>Вне зависимости от того, какой тип хранилища вы выберете, данные для приложения будут храниться в заданной вами папке внутри контейнера. Технология работает бесшовно, но имеет свои накладные расходы для каждого конкретного типа.</p>
<p>Наглядная схема типов управления данными в Docker:</p>
<p><img src="images/docker-data-types.png" alt="Наглядная схема типов управления данными в Docker."></p>
<p>Рассмотрим каждый тип по отдельности.</p>
<h2>Связанные папки (bind mounts)</h2>
<p>Связанные папки появились в Docker с самых первых релизов. Это удобный инструмент, но у него есть ограничения. Этот тип управления данными позволяет связать папку на компьютере пользователя (то есть хосте, на котором установлен Docker Engine) и папку в контейнере. Работать в контейнере и на хосте с такой папкой можно одновременно, все изменения будут отображаться и там, и там. Механизм bind mounts подразумевает, что данные могут быть изменены в любое время как из подключённого контейнера, так и непосредственно на хосте.</p>
<p>При создании связанной папки указывается полный путь к ней на хосте и путь внутри контейнера. Если папка не существует на хосте, Docker может создать её сам.</p>
<p>Связанные папки используются:</p>
<p><strong>Когда конфигурационные файлы на хосте и в контейнере одни и те же.</strong> Именно этот тип использует сам Docker для автоматического монтирования конфигурации DNS хоста.</p>
<p><strong>Когда работаем с исходным кодом и артефактами сборок.</strong> Можно использовать системы сборки для исходного кода внутри контейнера. Вы меняете код, <a href="/tools/bundlers/">бандлер</a>, который находится внутри контейнера, это видит, и код попадает в новую сборку. Другой вариант использования — работа с уже собранными бандлами, например, для тестирования или отладки приложений.</p>
<p><strong>Когда необходимо обеспечить создание одной и той же файловой структуры на различных компьютерах.</strong> Если папки на компьютере пользователя не существует, она будет создана при сборке образа и запуске контейнера.</p>
<h3>Как пользоваться</h3>
<p>Чтобы связать папку на хосте с папкой внутри контейнера, можно воспользоваться флагами <code>-v</code> или <code>--mount</code>. <code>$(pwd)</code> в командах ниже означает, что примонтируется текущая папка на хосте.</p>
<p>Пример с флагом <code>-v</code>:</p>
<pre><code class="language-bash">docker run -d \
  -it \
  --name devtest \
  -v &quot;$(pwd)&quot;/target:/app \
  node:lts
</code></pre>
<p>Можно задать следующие опции: <code>rprivate</code>, <code>private</code>, <code>rshared</code>, <code>shared</code>, <code>rslave</code>, <code>slave</code>, <code>ro</code>, <code>z</code> и <code>Z</code>.</p>
<p>Первые шесть параметров позволяют управлять тем, как будут влиять изменения в одной точке монтирования тома на другие точки монтирования. По умолчанию используется <code>rprivate</code>, что означает — никак.</p>
<p>Последние три параметра могут быть указаны только для флага <code>-v</code>. Значение <code>ro</code> определяет режим только для чтения. Папка на хосте не может быть изменена внутри контейнера. Значение <code>z</code> обозначает, что папка на хосте может быть использована несколькими контейнерами. Значение <code>Z</code> обозначает, что папка используется только одним контейнером. Не указывайте значение <code>Z</code> для системных папок, например, <em>/usr</em> или <em>/home</em>. Это приведёт к тому, что работа операционной системы на хосте будет парализована. Будьте аккуратны!</p>
<p>Пример с флагом <code>--mount</code>:</p>
<pre><code class="language-bash">docker run -d \
  -it \
  --name devtest \
  --mount type=bind,source=&quot;$(pwd)&quot;/target,target=/app \
  node:lts
</code></pre>
<details>
  <summary>Ключ <code>bind-propagation</code></summary>
<p>Для флага <code>--mount</code> есть ключ <code>bind-propagation</code>, который работает только на Linux (операционные системы контейнера и хоста должны поддерживать этот режим работы).</p>
<p>Представьте, есть две точки монтирования <code>/mnt1</code> и <code>/mnt2</code>, к которым привязана одна и та же папка на хосте. Значения ключа <code>bind-propagation</code> определяют, что произойдёт, если в связанной папке появятся подпапки. Что произойдёт с <code>/mnt2/sub</code> при монтировании <code>/mnt1/sub</code>? Возможны следующие варианты:</p>
<p>— <code>shared</code> указывает на то, что изменения для точки монтирования <code>/mnt1/sub</code> будут в точности отражаться в <code>/mnt2/sub</code> и наоборот;
— <code>slave</code> указывает на то же, что <code>shared</code>, но только в одном направлении (изменения в первой точке монтирования будут распространяться на вторую, но не наоборот);
— <code>private</code> указывает, что изменения в первой точке монтирования не будут отображаться во второй, и наоборот;
— <code>rshared</code> — то же, что <code>shared</code>, распространяет подобное поведение на все реплики точек монтирования;
— <code>rslave</code> — то же, что <code>slave</code>, распространяет подобное поведение на все реплики точек монтирования;
— <code>rprivate</code> (значение по умолчанию) — то же, что <code>private</code>, распространяет подобное поведение на все реплики точек монтирования.</p>
<p>Пример:</p>
<pre><code class="language-bash">docker run -d \
  -it \
  --name devtest \
  --mount type=bind,source=&quot;$(pwd)&quot;/app/src,target=/app \
  --mount type=bind,source=&quot;$(pwd)&quot;/app/src,target=/app2,readonly,bind-propagation=rslave \
  node:lts
</code></pre>
<p>Папка <em>/app/src</em> на хосте дважды монтируется к разным папкам в контейнере. Вторая точка монтирования имеет дополнительные настройки:</p>
<p>— приложение <em>app2</em> может только читать данные из папки на хосте;
— изменения в первой точке монтирования сразу происходят и во второй, но не наоборот.</p>
<p>Ключ <code>bind-propagation</code> служит для управления хранилищами на продвинутом уровне и, как правило, нужен в специальных задачах. Об этом механизме вы можете почитать подробнее в <a href="https://www.kernel.org/doc/Documentation/filesystems/sharedsubtree.txt">официальной документации Linux</a>.</p>
</details>
<p>Флаг <code>--mount</code> не поддерживает опции для управления метками <a href="https://ru.wikipedia.org/wiki/SELinux">selinux</a> (<code>z</code> и <code>Z</code>).</p>
<p>Проверьте корректность работы хранилища с помощью команды:</p>
<pre><code class="language-bash">docker inspect devtest
</code></pre>
<p>В соответствующей секции <em>Mounts</em> вы сможете найти исчерпывающую информацию. Например, если вы находились в папке <em>/tmp/source/target</em> при запуске контейнера, то в этой секции будет указана примерно следующая информация:</p>
<pre><code class="language-js">&quot;Mounts&quot;: [
    {
        &quot;Type&quot;: &quot;bind&quot;,
        &quot;Source&quot;: &quot;/tmp/source/target&quot;,
        &quot;Destination&quot;: &quot;/app&quot;,
        &quot;Mode&quot;: &quot;&quot;,
        &quot;RW&quot;: true,
        &quot;Propagation&quot;: &quot;rprivate&quot;
    }
],
</code></pre>
<p>Для разрыва связи между папками на хосте и в контейнере выполните команды остановки и удаления контейнера:</p>
<pre><code class="language-bash">docker container stop devtest
docker container rm devtest
</code></pre>
<aside>
<p>☝️ Помните:</p>
<ol>
<li>Связанными папками нельзя управлять из Docker CLI.</li>
<li>Абсолютные пути на разных компьютерах могут быть разными.</li>
<li>Если в контейнере в примонтированной папке есть содержимое, то оно «перекроет» содержимое связанной папки на все время работы контейнера.</li>
<li>Использовать связанные папки для работы с конфигурационными файлами небезопасно.</li>
<li>Файловая система и структура папок могут сильно отличаться на разных компьютерах.</li>
<li>Правила описания путей к файлам могут отличаться при переходе от одной платформы к другой.</li>
<li>Вы можете столкнуться с ситуацией, когда приложение в контейнере получит доступ к системным папкам или удалит критически важные файлы.</li>
</ol>
</aside>
<h2>Тома (volumes)</h2>
<p>Тома — это лучший тип управления данных в Docker. Только объекты или службы Docker должны иметь права на изменение данных, расположенных в томах. На хосте данные хранятся в специальных папках, но без доступа администратора к ним не подобраться. В идеологии Docker тома — что-то вроде образа флэш-накопителя или CD/DVD.</p>
<p>Тома можно размещать не только на хосте. Можно, например, пользоваться облачными платформами для совместной работы с данными или для тестирования приложений. А ещё тома будут работать как с Linux-контейнерами, так и с Windows-контейнерами, поскольку файловая система томов одна и та же.</p>
<p>Когда том примонтирован к контейнеру, операционная система хоста не имеет к нему доступа. Docker управляет томами отдельно, позволяя подключаться одному или нескольким контейнерам одновременно. Плюсом является и то, что том существует самостоятельно и не зависит от жизненного цикла контейнеров.</p>
<p>Тома могут быть созданы при сборке контейнера (с помощью <a href="/tools/docker/">Dockerfile</a> или <a href="/tools/docker-compose/">Docker Compose</a>) или вручную с помощью Docker Engine. Тома могут иметь имя, назначенное пользователем (именованные тома, named volumes), а могут быть анонимными с именем, которое Docker устанавливает автоматически (анонимные тома, anonymous volumes).</p>
<p>Концепция драйвера позволяет преобразовывать данные в томах или влиять на потоки данных между томами и контейнерами. Например, это можно использовать для шифрования. Но чаще с помощью драйверов к контейнеру подключают тома, которые расположены не локально на хосте, а в облаке или на сервере. Это позволяет, не меняя логику работы приложения внутри контейнера, обрабатывать данные, которых на хосте нет.</p>
<p>Итак, возможности томов:</p>
<p>— миграция данных и создание резервных копий;
— управление с помощью Docker CLI или Docker API;
— тома работают и с Linux-, и с Windows-контейнерами;
— данные легко и безопасно можно использовать в нескольких контейнерах;
— существует механизм драйверов, который позволяет хранить данные не только на хосте, но и на сервере или в облаке, шифровать данные в томе или добавлять дополнительную функциональность;
— новые тома могут создаваться с уже загруженными с помощью контейнера данными;
— если на хосте установлены Mac или Windows, тома будут быстрее работать с Docker Desktop, чем связанные папки;
— тома не увеличивают размер контейнера;
— тома находятся вне жизненного цикла контейнера.</p>
<p>Тома используются:</p>
<p><strong>Когда нам нужно получить доступ к данным из разных контейнеров.</strong> Том создаётся в первый раз либо вручную, либо при сборке контейнера. Уничтожается том всегда только с помощью Docker вручную. После остановки контейнера том будет продолжать работать, пока не будет удалён пользователем.</p>
<p><strong>Когда вы не уверены, что путь до папки будет одним и тем же на разных компьютерах.</strong> Тома позволяют повысить уровень абстракции.</p>
<p><strong>Когда вы хотите хранить данные не только у себя на локальном компьютере, но и на сервере или в облаке.</strong></p>
<p><strong>Когда нужно создать резервную копию или перенести тома с одного компьютера на другой.</strong> Тома хранятся в определённой папке на компьютере. Вы можете просто скопировать её, заархивировать и перенести на другой хост. Примерно так же создаётся и резервная копия.</p>
<p><strong>Если ваше приложение требует высокой скорости обмена данными на Mac и Windows.</strong> Тома сохраняются на виртуальной машине Linux VM, на которой работают и контейнеры, поэтому скорость чтения и записи высокая. Нет лишних накладных расходов на доступ к файловой системе хоста.</p>
<p><strong>Когда важно, чтобы файловая система имела нативное поведение.</strong> Например, база данных должна контролировать кэширование на диске для гарантии выполнения транзакций. Файловые системы на Mac и Windows работают не так, как на Linux. Это может привести к ошибкам работы некоторых приложений.</p>
<h3>Как пользоваться</h3>
<p>Создать том можно с помощью флагов <code>-v</code> или <code>--mount</code> при запуске контейнера. Для флага <code>-v</code> можно указать параметр <code>ro</code>, который будет означать использование режима только для чтения. Для флага <code>--mount</code> есть ключ <code>volume-opt</code>, который устанавливает набор опций, разделённых запятыми. Не забывайте, что значения для этого ключа должны быть экранированы кавычками. Работа с томами такова, что изменения в одной точке монтирования в контейнере не будут отображаться в другой точке монтирования (параметр <code>bind-propagation</code> всегда выставлен в значение <code>rprivate</code>).</p>
<p>Подключить том с именем <code>my-vol</code> можно следующим образом.</p>
<p>С флагом <code>--mount</code>:</p>
<pre><code class="language-bash">docker run -d \
  --name devtest \
  --mount source=my-vol,target=/app \
  node:lts
</code></pre>
<p>С флагом <code>-v</code>:</p>
<pre><code class="language-bash">docker run -d \
  --name devtest \
  -v my-vol:/app \
  node:lts
</code></pre>
<p>Проверьте корректность результата выполнения команды:</p>
<pre><code class="language-bash">docker inspect devtest
</code></pre>
<p>Чтобы удалить том, необходимо отключить связанный с ним контейнер и удалить сам контейнер:</p>
<pre><code class="language-bash">docker container stop devtest
docker container rm devtest
docker volume rm my-vol
</code></pre>
<p>Управлять томами можно через Docker API с помощью Docker CLI и Docker Compose.</p>
<p>Чтобы создать новый том <strong>с помощью Docker CLI</strong>, используйте команду:</p>
<pre><code class="language-bash">docker volume create my-vol
</code></pre>
<p>Получите список томов на хосте:</p>
<pre><code class="language-bash">docker volume ls
</code></pre>
<p>Посмотрите информацию о томе:</p>
<pre><code class="language-bash">docker volume inspect my-vol
</code></pre>
<p>Удалите том командой:</p>
<pre><code class="language-bash">docker volume rm my-vol
</code></pre>
<p>Если том был анонимным, то можно удалить его сразу после завершения работы контейнера. Для этого при запуске контейнера вы можете прописать флаг <code>--rm</code>. Вместе с удалением контейнера в этом случае удалится и том:</p>
<pre><code class="language-bash">docker run --rm -v /foo -v awesome:/bar container app
</code></pre>
<p>После завершения работы и последующего удаления контейнера анонимный том удалится, а именованный <code>awesome</code> продолжит работать.</p>
<p>Чтобы удалить все неиспользуемые тома, используйте команду:</p>
<pre><code class="language-bash">docker volume prune
</code></pre>
<p>Для того, чтобы подключить том <strong>с помощью Dockerfile</strong>, необходимо использовать инструкцию <code>VOLUME</code>:</p>
<pre><code class="language-dockerfile">FROM node:lts
RUN useradd user
RUN mkdir /data &amp;&amp; touch /data/x
RUN chown -R user:user /data
VOLUME /data
</code></pre>
<p>Интересно, что вы не сможете внести какие-либо изменения в данные на этапе сборки образа. Следующий <em>Dockerfile</em> правильно работать не будет:</p>
<pre><code class="language-dockerfile">FROM node:lts
RUN useradd user
VOLUME /data
RUN touch /data/x
RUN chown -R user:user /data
</code></pre>
<p>Том будет подключён только после создания образа на этапе запуска контейнера. Возможно, придётся использовать инструкции <code>CMD</code> или <code>ENTRYPOINT</code>. Подробнее описано в статье «<a href="/tools/dockerfile/">Как устроен Dockerfile</a>».</p>
<p>Запустить том для отдельного контейнера <strong>с Docker Compose</strong> можно с помощью следующей конфигурации:</p>
<pre><code class="language-yaml">services:
  frontend:
    image: node:lts
    volumes:
      - myapp:/home/node/app
volumes:
  myapp:
</code></pre>
<p>Команда <code>docker-compose up</code> поднимет не только сам контейнер <code>frontend</code>, но и создаст том <code>myapp</code>. Если он уже был создан, Docker Compose подключит его к контейнеру, но надо указать это явно с помощью элемента <code>external</code> так:</p>
<pre><code class="language-yaml">services:
  frontend:
    image: node:lts
    volumes:
      - myapp:/home/node/app
volumes:
  myapp:
    external: true
</code></pre>
<p>Подробнее о формате конфигурации Docker Compose можно прочитать <a href="/tools/docker-compose/">в статье о Docker Compose</a>.</p>
<h3>Использование драйверов</h3>
<p>Когда приходит время масштабировать приложение, несколько сервисов должны работать с одним хранилищем данных. Для этого существует масса решений, и у Docker есть своё — драйверы для томов. Это лишь один пример использования драйверов. Можно организовать, например, пересылку данных между контейнерами с поддержкой шифрования или автоматическое шифрование и дешифровку всех данных в томе. Можно реализовать любой механизм обработки данных. Драйверы повышают уровень абстракции, позволяя отделить логику работы приложения от системы хранения данных.</p>
<p>Например, есть два компьютера — хост, на котором установлен Docker и запускаются контейнеры, и файловый сервер, который поставляет данные для них. Контейнеры ничего не знают про эту архитектуру: все запускалось изначально на локальном хосте. Драйвер <code>vieux/sshfs</code> позволяет использовать SSH-соединение для связи с файловым сервером, при этом данные будут представлены в виде тома Docker.</p>
<p>Для начала необходимо установить соответствующий плагин для Docker Engine:</p>
<pre><code class="language-bash">docker plugin install --grant-all-permissions vieux/sshfs
</code></pre>
<p>Затем нужно создать том и прописать учётные данные:</p>
<pre><code class="language-bash">docker volume create --driver vieux/sshfs \
  -o sshcmd=test@node2:/home/test \
  -o password=testpassword \
  sshvolume
</code></pre>
<p>Если для связи по SSH между клиентом и сервером уже работают ключи доступа, то пароль можно опустить. Флаг <code>-o</code> указывает на опции, которые могут быть переданы драйверу. Набор доступных опций у каждого драйвера свой.</p>
<p>Можно создать том и другим способом, при запуске контейнера:</p>
<pre><code class="language-bash">docker run -d \
  --name sshfs-container \
  --volume-driver vieux/sshfs \
  --mount src=sshvolume,target=/app,volume-opt=sshcmd=test@node2:/home/test,volume-opt=password=testpassword \
  nginx:latest
</code></pre>
<p>Если драйвер требует передачи опций, приходится использовать флаг <code>--mount</code>.</p>
<h3>Резервные копии</h3>
<p>Для того чтобы создать резервную копию тома, можно использовать механизм контейнеров Docker. Например, вы уже создали контейнер с именем <code>dbstore</code> на базе операционной системы Ubuntu и работаете с данными в томе <code>dbdata</code>. Для этого вы уже выполнили команду и получили доступ к терминалу контейнера:</p>
<pre><code class="language-bash">docker run -v /dbdata --name dbstore node:lts /bin/bash
</code></pre>
<p>Как создать резервную копию данных в томе? Нужно:</p>
<p>— запустить новый контейнер и примонтировать том, который используется в контейнере <code>dbstore</code>;
— примонтировать папку на хосте, чтобы потом в неё положить резервную копию;
— зайти внутри контейнера в том, заархивировать данные и положить их в связанную папку.</p>
<p>Выполните команду:</p>
<pre><code class="language-bash">docker run --rm --volumes-from dbstore -v $(pwd):/backup ubuntu tar cvf /backup/backup.tar /dbdata
</code></pre>
<p>После завершения архивации контейнер выключится и удалится, а резервная копия останется у вас в папке, из которой вы запускали команду.</p>
<p>Допустим, у вас возникла необходимость развернуть данные из сохранённой резервной копии внутри контейнера <code>dbstore2</code>. Нужно запустить его:</p>
<pre><code class="language-bash">docker run -v /dbdata --name dbstore2 node:lts /bin/bash
</code></pre>
<p>Затем разархивировать данные в том:</p>
<pre><code class="language-bash">docker run --rm --volumes-from dbstore2 -v $(pwd):/backup ubuntu bash -c &quot;cd /dbdata &amp;&amp; tar xvf /backup/backup.tar --strip 1&quot;
</code></pre>
<h2>Хранение в оперативной памяти</h2>
<p>Хранение в оперативной памяти бывает двух типов:  <em>tmpfs mounts</em> и <em>npipe mounts</em>.</p>
<p>Механизм <em>tmpfs mount</em> в операционной системе Linux позволяет выделить часть оперативной памяти хоста для хранения данных. Данные не сохраняются в файловой системе, и получается быстрое хранилище. Примонтированная папка <em>tmpfs</em> работает, пока запущен контейнер, поэтому не стоит использовать этот способ для хранения настроек и результатов работы приложения.</p>
<p>Для пользователей операционной системы Windows существует ещё один тип управления данными — <em>npipe mount</em>. Этот тип позволяет получить доступ к хосту Docker из контейнера и в основном используется для управления данными с Docker Engine API.</p>
<p>Используем оперативную память:</p>
<p><strong>Если вы не хотите оставлять данные после завершения работы приложения.</strong></p>
<h3>Как пользоваться</h3>
<p>Этот раздел посвящён использованию только на Linux.</p>
<p>С помощью томов и связанных папок вы можете делиться файлами между хостом и контейнером. После остановки контейнера данные сохраняются. Но если на хосте используется операционная система Linux, то существует и третий тип работы с данными — <em>tmpfs</em>. Это временное файловое хранилище, которое располагается в оперативной памяти, присутствует во многих Unix-подобных системах. Когда вы создаёте контейнер, Docker может создать отдельный слой в оперативной памяти снаружи контейнера для хранения и обработки данных.</p>
<p>При использовании этого типа работы с данными в Docker есть два ограничения:</p>
<p>— операционной системой хоста может быть только Linux;
— данные в <em>tmpfs</em> доступны лишь из одного контейнера.</p>
<p><em>tmpfs</em> хорошо работает в случае хранения чувствительной информации: ключей шифрования, паролей, сертификатов доступа и тому подобного.</p>
<p>Чтобы запустить контейнер с <em>tmpfs</em>, используют команду:</p>
<pre><code class="language-bash">docker run -d \
  -it \
  --name tmptest \
  --mount type=tmpfs,destination=/app \
  node:lts
</code></pre>
<p>С помощью ключа <code>tmpfs-size</code> можно определить максимальный размер хранилища в байтах. По умолчанию он не ограничен. Ключ <code>tmpfs-mode</code> служит для определения уровня доступа в восьмеричном формате. Например, значение по умолчанию <code>1777</code> обозначает, что любой пользователь или программа в контейнере имеют неограниченный доступ к данным, которые будут доступны и вне контейнера. Этот параметр работает также, как и для <a href="https://man.archlinux.org/man/tmpfs"><em>tmpfs</em> в Unix-подобных операционных системах</a>.</p>
<p>Также есть альтернативная более короткая команда для управления <em>tmpfs mounts</em>:</p>
<pre><code class="language-bash">docker run -d \
  -it \
  --name tmptest \
  --tmpfs /app \
  node:lts
</code></pre>
<p>Проверьте состояние контейнера, чтобы убедиться, что файловое хранилище создано корректно:</p>
<pre><code class="language-bash">docker container inspect tmptest
</code></pre>
<p>В соответствующей секции будет доступна информация о примонтированной папке:</p>
<pre><code class="language-js">&quot;Tmpfs&quot;: {
    &quot;/app&quot;: &quot;&quot;
},
</code></pre>
<p>Для удаления слоя с данными выполните команды остановки и удаления контейнера:</p>
<pre><code class="language-bash">docker container stop tmptest
docker container rm tmptest
</code></pre>
