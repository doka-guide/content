<h2>Кратко</h2>
<p><code>Dockerfile</code> — это текстовый файл, в котором описан рецепт создания образа Docker. Рецепт состоит из инструкций, которые выполняются последовательно. Они содержат информацию об операционной системе, выбранной платформе, фреймворках, библиотеках, инструментах, которые нужно установить.</p>
<p>Dockerfile позволяет создавать одинаковое окружение для работы программы, независимо от машины, которая собирает образ. Прочитайте обзорную статью о Docker<!--TODO: Ссылка на статью про Docker-->, чтобы лучше разобраться, зачем это нужно.</p>
<h2>Как понять</h2>
<p>Современные веб-приложения работают очень просто только для пользователя, который может смотреть видео, читать тексты, слушать музыку или заказывать еду «в один клик». Под капотом — это сложный набор приложений, взаимодействующих между собой. Если одно из приложений в цепочке сломается, клиент не сможет решить свою задачу. Важная задача веб-разработчика — сделать приложение максимально живучим в самых разных условиях. Решение задачи заключается в том, чтобы воспроизвести одинаковое, «правильное» поведение веб-приложения.</p>
<p>Docker умеет создать идентичные условия работы приложения, независимо от операционных систем и установленных служб на компьютере разработчика и на сервере. Для этого используется концепция контейнера. Прототипом контейнера является образ, в <code>Dockerfile</code> описывают процесс его создания в виде набора инструкций.</p>
<p>Инструкции записываются построчно. На первом месте указывается команда для Docker, которую нужно выполнить, а затем — список аргументов этой команды:</p>
<pre><code class="language-dockerfile"># Comment
INSTRUCTION arguments
</code></pre>
<p>Образ Docker легче всего представить в виде слоёного пирога или бургера: новый слой — новая инструкция. Образы для типичного веб-приложения могут быть собраны примерно так:</p>
<p><img src="images/docker-images.png" alt="Примеры образов Docker для веб-приложений"></p>
<p>Каждая новая инструкция — новый слой. В качестве инструкции можно выполнить команду в терминале, скопировать файлы внутрь образа или настроить связь с внешним миром с помощью сетевого окружения и томов. Docker объединяет файловые системы отдельных слоёв в одну во время сборки, используя механизм <a href="https://www.terriblecode.com/blog/how-docker-images-work-union-file-systems-for-dummies/">Union File Systems</a>.</p>
<p>Концепция слоёв позволяет Docker оптимальным образом хранить данные на жёстком диске. Docker загружает только те слои, которых не было на компьютере прежде. При этом слой из одного образа может подойти и к другому.</p>
<p>После того как слои образа описаны в файле конфигурации, необходимо произвести сборку образа с помощью команды:</p>
<pre><code class="language-bash">docker build
</code></pre>
<h2>Как пишется</h2>
<p>Работу с <code>Dockerfile</code> можно разбить на два этапа: описание инструкций и сборка образа. Набор инструкций — последовательность действий, чтобы собрать образ.</p>
<h3>Описание инструкций <code>Dockerfile</code></h3>
<h4><code>FROM</code>. Установка базового образа</h4>
<p>Dockerfile обычно начинается с инструкции <code>FROM</code>. Эта инструкция задаёт базовый образ.</p>
<p>В качестве базового образа может быть использован образ с чистой операционной системой, образ с уже установленной и настроенной платформой или вообще любой другой образ. Вот так можно установить Ubuntu 18.04 как базовый образ:</p>
<pre><code class="language-dockerfile">FROM ubuntu:18.04
</code></pre>
<p>Для веб-приложения на <a href="/tools/nodejs/">Node.js</a> обычно используют <a href="https://hub.docker.com/_/node">официальный образ от команды Docker</a>:</p>
<pre><code class="language-dockerfile">FROM node
</code></pre>
<h4><code>RUN</code>. Запуск команд терминала</h4>
<p>Инструкция <code>RUN</code> позволяет запускать команды терминала при сборке. Это самая используемая инструкция, ей можно создать папку, установить недостающие пакеты или запустить shell скрипт.</p>
<p>Например, установим платформу Node.js<!--TODO: Ссылка на обзорную статью о Node.js--> поверх образа с чистой Ubuntu:</p>
<pre><code class="language-dockerfile">FROM ubuntu:18.04
RUN sudo apt update &amp;&amp; sudo apt install nodejs &amp;&amp; sudo apt install npm
</code></pre>
<p>При сборке образа теперь будет произведена установка последней версии Node.js.</p>
<h4><code>COPY</code> и <code>ADD</code>. Копирование файлов проекта</h4>
<p>Инструкции <code>COPY</code> и <code>ADD</code> позволяют перенести файлы с компьютера, который запускает сборку, внутрь образа.</p>
<p>Например, перенесём все содержимое папки, где лежит <code>Dockerfile</code> в папку <code>/app</code> внутри образа:</p>
<pre><code class="language-dockerfile">FROM ubuntu:18.04
RUN sudo apt update &amp;&amp; sudo apt install nodejs &amp;&amp; sudo apt install npm
COPY . /app
</code></pre>
<aside>
<p>☝️ Используйте <code>COPY</code>, она только копирует указанную папку во внутреннюю папку образа. Инструкция <code>ADD</code> слишком всемогущая и можно случайно использовать её неверно. Например, она может скачать файл из Интернета перед копированием или разархивировать архив.</p>
</aside>
<h4><code>ENTRYPOINT</code> и <code>CMD</code>. Запуск приложения</h4>
<p>После того как образ готов, необходимо запустить приложение, которое в нем содержится. Образы Docker задумывались как упаковка для приложения, поэтому нет ничего удивительного в существовании механизма запуска приложения при старте контейнера на основе собранного образа. Для этого используют одну из двух инструкций: <code>ENTRYPOINT</code> и <code>CMD</code>.</p>
<p>Инструкция <code>ENTRYPOINT</code> используется для запуска приложения при старте контейнера:</p>
<pre><code class="language-dockerfile">FROM ubuntu:18.04
RUN sudo apt update &amp;&amp; sudo apt install nodejs &amp;&amp; sudo apt install npm
COPY . /app
ENTRYPOINT [&quot;node&quot;, &quot;/app/app.js&quot;]
</code></pre>
<p>В отличие от инструкции <code>RUN</code> эта инструкция получает полный доступ к инфраструктуре терминала на компьютере пользователя. Вместе с командой запуска контейнера вы можете передавать параметры команде, которая прописана после <code>ENTRYPOINT</code> или пользоваться системой <a href="https://ru.wikipedia.org/wiki/%D0%A1%D0%B8%D0%B3%D0%BD%D0%B0%D0%BB_(Unix)">сигналов Linux</a>. Внутрь образа можно положить программу и запускать её внутри контейнера, передавая через параметры текстовые файлы со своего компьютера. Например, можно упаковать в контейнер утилиту для проверки орфографии <a href="https://github.com/hcodes/yaspeller/blob/master/README.ru.md">yaspeller</a>. В примере ниже она используется для проверки орфографии слов на русском и английском языках в файлах с расширением <code>*.md</code> и <code>*.txt</code>:</p>
<pre><code class="language-dockerfile">FROM node
RUN npm install yaspeller -g
ENTRYPOINT [&quot;yaspeller&quot;]
</code></pre>
<p>Затем необходимо собрать образ, указав явно имя образа для удобства:</p>
<pre><code class="language-bash">docker build -t yaspeller .
</code></pre>
<p>Запускать проверку орфографии в любой папке для файлов с расширением <code>*.md</code> и <code>*.txt</code> можно теперь простой командой:</p>
<pre><code class="language-bash">docker run --rm yaspeller .
</code></pre>
<p>Вместо <code>.</code> можно писать название файла или папки. Ключ <code>--rm</code> означает, что после завершения работы контейнер удалится из списка использованных Docker. Это важно, поскольку, пока контейнер хранится в этом списке, нельзя запустить контейнер с таким же именем, несмотря на то, что контейнер уже отработал и не используется.</p>
<p>Инструкция <code>CMD</code> делает практически то же самое. Обычно это также команда запуска приложения:</p>
<pre><code class="language-dockerfile">FROM ubuntu:18.04
RUN sudo apt update &amp;&amp; sudo apt install nodejs &amp;&amp; sudo apt install npm
COPY . /app
CMD [&quot;node&quot;, &quot;/app/app.js&quot;]
</code></pre>
<p><code>CMD</code> — инструкция запуска по умолчанию, она игнорируется в том случае, если пользователь вашего образа прописывает в явном виде, что и как запускать после запуска контейнера на основе образа. Обычно <code>CMD</code> вообще используется для передачи параметров по умолчанию вашему приложению, которые пользователь может переопределить.</p>
<p>В чем же разница между <code>ENTRYPOINT</code> и <code>CMD</code>? В ваших намерениях.</p>
<aside>
<p>☝️ Используйте <code>ENTRYPOINT</code>, если вы не хотите, чтобы пользователь вашего образа переопределял поведение приложения в контейнере. Используйте <code>CMD</code>, если записываете команду по умолчанию, которую пользователь с лёгкостью может переопределить на этапе запуска контейнера.</p>
</aside>
<p>Есть две формы записи аргументов <code>ENTRYPOINT</code> и <code>CMD</code>: в виде строки и в виде массива строк. Первый вариант (так называемый <strong>shell</strong> режим) используется редко, поскольку не позволяет гибко настраивать работу образа. Обычно используется второй вариант (так называемый  <strong>exec</strong> режим) — массив строк, который может состоять из команды и её параметров. Среди аргументов инструкции <code>CMD</code> строка с командой может и отсутствовать, если эта инструкция идёт после инструкции <code>ENTRYPOINT</code>. В этом случае строки массива рассматриваются как аргументы по умолчанию для команды, обозначенной в <code>ENTRYPOINT</code>.</p>
<h4><code>ENV</code>. Переменные окружения</h4>
<p>Переменные окружения задаются инструкцией <code>ENV</code>.</p>
<p>Через переменные окружения передают ключи и пароли к сервисам, режим работы, другие секретные и не очень значения. Например, запуск приложения Node.js для конечного пользователя обозначается дополнительной инструкцией:</p>
<pre><code class="language-dockerfile">FROM ubuntu:18.04
RUN sudo apt update &amp;&amp; sudo apt install nodejs &amp;&amp; sudo apt install npm
COPY . /app
ENV NODE_ENV=production
CMD [&quot;node&quot;, &quot;/app/app.js&quot;]
</code></pre>
<h4><code>WORKDIR</code>. Рабочая папка проекта</h4>
<p>Инструкция <code>WORKDIR</code> задаёт рабочую папку приложения. Все инструкции в <code>Dockerfile</code> будут выполняться относительно неё.</p>
<p>Устанавливать рабочую папку — хороший тон. Она позволяет явно указать место, где будет происходить вся работа. Добавим её в нашу конфигурацию:</p>
<pre><code class="language-dockerfile">FROM ubuntu:18.04
RUN sudo apt update &amp;&amp; sudo apt install nodejs &amp;&amp; sudo apt install npm
WORKDIR /app
COPY . .
ENV NODE_ENV=production
CMD [&quot;node&quot;, &quot;app.js&quot;]
</code></pre>
<h4><code>USER</code>. Запуск от имени пользователя</h4>
<p>Если приложение нужно запускать от имени пользователя системы, то используйте инструкцию <code>USER</code> с именем пользователя. Например, если вы хотите запускать приложение от имени пользователя <code>node_user</code>, то конфигурационный файл будет выглядеть так:</p>
<pre><code class="language-dockerfile">FROM ubuntu:18.04
RUN sudo apt update &amp;&amp; sudo apt install nodejs &amp;&amp; sudo apt install npm
WORKDIR /app
COPY . .
ENV NODE_ENV=production
USER node_user
CMD [&quot;node&quot;, &quot;app.js&quot;]
</code></pre>
<h4><code>EXPOSE</code>. Проброска порта вовне</h4>
<p>Для запуска веб-приложения на компьютере вы используете веб-сервер, запущенный локально. Обычно веб-приложение становится доступным по адресу <code>http://localhost:8080</code>. Цифры в конце означают порт, открытый для запросов со стороны браузера или других приложений. Чтобы открыть в браузере веб-приложение, запущенное внутри контейнера, нужно «пробросить» запросы от браузера внутрь контейнера, а ответ от веб-приложения из контейнера наружу. Для этого используется перенаправление пакетов в виртуальном сетевом окружении (Docker Network):</p>
<p><img src="images/docker-expose.png" alt="Проброска портов образов Docker для веб-приложений"></p>
<p><code>EXPOSE</code> незаменим, когда в образе находится база данных и нам нужен доступ к ней вне контейнера. Для этого используется инструкция <code>EXPOSE</code>:</p>
<pre><code class="language-dockerfile">FROM ubuntu:18.04
RUN sudo apt update &amp;&amp; sudo apt install nodejs &amp;&amp; sudo apt install npm
WORKDIR /app
COPY . .
ENV NODE_ENV=production
USER node_user
EXPOSE 8080
CMD [&quot;node&quot;, &quot;app.js&quot;]
</code></pre>
<p>Запись <code>EXPOSE 8080</code> означает, что на компьютере, на котором запущен Docker, веб-приложение будет доступно по адресу <code>http://localhost:8080</code>.</p>
<h4><code>ARG</code>. Аргументы командной строки</h4>
<p>Во время сборки образа не всегда удобно, а иногда даже опасно, описывать все параметры внутри <code>Dockerfile</code>, поскольку этот файл обычно доступен в репозитории большинству разработчиков. В случае публичного репозитория это недопустимо вовсе. В этом случае следует пользоваться переменными, значения которых задаются на этапе сборки образа.</p>
<p>Передавать данные можно с помощью аргументов команды <code>docker build</code> на этапе сборки образа. Во время сборки эти аргументы можно использовать как переменные, достаточно их определить инструкцией <code>ARG</code>. Можно задать и значения по умолчанию на тот случай, если пользователь не укажет нужные аргументы. Например, передать имя пользователя внутрь контейнера можно следующим образом:</p>
<pre><code class="language-bash">docker build --build-arg user=node_user .
</code></pre>
<p>В <code>Dockerfile</code> надо будет добавить соответствующие инструкции:</p>
<pre><code class="language-dockerfile">FROM ubuntu:18.04
RUN sudo apt update &amp;&amp; sudo apt install nodejs &amp;&amp; sudo apt install npm
WORKDIR /app
COPY . .
ENV NODE_ENV=production
# Значение по умолчанию 'deploy' (можно не указывать)
ARG user=deploy
USER $user
EXPOSE 8080
CMD [&quot;node&quot;, &quot;app.js&quot;]
</code></pre>
<p>Важно, что так не следует передавать секретные данные, поскольку их можно будет увидеть в истории Docker:</p>
<pre><code class="language-bash">docker history
</code></pre>
<p>Для безопасной передачи секретных данных лучше использовать тома Docker.</p>
<h4>Многоступенчатая сборка образа</h4>
<p>С точки зрения оптимизации сборки, уменьшения размера образа и ускорения приложения, образ можно собирать в несколько этапов. Например, с помощью платформы Node.js произвести сборку веб-приложения на первом этапе, а на втором — запустить готовый бандл с помощью веб-сервера. Операция копирования из первого промежуточного образа во второй целевой пройдёт совершенно незаметно. После сборки образ будет занимать мало дискового пространства, в нем будет все самое необходимое для работы веб-приложения:</p>
<pre><code class="language-dockerfile"># Сборка проекта на платформе Node.js
FROM node:lts-alpine as build-stage
WORKDIR /app
COPY package*.json ./
RUN npm install
COPY . .
RUN npm run build

# Запуск приложения на сервере
FROM nginx:stable-alpine as production-stage
COPY --from=build-stage /app/dist /usr/share/nginx/html
EXPOSE 80
CMD [&quot;nginx&quot;, &quot;-g&quot;, &quot;daemon off;&quot;]
</code></pre>
<p>Имя промежуточного образа <code>build-stage</code> служит для передачи результата работы первой стадии сборки.</p>
<h3>Рекомендации</h3>
<p>Для того чтобы использовать образы эффективнее, необходимо следовать рекомендациям от команды Docker:</p>
<ol>
<li>Нужно создавать образы так, чтобы жизненным циклом контейнера можно было удобно управлять. Образ не должен хранить внутреннее состояние. Данные внутрь образа можно передать на этапе сборки с помощью аргументов командной строки, а на этапе работы контейнера можно пользоваться томами Docker.</li>
<li>Необходимо понимать контекст запуска веб-приложения: папка проекта, удалённый ресурс (remote source) или репозиторий.</li>
<li>Надо понимать, что <code>Dockerfile</code> может запускаться вне контекста через стандартный поток ввода.</li>
<li>Используйте файл <code>.dockerignore</code> для того, чтобы в образ попадали только нужные файлы и папки. От всего лишнего лучше избавиться на этапе сборки.</li>
<li>Используйте сборку приложения в несколько стадий. Это позволит существенно уменьшить размер образа.</li>
<li>Не устанавливайте то, что не будете использовать в образе.</li>
<li>Необходимо разделять приложения на обособленные части, которые способны выполняться независимо. Этот процесс носит название декаплинга (Decoupling).</li>
<li>Минимизируйте количество слоёв в образе. Это повышает производительность образа как при сборке, так и при работе контейнера.</li>
<li>Если параметры инструкции записываются в несколько строк (с помощью символа переноса строки <code>\</code>) необходимо выстраивать аргументы в алфавитном порядке. Это повышает читаемость файла и упрощает отладку.</li>
<li>Используйте кэш Docker только для тех слоёв, которые будут нужны для сборки других образов. Для этого достаточно добавить параметр <code>--no-cache=true</code> в команду сборки <code>docker build</code>.</li>
</ol>
<h3>Сборка образа</h3>
<p>Образ Docker можно собрать тремя способами:</p>
<p>– указав путь к папке <code>PATH</code>;
– указав путь к репозиторию <code>URL</code>;
– используя стандартный поток ввода <code>–</code>.</p>
<p>Чаще всего используется первый способ с указанием пути. Самая простая команда для сборки образа:</p>
<pre><code class="language-bash">docker build .
</code></pre>
<p>С помощью этой команды собираться образ будет из текущей папки (<code>.</code> в конце), в которой должен быть <code>Dockerfile</code>.</p>
<h4>Использование нескольких <code>Dockerfile</code></h4>
<p>Иногда возникает необходимость использования нескольких вариантов сборок в одном проекте. В этом случае не обойтись без нескольких файлов с инструкциями. При сборке можно указать другое имя для файла конфигурации или относительный путь внутри <code>PATH</code>, нужно использовать флаг <code>-f</code>:</p>
<pre><code class="language-bash">docker build -f containers/dockerfile-mode-1 .
</code></pre>
<p>Точно так же можно указать относительный путь для проекта или репозитория по некоторому <code>URL</code>. Например, Docker может скачать не только репозиторий GitHub, но и произвольный архив с проектом, распаковать его и собрать образ:</p>
<pre><code class="language-bash">docker build -f ctx/Dockerfile http://server/ctx.tar.gz
</code></pre>
<p>Поддерживаются архивы форматов bzip2, gzip, xz.</p>
<p>Файлы и папки проекта, исполняемый файл приложения, архив или репозиторий <a href="/tools/version-control/">Git</a> составляют <code>контекст</code> образа. Но Docker позволяет собирать образы без <code>контекста</code> из стандартного потока ввода. Собрать такой образ можно командой:</p>
<pre><code class="language-bash">docker build - &lt; Dockerfile
</code></pre>
<h4>Исключение файлов из сборки <code>.dockerignore</code></h4>
<p>Если вам не нужно включать в образ какие-то папки или файлы из <code>контекста</code>, добавьте в папку файл исключений <code>.dockerignore</code>. В этом файле перечисляются в отдельных строках все пути или маски путей, которые не должны быть помещены в образ. Пример файла:</p>
<pre><code class="language-bash"># Комментарий
*/temp*
*/*/temp*
temp?
</code></pre>
<p>– <code>*/temp</code> позволяет не включать в образ файлы или папки, имена которых начинаются на <code>temp</code>, и которые находятся в любой папке первого уровня (например, <code>/somedir/temporary.txt</code> или <code>/somedir/temp</code>);
– <code>*/*/temp*</code> — делает то же, но для папок второго уровня;
– <code>temp?</code> — позволяет не включать в образ файлы и папки из корневой папки образа, имена которых начинаются на <code>temp</code> и состоят из пяти символов, последний из которых может быть любым.</p>
