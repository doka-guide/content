<h2>Кратко</h2>
<p>Современные операционные системы позволяют нескольким пользователям одновременно работать на одном компьютере. При этом ресурсы компьютера должны правильно распределяться между приложениями, которые запускают пользователи. Для этого в операционной системе используется специальная абстракция — «процесс».</p>
<p>Под процессом чаще всего понимают отдельное работающее приложение, но бывают приложения, которые используют несколько процессов. Например, браузер Chrome под каждую вкладку создаёт отдельный процесс. Процесс — это абстракция операционной системы, которая позволяет выделять процессорное время и память компьютера для работы программы. Операционная система запускает процессы на короткое время поочерёдно. <a href="https://ru.wikipedia.org/wiki/%D0%94%D0%B8%D1%81%D0%BF%D0%B5%D1%82%D1%87%D0%B5%D1%80_%D0%BE%D0%BF%D0%B5%D1%80%D0%B0%D1%86%D0%B8%D0%BE%D0%BD%D0%BD%D0%BE%D0%B9_%D1%81%D0%B8%D1%81%D1%82%D0%B5%D0%BC%D1%8B">Диспетчер операционной системы</a> помещает отдельные операции из разных процессов в очередь. Когда очередь подошла, операция выполняется.</p>
<p>Для управления процессами операционная система использует механизм прерываний. Процессы можно останавливать или ставить на паузу, перезапускать различными способами, сообщать процессам об изменении состояния системы и прочее. Прерывания в операционных системах реализованы по-разному. В Unix-подобных системах существует несколько механизмов реализации прерываний. Один из них — управления процессами с помощью сигналов, описанный в стандарте <a href="https://ru.wikipedia.org/wiki/POSIX">POSIX</a> для Unix-подобных операционных систем.</p>
<h2>Как понять</h2>
<p>Первые операционные системы были однозадачные. Разработаны они были для компьютеров с одним процессором. В каждый момент времени работать могла только одна программа. Пока она не завершится, нельзя запустить другую программу. Все ресурсы компьютера используются для работы только одной программы:</p>
<p><img src="images/1.png" alt="Работа процессов в однопоточных операционных системах"></p>
<p>Вскоре выяснилось, что такой механизм не очень хорошо работает. Программы могут запрашивать данные у внешних устройств или ждать ввода данных от пользователя, и процессор все это время простаивает. Хочется использовать процессор эффективнее, загружая выполнением других программ. Для этого операционная система стала разбивать программы на блоки. Каждый блок выбирался так, чтобы процессор не простаивал.</p>
<p>Например, можно было сделать так:</p>
<ul>
<li>выполняется блок программы до тех пор, пока не запросит данные у пользователя;</li>
<li>далее выполняется блок другой программы, пока данные не будут получены;</li>
<li>после этого выполняется блок первой программы, пока программа не отправит данные на печать;</li>
<li>пока печатаются данные, выполняется блок второй программы.</li>
</ul>
<p>Следующим шагом было внедрение специального диспетчера операционной системы. Главная задача диспетчера — максимально эффективно использовать процессор. Для этого все программы бились уже не на блоки, а на отдельные операции (команды для процессора). Процессор заблокирован, пока команда не выполнится полностью. На схеме показано, как диспетчер использует очередь готовых к запуску программ (процессов в терминах операционной системы):</p>
<p><img src="images/2.png" alt="Очередь готовых к запуску процессов в многопоточных операционных системах"></p>
<p>Диспетчер операционной системы распределяет процессы в очереди в порядке приоритета. Такая очередь называется <em>очередью готовых к запуску</em>. Например, системным процессам назначается наивысший приоритет. Приоритет означает количество процессорного времени, которое будет отдано процессу. В некоторых операционных системах приоритетом процессов можно управлять. Linux одна из таких операционных систем. Все процессы в Linux имеют свой приоритет, который задаётся числом от -20 (наивысший приоритет) до 19 (наименьший приоритет). Любой пользователь может понижать приоритет процесса, но только суперпользователь может его увеличивать. Управление приоритетом возможно как на этапе запуска, так и на этапе работы процесса.</p>
<p>После создания одной очереди, оказалось, что и это не совсем оптимальный механизм работы с несколькими процессами. Всё дело в том, что разные внешние устройства работают за разное время. Какие-то устройства работают в автоматическом режиме, какие-то в ручном (с участием пользователя). Решили, что было бы здорово сделать несколько очередей, каждая из которых обеспечивает доступ до какого-то определённого ресурса:</p>
<p><img src="images/3.png" alt="Множественная очередь для процессов в многопоточных операционных системах"></p>
<p>Например, существуют очереди для доступа к клавиатуре или принтеру, видеокарте или накопителю (HDD, SSD, Flash-drive и так далее). На рисунке разные устройства обозначены буквами (A, B и так далее).</p>
<p>Процесс для операционной системы — это не просто совокупность операций или код программы. Для того чтобы процессор мог возвращаться к выполнению программы, в операционной системе должны хранится промежуточные результаты выполнения программы, состояние процессора на момент перехода к другому процессу (контекст) и значения переменных (данные программы):</p>
<p><img src="images/4.png" alt="Как устроен процесс в операционной системе"></p>
<p>Для операционной системы процесс состоит из трёх частей: программы, контекста и данных. Программа — это последовательность операций над данными, записанная в оперативной памяти. Данные программ располагаются в оперативной памяти и на внешних устройствах. Перед выполнением очередной операции программы все требуемые данные должны быть загружены в оперативную память компьютера.</p>
<p>Контекст позволяет операционной системе отложить процесс на некоторое время, а затем вернуться к нему, когда это будет возможно. Контекст процесса, например, может содержать следующие данные:</p>
<ul>
<li>состояние регистров процессора;</li>
<li>состояние стека программы;</li>
<li>состояние стека операционной системы;</li>
<li>состояния зарезервированной памяти.</li>
</ul>
<p>Контекст необходим для того, чтобы можно было реализовать работу диспетчера операционной системы, обеспечить межпроцессное взаимодействие и обмен информацией между процессами и операционной системой.</p>
<p>У процесса всегда есть приоритет, который позволяет помещать процесс в нужное место очереди. В первую очередь выполняются процессы, имеющие в операционной системе наивысший приоритет. Операционная система использует специальную структуру данных <a href="https://ru.wikipedia.org/wiki/%D0%9E%D1%87%D0%B5%D1%80%D0%B5%D0%B4%D1%8C_%D1%81_%D0%BF%D1%80%D0%B8%D0%BE%D1%80%D0%B8%D1%82%D0%B5%D1%82%D0%BE%D0%BC_(%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5)"><em>очередь с приоритетом</em></a> в качестве абстракции для реализации механизма выполнения процессов на процессоре компьютера.</p>
<p>Каждому процессу соответствует набор состояний. В современных операционных системах набор состояний сводится к следующим пяти:</p>
<p><img src="images/5.png" alt="Состояния процесса"></p>
<p>Состояние «блокирован» соответствует случаю, когда процесс, например, ожидает ответа от внешнего устройства: ввод с клавиатуры или ответ от накопителя. Количество состояний увеличивается, если ввести возможность приостанавливать процесс в момент того, когда он, например, заблокирован или готов продолжить свою работу:</p>
<p><img src="images/6.png" alt="Состояния процесса в случае использования возможности приостановить процесс"></p>
<h3>Прерывания</h3>
<p>Чтобы можно было управлять процессами на уровне операционной системы, существует механизм прерываний. Когда происходит прерывание, выполнение процесса прерывается и совершается какое-то действие. Например, можно приостановить процесс или переместить из одной очереди в другую. Часть прерываний обрабатываются только операционной системой, другую часть можно слушать и реагировать на них, аналогично событиям в DOM. Прерывания делятся на две группы: прерывания на уровне железа, и программные прерывания.</p>
<p>Механизм прерываний из первой группы реализован на уровне процессора и используется в основном для работы с внешними устройствами. Операционная система может получить доступ к прерываниям, но управлять может только с позиции установки настроек для процессора (разрешать или запрещать определённые прерывания). Программы могут использовать прерывания для взаимодействия с другими программами и для взаимодействия с внешними устройствами на уровне железа. Программе прерывание передаётся как событие, по наступлению которого выполняется заранее заготовленный разработчиками код (обработчик прерывания).</p>
<p>По типу источника «железные» прерывания делятся на:</p>
<ul>
<li>внешние, асинхронные, получаемые от внешних устройств: сигнал от аппаратного таймера или сетевой карты, готовность передать информацию с дискового накопителя, нажатие клавиш клавиатуры, движение мыши;</li>
<li>внутренние, синхронные, возникающие в самом процессоре: переполнение стека, деление на ноль, обращение к недопустимым адресам памяти или недопустимый код операции.</li>
</ul>
<p>Вторая группа прерываний (программные прерывания) реализуются на уровне операционной системы. Программные прерывания инициируются специальной инструкцией в коде программы. Программные прерывания, например, используются для пересылки данных между процессами или работы драйверами внешних устройств.</p>
<p>Реализация программных прерываний зависит от операционной системы. Например, в Windows в основном используется модель событий. Когда событие наступает программе посылается специальное сообщение. Это может быть использовано для реализации взаимодействия пользователя с интерфейсом окна или для обмена данными между программами. Однако модель сообщений очень ограничена в функциональности. Например, остановить или перезапустить программу с помощью сообщений не получится.</p>
<p>В Unix-подобных операционных системах используется модель сигналов, которые могут посылаться программам как со стороны пользователя, так и со стороны операционной системы. Когда программа получает сигнал, выполнение программы прерывается, и исполняется заранее заготовленный код (обработчик сигнала).</p>
<p>В рамках стандарта POSIX описан <a href="https://ru.wikipedia.org/wiki/%D0%9A%D0%B0%D1%82%D0%B5%D0%B3%D0%BE%D1%80%D0%B8%D1%8F:%D0%A1%D0%B8%D0%B3%D0%BD%D0%B0%D0%BB%D1%8B_POSIX">набор стандартных сигналов</a> операционной системы, которые можно обрабатывать в программах. Однако можно устанавливать и свои сигналы, стандарт этого не запрещает.</p>
<p>Вот список наиболее используемых сигналов:</p>
<ol>
<li><code>SIGINT</code> — прервать процесс (тип — управление). Сигнал сообщает процессу, что пользователь собирается остановить процесс из терминала.</li>
<li><code>SIGKILL</code> — завершить процесс (тип — исключение). Сигнал сообщает процессу, что операционная система немедленно останавливает процесс. Этот сигнал нельзя проигнорировать или перехватить.</li>
<li><code>SIGSTOP</code> — остановить выполнение процесса (тип — управление). Сигнал сообщает процессу, что операционная система принудительно останавливает процесс.</li>
<li><code>SIGCONT</code> — продолжить выполнение ранее остановленного процесса (тип — управление). Сигнал сообщает процессу, что операционная система собирается продолжить выполнение процесса.</li>
<li><code>SIGTRAP</code> — остановить выполнение процесса в брейкпоинте в программе (тип — отладка). Сигнал сообщает отладчику, что наступило интересующее событие в программе.</li>
</ol>
<p>Сигналы можно послать работающему процессу:</p>
<p>— из терминала с помощью сочетания клавиш на клавиатуре;
— с помощью ядра операционной системы;
— из одного процесса другому (или самому себе).</p>
<p>Вот несколько наиболее распространённых сигналов, которые можно послать текущему процессу из терминала:</p>
<p>— <code>SIGINT</code>, нажав на клавиатуре <kbd>Ctrl C</kbd>;
— <code>SIGQUIT</code>, нажав на клавиатуре <kbd>Ctrl \</kbd>;
— <code>SIGTSTP</code>, нажав на клавиатуре <kbd>Ctrl Z</kbd>.</p>
