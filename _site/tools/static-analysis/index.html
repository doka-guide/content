<h2>Кратко</h2>
<p>Часто можно сказать, насколько код программы корректен, даже не запуская её. Процесс исследования исходного кода без запуска называют <strong>статическим анализом</strong> или <strong>линтингом</strong>, а программу, которая это делает — <strong>статическим анализатором</strong> или <strong>линтером</strong>.</p>
<p>Самый популярный линтер для JavaScript — это <strong>ESLint</strong>. Он находит участки кода, которые могут потенциально привести к ошибкам, и сообщает об этом.</p>
<h2>Как пользоваться</h2>
<p>Чтобы воспользоваться ESLint, нужно установить его через <a href="/tools/package-managers/">менеджер зависимостей</a> в папке проекта:</p>
<pre><code class="language-bash">npm install --save-dev eslint
</code></pre>
<p>После установки нужно инициализировать конфигурационный файл <code>.eslintrc.json</code>:</p>
<pre><code class="language-bash">npx eslint --init
</code></pre>
<p>В созданный файл можно добавлять правила, по которым линтер будет работать. Обычно используют стандартную конфигурацию, поверх которой добавляют правила, подходящие для конкретного проекта.</p>
<pre><code class="language-js">{
  // ...
  &quot;extends&quot;: &quot;eslint:recommended&quot;,
  // ...
}
</code></pre>
<p>Теперь можно добавить в <code>package.json</code> новый скрипт, который будет запускать статический анализ:</p>
<pre><code class="language-js">{
  // ...
  &quot;scripts&quot;: {
    &quot;lint&quot;: &quot;eslint ./**/*.js&quot;
  }
  // ...
}
</code></pre>
<p>После запуска линтера командой <code>npm run lint</code>, в консоли появится результат его работы.</p>
<p>Для наглядности положим в папку проекта JavaScript-файл с ошибками, которые ESLint способен отловить.</p>
<pre><code class="language-js">// script.js

let x = 12

// Сравнения с -0 запрещены стандартной конфигурацией ESLint
// При запуске он выведет ошибку
if (x === -0) {
  console.log(&quot;Hello!&quot;)
}
</code></pre>
<h2>Как понять</h2>
<p>Линтер — это программа, которая разбирает исходный код на стандартизированные кусочки, а потом даёт эти кусочки на проверку специальным <strong>плагинам</strong>. Плагин получает разобранный участок кода и проверяет его на корректность по ряду <strong>правил</strong>, которые определены в этом плагине.</p>
<p>Советы линтера — это не абсолютная истина. Скорее подсветка спорных моментов, на которые стоит обратить внимание.</p>
<p>Типичные проблемы, которые отлавливают линтеры:</p>
<ul>
<li>неоднозначности, которые могут быть понятны автору, но запутают других разработчиков (например, <a href="https://eslint.org/docs/rules/no-cond-assign">присваивание в условном операторе</a>);</li>
<li>особенности языка, которые легко забыть, но просто проверить автоматически (например, <a href="https://eslint.org/docs/rules/valid-typeof">проверка результата вызова typeof</a>);</li>
<li>потенциальные проблемы производительности (например, <a href="https://eslint.org/docs/rules/no-await-in-loop#disallow-await-inside-of-loops-no-await-in-loop">ожидание асинхронной функции в цикле</a>);</li>
<li>использования не принятых в языке конструкций (например, <a href="https://eslint.org/docs/rules/no-implicit-coercion">неявное приведение типов</a>);</li>
</ul>
<p>Например:</p>
<pre><code class="language-js">// проблему в такой функции можно отловить статическим анализом
async function parseFiles(files) {
  const data = []

  // parseFile будет вызываться последовательно
  // сначала будет обработан первый файл
  // потом второй, третий и так далее
  for (const file of files) {
    const parsed = await parseFile(file)
    data.push(parsed)
  }

  return data
}

// линтер может предложить переписать функцию так
async function parseFiles(files) {
  // parseFile вызовется для всех файлов почти одновременно
  const data = await Promise.all(files.map((file) =&gt; parseFile(file)))

  return data
}
</code></pre>
<p>Подобные исправления не всегда будут корректны, иногда разработчику правда нужно обрабатывать файлы последовательно. Но чаще всего, это не так. Статический анализатор обратит внимание программиста на это место, а программист уже решит — актуальна ли эта проблема для конкретного кейса.</p>
<p>Статический анализатор работает только с исходными текстами программы, но никогда не запускает само приложение. Поэтому, не все проблемы можно отловить линтингом. Статический анализ — это отличное дополнение к другим способам проверки кода: код-ревью, юнит и интеграционным тестам.</p>
